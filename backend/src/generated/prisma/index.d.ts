
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model client
 * 
 */
export type client = $Result.DefaultSelection<Prisma.$clientPayload>
/**
 * Model client_details
 * 
 */
export type client_details = $Result.DefaultSelection<Prisma.$client_detailsPayload>
/**
 * Model client_parameter
 * 
 */
export type client_parameter = $Result.DefaultSelection<Prisma.$client_parameterPayload>
/**
 * Model client_service
 * 
 */
export type client_service = $Result.DefaultSelection<Prisma.$client_servicePayload>
/**
 * Model invoice
 * 
 */
export type invoice = $Result.DefaultSelection<Prisma.$invoicePayload>
/**
 * Model invoice_detail
 * 
 */
export type invoice_detail = $Result.DefaultSelection<Prisma.$invoice_detailPayload>
/**
 * Model log
 * 
 */
export type log = $Result.DefaultSelection<Prisma.$logPayload>
/**
 * Model payment
 * 
 */
export type payment = $Result.DefaultSelection<Prisma.$paymentPayload>
/**
 * Model payment_attachment
 * 
 */
export type payment_attachment = $Result.DefaultSelection<Prisma.$payment_attachmentPayload>
/**
 * Model payment_method
 * 
 */
export type payment_method = $Result.DefaultSelection<Prisma.$payment_methodPayload>
/**
 * Model permission
 * 
 */
export type permission = $Result.DefaultSelection<Prisma.$permissionPayload>
/**
 * Model quote
 * 
 */
export type quote = $Result.DefaultSelection<Prisma.$quotePayload>
/**
 * Model quote_attachment
 * 
 */
export type quote_attachment = $Result.DefaultSelection<Prisma.$quote_attachmentPayload>
/**
 * Model quote_detail
 * 
 */
export type quote_detail = $Result.DefaultSelection<Prisma.$quote_detailPayload>
/**
 * Model role
 * 
 */
export type role = $Result.DefaultSelection<Prisma.$rolePayload>
/**
 * Model role_permission
 * 
 */
export type role_permission = $Result.DefaultSelection<Prisma.$role_permissionPayload>
/**
 * Model service
 * 
 */
export type service = $Result.DefaultSelection<Prisma.$servicePayload>
/**
 * Model service_category
 * 
 */
export type service_category = $Result.DefaultSelection<Prisma.$service_categoryPayload>
/**
 * Model service_usage
 * 
 */
export type service_usage = $Result.DefaultSelection<Prisma.$service_usagePayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Clients
 * const clients = await prisma.client.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Clients
   * const clients = await prisma.client.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.client`: Exposes CRUD operations for the **client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.clientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client_details`: Exposes CRUD operations for the **client_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Client_details
    * const client_details = await prisma.client_details.findMany()
    * ```
    */
  get client_details(): Prisma.client_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client_parameter`: Exposes CRUD operations for the **client_parameter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Client_parameters
    * const client_parameters = await prisma.client_parameter.findMany()
    * ```
    */
  get client_parameter(): Prisma.client_parameterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client_service`: Exposes CRUD operations for the **client_service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Client_services
    * const client_services = await prisma.client_service.findMany()
    * ```
    */
  get client_service(): Prisma.client_serviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.invoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice_detail`: Exposes CRUD operations for the **invoice_detail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoice_details
    * const invoice_details = await prisma.invoice_detail.findMany()
    * ```
    */
  get invoice_detail(): Prisma.invoice_detailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.logDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.paymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_attachment`: Exposes CRUD operations for the **payment_attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_attachments
    * const payment_attachments = await prisma.payment_attachment.findMany()
    * ```
    */
  get payment_attachment(): Prisma.payment_attachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_method`: Exposes CRUD operations for the **payment_method** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_methods
    * const payment_methods = await prisma.payment_method.findMany()
    * ```
    */
  get payment_method(): Prisma.payment_methodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.permissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quote`: Exposes CRUD operations for the **quote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotes
    * const quotes = await prisma.quote.findMany()
    * ```
    */
  get quote(): Prisma.quoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quote_attachment`: Exposes CRUD operations for the **quote_attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quote_attachments
    * const quote_attachments = await prisma.quote_attachment.findMany()
    * ```
    */
  get quote_attachment(): Prisma.quote_attachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quote_detail`: Exposes CRUD operations for the **quote_detail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quote_details
    * const quote_details = await prisma.quote_detail.findMany()
    * ```
    */
  get quote_detail(): Prisma.quote_detailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.roleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role_permission`: Exposes CRUD operations for the **role_permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Role_permissions
    * const role_permissions = await prisma.role_permission.findMany()
    * ```
    */
  get role_permission(): Prisma.role_permissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.serviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service_category`: Exposes CRUD operations for the **service_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Service_categories
    * const service_categories = await prisma.service_category.findMany()
    * ```
    */
  get service_category(): Prisma.service_categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service_usage`: Exposes CRUD operations for the **service_usage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Service_usages
    * const service_usages = await prisma.service_usage.findMany()
    * ```
    */
  get service_usage(): Prisma.service_usageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    client: 'client',
    client_details: 'client_details',
    client_parameter: 'client_parameter',
    client_service: 'client_service',
    invoice: 'invoice',
    invoice_detail: 'invoice_detail',
    log: 'log',
    payment: 'payment',
    payment_attachment: 'payment_attachment',
    payment_method: 'payment_method',
    permission: 'permission',
    quote: 'quote',
    quote_attachment: 'quote_attachment',
    quote_detail: 'quote_detail',
    role: 'role',
    role_permission: 'role_permission',
    service: 'service',
    service_category: 'service_category',
    service_usage: 'service_usage',
    user: 'user'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "client" | "client_details" | "client_parameter" | "client_service" | "invoice" | "invoice_detail" | "log" | "payment" | "payment_attachment" | "payment_method" | "permission" | "quote" | "quote_attachment" | "quote_detail" | "role" | "role_permission" | "service" | "service_category" | "service_usage" | "user"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      client: {
        payload: Prisma.$clientPayload<ExtArgs>
        fields: Prisma.clientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          findFirst: {
            args: Prisma.clientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          findMany: {
            args: Prisma.clientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>[]
          }
          create: {
            args: Prisma.clientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          createMany: {
            args: Prisma.clientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.clientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>[]
          }
          delete: {
            args: Prisma.clientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          update: {
            args: Prisma.clientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          deleteMany: {
            args: Prisma.clientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.clientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>[]
          }
          upsert: {
            args: Prisma.clientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.clientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.clientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      client_details: {
        payload: Prisma.$client_detailsPayload<ExtArgs>
        fields: Prisma.client_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.client_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.client_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_detailsPayload>
          }
          findFirst: {
            args: Prisma.client_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.client_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_detailsPayload>
          }
          findMany: {
            args: Prisma.client_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_detailsPayload>[]
          }
          create: {
            args: Prisma.client_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_detailsPayload>
          }
          createMany: {
            args: Prisma.client_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.client_detailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_detailsPayload>[]
          }
          delete: {
            args: Prisma.client_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_detailsPayload>
          }
          update: {
            args: Prisma.client_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_detailsPayload>
          }
          deleteMany: {
            args: Prisma.client_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.client_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.client_detailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_detailsPayload>[]
          }
          upsert: {
            args: Prisma.client_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_detailsPayload>
          }
          aggregate: {
            args: Prisma.Client_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient_details>
          }
          groupBy: {
            args: Prisma.client_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Client_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.client_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Client_detailsCountAggregateOutputType> | number
          }
        }
      }
      client_parameter: {
        payload: Prisma.$client_parameterPayload<ExtArgs>
        fields: Prisma.client_parameterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.client_parameterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_parameterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.client_parameterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_parameterPayload>
          }
          findFirst: {
            args: Prisma.client_parameterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_parameterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.client_parameterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_parameterPayload>
          }
          findMany: {
            args: Prisma.client_parameterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_parameterPayload>[]
          }
          create: {
            args: Prisma.client_parameterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_parameterPayload>
          }
          createMany: {
            args: Prisma.client_parameterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.client_parameterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_parameterPayload>[]
          }
          delete: {
            args: Prisma.client_parameterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_parameterPayload>
          }
          update: {
            args: Prisma.client_parameterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_parameterPayload>
          }
          deleteMany: {
            args: Prisma.client_parameterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.client_parameterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.client_parameterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_parameterPayload>[]
          }
          upsert: {
            args: Prisma.client_parameterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_parameterPayload>
          }
          aggregate: {
            args: Prisma.Client_parameterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient_parameter>
          }
          groupBy: {
            args: Prisma.client_parameterGroupByArgs<ExtArgs>
            result: $Utils.Optional<Client_parameterGroupByOutputType>[]
          }
          count: {
            args: Prisma.client_parameterCountArgs<ExtArgs>
            result: $Utils.Optional<Client_parameterCountAggregateOutputType> | number
          }
        }
      }
      client_service: {
        payload: Prisma.$client_servicePayload<ExtArgs>
        fields: Prisma.client_serviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.client_serviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_servicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.client_serviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_servicePayload>
          }
          findFirst: {
            args: Prisma.client_serviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_servicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.client_serviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_servicePayload>
          }
          findMany: {
            args: Prisma.client_serviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_servicePayload>[]
          }
          create: {
            args: Prisma.client_serviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_servicePayload>
          }
          createMany: {
            args: Prisma.client_serviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.client_serviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_servicePayload>[]
          }
          delete: {
            args: Prisma.client_serviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_servicePayload>
          }
          update: {
            args: Prisma.client_serviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_servicePayload>
          }
          deleteMany: {
            args: Prisma.client_serviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.client_serviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.client_serviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_servicePayload>[]
          }
          upsert: {
            args: Prisma.client_serviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_servicePayload>
          }
          aggregate: {
            args: Prisma.Client_serviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient_service>
          }
          groupBy: {
            args: Prisma.client_serviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<Client_serviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.client_serviceCountArgs<ExtArgs>
            result: $Utils.Optional<Client_serviceCountAggregateOutputType> | number
          }
        }
      }
      invoice: {
        payload: Prisma.$invoicePayload<ExtArgs>
        fields: Prisma.invoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          findFirst: {
            args: Prisma.invoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          findMany: {
            args: Prisma.invoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>[]
          }
          create: {
            args: Prisma.invoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          createMany: {
            args: Prisma.invoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.invoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>[]
          }
          delete: {
            args: Prisma.invoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          update: {
            args: Prisma.invoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          deleteMany: {
            args: Prisma.invoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.invoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>[]
          }
          upsert: {
            args: Prisma.invoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.invoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.invoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      invoice_detail: {
        payload: Prisma.$invoice_detailPayload<ExtArgs>
        fields: Prisma.invoice_detailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invoice_detailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_detailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invoice_detailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_detailPayload>
          }
          findFirst: {
            args: Prisma.invoice_detailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_detailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invoice_detailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_detailPayload>
          }
          findMany: {
            args: Prisma.invoice_detailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_detailPayload>[]
          }
          create: {
            args: Prisma.invoice_detailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_detailPayload>
          }
          createMany: {
            args: Prisma.invoice_detailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.invoice_detailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_detailPayload>[]
          }
          delete: {
            args: Prisma.invoice_detailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_detailPayload>
          }
          update: {
            args: Prisma.invoice_detailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_detailPayload>
          }
          deleteMany: {
            args: Prisma.invoice_detailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invoice_detailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.invoice_detailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_detailPayload>[]
          }
          upsert: {
            args: Prisma.invoice_detailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_detailPayload>
          }
          aggregate: {
            args: Prisma.Invoice_detailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice_detail>
          }
          groupBy: {
            args: Prisma.invoice_detailGroupByArgs<ExtArgs>
            result: $Utils.Optional<Invoice_detailGroupByOutputType>[]
          }
          count: {
            args: Prisma.invoice_detailCountArgs<ExtArgs>
            result: $Utils.Optional<Invoice_detailCountAggregateOutputType> | number
          }
        }
      }
      log: {
        payload: Prisma.$logPayload<ExtArgs>
        fields: Prisma.logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logPayload>
          }
          findFirst: {
            args: Prisma.logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logPayload>
          }
          findMany: {
            args: Prisma.logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logPayload>[]
          }
          create: {
            args: Prisma.logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logPayload>
          }
          createMany: {
            args: Prisma.logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.logCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logPayload>[]
          }
          delete: {
            args: Prisma.logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logPayload>
          }
          update: {
            args: Prisma.logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logPayload>
          }
          deleteMany: {
            args: Prisma.logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.logUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logPayload>[]
          }
          upsert: {
            args: Prisma.logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.logGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.logCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      payment: {
        payload: Prisma.$paymentPayload<ExtArgs>
        fields: Prisma.paymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          findFirst: {
            args: Prisma.paymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          findMany: {
            args: Prisma.paymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          create: {
            args: Prisma.paymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          createMany: {
            args: Prisma.paymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          delete: {
            args: Prisma.paymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          update: {
            args: Prisma.paymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          deleteMany: {
            args: Prisma.paymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          upsert: {
            args: Prisma.paymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.paymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      payment_attachment: {
        payload: Prisma.$payment_attachmentPayload<ExtArgs>
        fields: Prisma.payment_attachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_attachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_attachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_attachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_attachmentPayload>
          }
          findFirst: {
            args: Prisma.payment_attachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_attachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_attachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_attachmentPayload>
          }
          findMany: {
            args: Prisma.payment_attachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_attachmentPayload>[]
          }
          create: {
            args: Prisma.payment_attachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_attachmentPayload>
          }
          createMany: {
            args: Prisma.payment_attachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_attachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_attachmentPayload>[]
          }
          delete: {
            args: Prisma.payment_attachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_attachmentPayload>
          }
          update: {
            args: Prisma.payment_attachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_attachmentPayload>
          }
          deleteMany: {
            args: Prisma.payment_attachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_attachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.payment_attachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_attachmentPayload>[]
          }
          upsert: {
            args: Prisma.payment_attachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_attachmentPayload>
          }
          aggregate: {
            args: Prisma.Payment_attachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_attachment>
          }
          groupBy: {
            args: Prisma.payment_attachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_attachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_attachmentCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_attachmentCountAggregateOutputType> | number
          }
        }
      }
      payment_method: {
        payload: Prisma.$payment_methodPayload<ExtArgs>
        fields: Prisma.payment_methodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_methodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_methodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          findFirst: {
            args: Prisma.payment_methodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_methodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          findMany: {
            args: Prisma.payment_methodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>[]
          }
          create: {
            args: Prisma.payment_methodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          createMany: {
            args: Prisma.payment_methodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_methodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>[]
          }
          delete: {
            args: Prisma.payment_methodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          update: {
            args: Prisma.payment_methodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          deleteMany: {
            args: Prisma.payment_methodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_methodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.payment_methodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>[]
          }
          upsert: {
            args: Prisma.payment_methodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          aggregate: {
            args: Prisma.Payment_methodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_method>
          }
          groupBy: {
            args: Prisma.payment_methodGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_methodGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_methodCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_methodCountAggregateOutputType> | number
          }
        }
      }
      permission: {
        payload: Prisma.$permissionPayload<ExtArgs>
        fields: Prisma.permissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          findFirst: {
            args: Prisma.permissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          findMany: {
            args: Prisma.permissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>[]
          }
          create: {
            args: Prisma.permissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          createMany: {
            args: Prisma.permissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.permissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>[]
          }
          delete: {
            args: Prisma.permissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          update: {
            args: Prisma.permissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          deleteMany: {
            args: Prisma.permissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.permissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.permissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>[]
          }
          upsert: {
            args: Prisma.permissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.permissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      quote: {
        payload: Prisma.$quotePayload<ExtArgs>
        fields: Prisma.quoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.quoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.quoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotePayload>
          }
          findFirst: {
            args: Prisma.quoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.quoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotePayload>
          }
          findMany: {
            args: Prisma.quoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotePayload>[]
          }
          create: {
            args: Prisma.quoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotePayload>
          }
          createMany: {
            args: Prisma.quoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.quoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotePayload>[]
          }
          delete: {
            args: Prisma.quoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotePayload>
          }
          update: {
            args: Prisma.quoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotePayload>
          }
          deleteMany: {
            args: Prisma.quoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.quoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.quoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotePayload>[]
          }
          upsert: {
            args: Prisma.quoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotePayload>
          }
          aggregate: {
            args: Prisma.QuoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote>
          }
          groupBy: {
            args: Prisma.quoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.quoteCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteCountAggregateOutputType> | number
          }
        }
      }
      quote_attachment: {
        payload: Prisma.$quote_attachmentPayload<ExtArgs>
        fields: Prisma.quote_attachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.quote_attachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_attachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.quote_attachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_attachmentPayload>
          }
          findFirst: {
            args: Prisma.quote_attachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_attachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.quote_attachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_attachmentPayload>
          }
          findMany: {
            args: Prisma.quote_attachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_attachmentPayload>[]
          }
          create: {
            args: Prisma.quote_attachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_attachmentPayload>
          }
          createMany: {
            args: Prisma.quote_attachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.quote_attachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_attachmentPayload>[]
          }
          delete: {
            args: Prisma.quote_attachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_attachmentPayload>
          }
          update: {
            args: Prisma.quote_attachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_attachmentPayload>
          }
          deleteMany: {
            args: Prisma.quote_attachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.quote_attachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.quote_attachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_attachmentPayload>[]
          }
          upsert: {
            args: Prisma.quote_attachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_attachmentPayload>
          }
          aggregate: {
            args: Prisma.Quote_attachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote_attachment>
          }
          groupBy: {
            args: Prisma.quote_attachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Quote_attachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.quote_attachmentCountArgs<ExtArgs>
            result: $Utils.Optional<Quote_attachmentCountAggregateOutputType> | number
          }
        }
      }
      quote_detail: {
        payload: Prisma.$quote_detailPayload<ExtArgs>
        fields: Prisma.quote_detailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.quote_detailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_detailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.quote_detailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_detailPayload>
          }
          findFirst: {
            args: Prisma.quote_detailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_detailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.quote_detailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_detailPayload>
          }
          findMany: {
            args: Prisma.quote_detailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_detailPayload>[]
          }
          create: {
            args: Prisma.quote_detailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_detailPayload>
          }
          createMany: {
            args: Prisma.quote_detailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.quote_detailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_detailPayload>[]
          }
          delete: {
            args: Prisma.quote_detailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_detailPayload>
          }
          update: {
            args: Prisma.quote_detailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_detailPayload>
          }
          deleteMany: {
            args: Prisma.quote_detailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.quote_detailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.quote_detailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_detailPayload>[]
          }
          upsert: {
            args: Prisma.quote_detailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_detailPayload>
          }
          aggregate: {
            args: Prisma.Quote_detailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote_detail>
          }
          groupBy: {
            args: Prisma.quote_detailGroupByArgs<ExtArgs>
            result: $Utils.Optional<Quote_detailGroupByOutputType>[]
          }
          count: {
            args: Prisma.quote_detailCountArgs<ExtArgs>
            result: $Utils.Optional<Quote_detailCountAggregateOutputType> | number
          }
        }
      }
      role: {
        payload: Prisma.$rolePayload<ExtArgs>
        fields: Prisma.roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findFirst: {
            args: Prisma.roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findMany: {
            args: Prisma.roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          create: {
            args: Prisma.roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          createMany: {
            args: Prisma.roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.roleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          delete: {
            args: Prisma.roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          update: {
            args: Prisma.roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          deleteMany: {
            args: Prisma.roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.roleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          upsert: {
            args: Prisma.roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.roleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      role_permission: {
        payload: Prisma.$role_permissionPayload<ExtArgs>
        fields: Prisma.role_permissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.role_permissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.role_permissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionPayload>
          }
          findFirst: {
            args: Prisma.role_permissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.role_permissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionPayload>
          }
          findMany: {
            args: Prisma.role_permissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionPayload>[]
          }
          create: {
            args: Prisma.role_permissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionPayload>
          }
          createMany: {
            args: Prisma.role_permissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.role_permissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionPayload>[]
          }
          delete: {
            args: Prisma.role_permissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionPayload>
          }
          update: {
            args: Prisma.role_permissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionPayload>
          }
          deleteMany: {
            args: Prisma.role_permissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.role_permissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.role_permissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionPayload>[]
          }
          upsert: {
            args: Prisma.role_permissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionPayload>
          }
          aggregate: {
            args: Prisma.Role_permissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole_permission>
          }
          groupBy: {
            args: Prisma.role_permissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Role_permissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.role_permissionCountArgs<ExtArgs>
            result: $Utils.Optional<Role_permissionCountAggregateOutputType> | number
          }
        }
      }
      service: {
        payload: Prisma.$servicePayload<ExtArgs>
        fields: Prisma.serviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          findFirst: {
            args: Prisma.serviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          findMany: {
            args: Prisma.serviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>[]
          }
          create: {
            args: Prisma.serviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          createMany: {
            args: Prisma.serviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.serviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>[]
          }
          delete: {
            args: Prisma.serviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          update: {
            args: Prisma.serviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          deleteMany: {
            args: Prisma.serviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.serviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.serviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>[]
          }
          upsert: {
            args: Prisma.serviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.serviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.serviceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      service_category: {
        payload: Prisma.$service_categoryPayload<ExtArgs>
        fields: Prisma.service_categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.service_categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.service_categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoryPayload>
          }
          findFirst: {
            args: Prisma.service_categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.service_categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoryPayload>
          }
          findMany: {
            args: Prisma.service_categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoryPayload>[]
          }
          create: {
            args: Prisma.service_categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoryPayload>
          }
          createMany: {
            args: Prisma.service_categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.service_categoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoryPayload>[]
          }
          delete: {
            args: Prisma.service_categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoryPayload>
          }
          update: {
            args: Prisma.service_categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoryPayload>
          }
          deleteMany: {
            args: Prisma.service_categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.service_categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.service_categoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoryPayload>[]
          }
          upsert: {
            args: Prisma.service_categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoryPayload>
          }
          aggregate: {
            args: Prisma.Service_categoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService_category>
          }
          groupBy: {
            args: Prisma.service_categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Service_categoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.service_categoryCountArgs<ExtArgs>
            result: $Utils.Optional<Service_categoryCountAggregateOutputType> | number
          }
        }
      }
      service_usage: {
        payload: Prisma.$service_usagePayload<ExtArgs>
        fields: Prisma.service_usageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.service_usageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.service_usageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usagePayload>
          }
          findFirst: {
            args: Prisma.service_usageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.service_usageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usagePayload>
          }
          findMany: {
            args: Prisma.service_usageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usagePayload>[]
          }
          create: {
            args: Prisma.service_usageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usagePayload>
          }
          createMany: {
            args: Prisma.service_usageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.service_usageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usagePayload>[]
          }
          delete: {
            args: Prisma.service_usageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usagePayload>
          }
          update: {
            args: Prisma.service_usageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usagePayload>
          }
          deleteMany: {
            args: Prisma.service_usageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.service_usageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.service_usageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usagePayload>[]
          }
          upsert: {
            args: Prisma.service_usageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usagePayload>
          }
          aggregate: {
            args: Prisma.Service_usageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService_usage>
          }
          groupBy: {
            args: Prisma.service_usageGroupByArgs<ExtArgs>
            result: $Utils.Optional<Service_usageGroupByOutputType>[]
          }
          count: {
            args: Prisma.service_usageCountArgs<ExtArgs>
            result: $Utils.Optional<Service_usageCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    client?: clientOmit
    client_details?: client_detailsOmit
    client_parameter?: client_parameterOmit
    client_service?: client_serviceOmit
    invoice?: invoiceOmit
    invoice_detail?: invoice_detailOmit
    log?: logOmit
    payment?: paymentOmit
    payment_attachment?: payment_attachmentOmit
    payment_method?: payment_methodOmit
    permission?: permissionOmit
    quote?: quoteOmit
    quote_attachment?: quote_attachmentOmit
    quote_detail?: quote_detailOmit
    role?: roleOmit
    role_permission?: role_permissionOmit
    service?: serviceOmit
    service_category?: service_categoryOmit
    service_usage?: service_usageOmit
    user?: userOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    client_details: number
    client_service: number
    invoice: number
    log: number
    payment: number
    quote: number
    service_usage: number
    user: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_details?: boolean | ClientCountOutputTypeCountClient_detailsArgs
    client_service?: boolean | ClientCountOutputTypeCountClient_serviceArgs
    invoice?: boolean | ClientCountOutputTypeCountInvoiceArgs
    log?: boolean | ClientCountOutputTypeCountLogArgs
    payment?: boolean | ClientCountOutputTypeCountPaymentArgs
    quote?: boolean | ClientCountOutputTypeCountQuoteArgs
    service_usage?: boolean | ClientCountOutputTypeCountService_usageArgs
    user?: boolean | ClientCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountClient_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: client_detailsWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountClient_serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: client_serviceWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoiceWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: logWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountQuoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quoteWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountService_usageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: service_usageWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }


  /**
   * Count Type Client_parameterCountOutputType
   */

  export type Client_parameterCountOutputType = {
    client_details: number
  }

  export type Client_parameterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_details?: boolean | Client_parameterCountOutputTypeCountClient_detailsArgs
  }

  // Custom InputTypes
  /**
   * Client_parameterCountOutputType without action
   */
  export type Client_parameterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client_parameterCountOutputType
     */
    select?: Client_parameterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Client_parameterCountOutputType without action
   */
  export type Client_parameterCountOutputTypeCountClient_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: client_detailsWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    invoice_detail: number
    payment_attachment: number
    quote_attachment: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_detail?: boolean | InvoiceCountOutputTypeCountInvoice_detailArgs
    payment_attachment?: boolean | InvoiceCountOutputTypeCountPayment_attachmentArgs
    quote_attachment?: boolean | InvoiceCountOutputTypeCountQuote_attachmentArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountInvoice_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoice_detailWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPayment_attachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_attachmentWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountQuote_attachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quote_attachmentWhereInput
  }


  /**
   * Count Type Payment_methodCountOutputType
   */

  export type Payment_methodCountOutputType = {
    payment: number
  }

  export type Payment_methodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | Payment_methodCountOutputTypeCountPaymentArgs
  }

  // Custom InputTypes
  /**
   * Payment_methodCountOutputType without action
   */
  export type Payment_methodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment_methodCountOutputType
     */
    select?: Payment_methodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Payment_methodCountOutputType without action
   */
  export type Payment_methodCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    role_permission: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role_permission?: boolean | PermissionCountOutputTypeCountRole_permissionArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRole_permissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_permissionWhereInput
  }


  /**
   * Count Type QuoteCountOutputType
   */

  export type QuoteCountOutputType = {
    quote_attachment: number
    quote_detail: number
  }

  export type QuoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote_attachment?: boolean | QuoteCountOutputTypeCountQuote_attachmentArgs
    quote_detail?: boolean | QuoteCountOutputTypeCountQuote_detailArgs
  }

  // Custom InputTypes
  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteCountOutputType
     */
    select?: QuoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountQuote_attachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quote_attachmentWhereInput
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountQuote_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quote_detailWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    log: number
    role_permission: number
    user: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    log?: boolean | RoleCountOutputTypeCountLogArgs
    role_permission?: boolean | RoleCountOutputTypeCountRole_permissionArgs
    user?: boolean | RoleCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: logWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRole_permissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_permissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    client_service: number
    invoice_detail: number
    quote_detail: number
    service_usage: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_service?: boolean | ServiceCountOutputTypeCountClient_serviceArgs
    invoice_detail?: boolean | ServiceCountOutputTypeCountInvoice_detailArgs
    quote_detail?: boolean | ServiceCountOutputTypeCountQuote_detailArgs
    service_usage?: boolean | ServiceCountOutputTypeCountService_usageArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountClient_serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: client_serviceWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountInvoice_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoice_detailWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountQuote_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quote_detailWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountService_usageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: service_usageWhereInput
  }


  /**
   * Count Type Service_categoryCountOutputType
   */

  export type Service_categoryCountOutputType = {
    service: number
  }

  export type Service_categoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | Service_categoryCountOutputTypeCountServiceArgs
  }

  // Custom InputTypes
  /**
   * Service_categoryCountOutputType without action
   */
  export type Service_categoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service_categoryCountOutputType
     */
    select?: Service_categoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Service_categoryCountOutputType without action
   */
  export type Service_categoryCountOutputTypeCountServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    log: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    log?: boolean | UserCountOutputTypeCountLogArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: logWhereInput
  }


  /**
   * Models
   */

  /**
   * Model client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    name: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    created: number
    updated: number
    status: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    created?: true
    updated?: true
    status?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    created?: true
    updated?: true
    status?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    created?: true
    updated?: true
    status?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which client to aggregate.
     */
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientOrderByWithRelationInput | clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type clientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientWhereInput
    orderBy?: clientOrderByWithAggregationInput | clientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: clientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    name: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends clientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type clientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    client_details?: boolean | client$client_detailsArgs<ExtArgs>
    client_service?: boolean | client$client_serviceArgs<ExtArgs>
    invoice?: boolean | client$invoiceArgs<ExtArgs>
    log?: boolean | client$logArgs<ExtArgs>
    payment?: boolean | client$paymentArgs<ExtArgs>
    quote?: boolean | client$quoteArgs<ExtArgs>
    service_usage?: boolean | client$service_usageArgs<ExtArgs>
    user?: boolean | client$userArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type clientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
  }, ExtArgs["result"]["client"]>

  export type clientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
  }, ExtArgs["result"]["client"]>

  export type clientSelectScalar = {
    id?: boolean
    name?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
  }

  export type clientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "created" | "updated" | "status", ExtArgs["result"]["client"]>
  export type clientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_details?: boolean | client$client_detailsArgs<ExtArgs>
    client_service?: boolean | client$client_serviceArgs<ExtArgs>
    invoice?: boolean | client$invoiceArgs<ExtArgs>
    log?: boolean | client$logArgs<ExtArgs>
    payment?: boolean | client$paymentArgs<ExtArgs>
    quote?: boolean | client$quoteArgs<ExtArgs>
    service_usage?: boolean | client$service_usageArgs<ExtArgs>
    user?: boolean | client$userArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type clientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type clientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $clientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "client"
    objects: {
      client_details: Prisma.$client_detailsPayload<ExtArgs>[]
      client_service: Prisma.$client_servicePayload<ExtArgs>[]
      invoice: Prisma.$invoicePayload<ExtArgs>[]
      log: Prisma.$logPayload<ExtArgs>[]
      payment: Prisma.$paymentPayload<ExtArgs>[]
      quote: Prisma.$quotePayload<ExtArgs>[]
      service_usage: Prisma.$service_usagePayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      created: Date | null
      updated: Date | null
      status: boolean | null
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type clientGetPayload<S extends boolean | null | undefined | clientDefaultArgs> = $Result.GetResult<Prisma.$clientPayload, S>

  type clientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface clientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['client'], meta: { name: 'client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {clientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clientFindUniqueArgs>(args: SelectSubset<T, clientFindUniqueArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clientFindUniqueOrThrowArgs>(args: SelectSubset<T, clientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clientFindFirstArgs>(args?: SelectSubset<T, clientFindFirstArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clientFindFirstOrThrowArgs>(args?: SelectSubset<T, clientFindFirstOrThrowArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clientFindManyArgs>(args?: SelectSubset<T, clientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {clientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends clientCreateArgs>(args: SelectSubset<T, clientCreateArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {clientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clientCreateManyArgs>(args?: SelectSubset<T, clientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {clientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends clientCreateManyAndReturnArgs>(args?: SelectSubset<T, clientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {clientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends clientDeleteArgs>(args: SelectSubset<T, clientDeleteArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {clientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clientUpdateArgs>(args: SelectSubset<T, clientUpdateArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {clientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clientDeleteManyArgs>(args?: SelectSubset<T, clientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clientUpdateManyArgs>(args: SelectSubset<T, clientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {clientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends clientUpdateManyAndReturnArgs>(args: SelectSubset<T, clientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {clientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends clientUpsertArgs>(args: SelectSubset<T, clientUpsertArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends clientCountArgs>(
      args?: Subset<T, clientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clientGroupByArgs['orderBy'] }
        : { orderBy?: clientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the client model
   */
  readonly fields: clientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client_details<T extends client$client_detailsArgs<ExtArgs> = {}>(args?: Subset<T, client$client_detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    client_service<T extends client$client_serviceArgs<ExtArgs> = {}>(args?: Subset<T, client$client_serviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_servicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoice<T extends client$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, client$invoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    log<T extends client$logArgs<ExtArgs> = {}>(args?: Subset<T, client$logArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment<T extends client$paymentArgs<ExtArgs> = {}>(args?: Subset<T, client$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quote<T extends client$quoteArgs<ExtArgs> = {}>(args?: Subset<T, client$quoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    service_usage<T extends client$service_usageArgs<ExtArgs> = {}>(args?: Subset<T, client$service_usageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_usagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends client$userArgs<ExtArgs> = {}>(args?: Subset<T, client$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the client model
   */
  interface clientFieldRefs {
    readonly id: FieldRef<"client", 'String'>
    readonly name: FieldRef<"client", 'String'>
    readonly created: FieldRef<"client", 'DateTime'>
    readonly updated: FieldRef<"client", 'DateTime'>
    readonly status: FieldRef<"client", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * client findUnique
   */
  export type clientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter, which client to fetch.
     */
    where: clientWhereUniqueInput
  }

  /**
   * client findUniqueOrThrow
   */
  export type clientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter, which client to fetch.
     */
    where: clientWhereUniqueInput
  }

  /**
   * client findFirst
   */
  export type clientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter, which client to fetch.
     */
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientOrderByWithRelationInput | clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clients.
     */
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * client findFirstOrThrow
   */
  export type clientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter, which client to fetch.
     */
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientOrderByWithRelationInput | clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clients.
     */
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * client findMany
   */
  export type clientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientOrderByWithRelationInput | clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clients.
     */
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * client create
   */
  export type clientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * The data needed to create a client.
     */
    data: XOR<clientCreateInput, clientUncheckedCreateInput>
  }

  /**
   * client createMany
   */
  export type clientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clients.
     */
    data: clientCreateManyInput | clientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * client createManyAndReturn
   */
  export type clientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * The data used to create many clients.
     */
    data: clientCreateManyInput | clientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * client update
   */
  export type clientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * The data needed to update a client.
     */
    data: XOR<clientUpdateInput, clientUncheckedUpdateInput>
    /**
     * Choose, which client to update.
     */
    where: clientWhereUniqueInput
  }

  /**
   * client updateMany
   */
  export type clientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clients.
     */
    data: XOR<clientUpdateManyMutationInput, clientUncheckedUpdateManyInput>
    /**
     * Filter which clients to update
     */
    where?: clientWhereInput
    /**
     * Limit how many clients to update.
     */
    limit?: number
  }

  /**
   * client updateManyAndReturn
   */
  export type clientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * The data used to update clients.
     */
    data: XOR<clientUpdateManyMutationInput, clientUncheckedUpdateManyInput>
    /**
     * Filter which clients to update
     */
    where?: clientWhereInput
    /**
     * Limit how many clients to update.
     */
    limit?: number
  }

  /**
   * client upsert
   */
  export type clientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * The filter to search for the client to update in case it exists.
     */
    where: clientWhereUniqueInput
    /**
     * In case the client found by the `where` argument doesn't exist, create a new client with this data.
     */
    create: XOR<clientCreateInput, clientUncheckedCreateInput>
    /**
     * In case the client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clientUpdateInput, clientUncheckedUpdateInput>
  }

  /**
   * client delete
   */
  export type clientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter which client to delete.
     */
    where: clientWhereUniqueInput
  }

  /**
   * client deleteMany
   */
  export type clientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clients to delete
     */
    where?: clientWhereInput
    /**
     * Limit how many clients to delete.
     */
    limit?: number
  }

  /**
   * client.client_details
   */
  export type client$client_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_details
     */
    select?: client_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_details
     */
    omit?: client_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_detailsInclude<ExtArgs> | null
    where?: client_detailsWhereInput
    orderBy?: client_detailsOrderByWithRelationInput | client_detailsOrderByWithRelationInput[]
    cursor?: client_detailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Client_detailsScalarFieldEnum | Client_detailsScalarFieldEnum[]
  }

  /**
   * client.client_service
   */
  export type client$client_serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_service
     */
    select?: client_serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_service
     */
    omit?: client_serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_serviceInclude<ExtArgs> | null
    where?: client_serviceWhereInput
    orderBy?: client_serviceOrderByWithRelationInput | client_serviceOrderByWithRelationInput[]
    cursor?: client_serviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Client_serviceScalarFieldEnum | Client_serviceScalarFieldEnum[]
  }

  /**
   * client.invoice
   */
  export type client$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    where?: invoiceWhereInput
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    cursor?: invoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * client.log
   */
  export type client$logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the log
     */
    omit?: logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logInclude<ExtArgs> | null
    where?: logWhereInput
    orderBy?: logOrderByWithRelationInput | logOrderByWithRelationInput[]
    cursor?: logWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * client.payment
   */
  export type client$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * client.quote
   */
  export type client$quoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote
     */
    select?: quoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote
     */
    omit?: quoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quoteInclude<ExtArgs> | null
    where?: quoteWhereInput
    orderBy?: quoteOrderByWithRelationInput | quoteOrderByWithRelationInput[]
    cursor?: quoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * client.service_usage
   */
  export type client$service_usageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage
     */
    select?: service_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_usage
     */
    omit?: service_usageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usageInclude<ExtArgs> | null
    where?: service_usageWhereInput
    orderBy?: service_usageOrderByWithRelationInput | service_usageOrderByWithRelationInput[]
    cursor?: service_usageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Service_usageScalarFieldEnum | Service_usageScalarFieldEnum[]
  }

  /**
   * client.user
   */
  export type client$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * client without action
   */
  export type clientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
  }


  /**
   * Model client_details
   */

  export type AggregateClient_details = {
    _count: Client_detailsCountAggregateOutputType | null
    _min: Client_detailsMinAggregateOutputType | null
    _max: Client_detailsMaxAggregateOutputType | null
  }

  export type Client_detailsMinAggregateOutputType = {
    id: string | null
    client_id: string | null
    c_parameter_id: string | null
    value: string | null
  }

  export type Client_detailsMaxAggregateOutputType = {
    id: string | null
    client_id: string | null
    c_parameter_id: string | null
    value: string | null
  }

  export type Client_detailsCountAggregateOutputType = {
    id: number
    client_id: number
    c_parameter_id: number
    value: number
    _all: number
  }


  export type Client_detailsMinAggregateInputType = {
    id?: true
    client_id?: true
    c_parameter_id?: true
    value?: true
  }

  export type Client_detailsMaxAggregateInputType = {
    id?: true
    client_id?: true
    c_parameter_id?: true
    value?: true
  }

  export type Client_detailsCountAggregateInputType = {
    id?: true
    client_id?: true
    c_parameter_id?: true
    value?: true
    _all?: true
  }

  export type Client_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which client_details to aggregate.
     */
    where?: client_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_details to fetch.
     */
    orderBy?: client_detailsOrderByWithRelationInput | client_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: client_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned client_details
    **/
    _count?: true | Client_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Client_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Client_detailsMaxAggregateInputType
  }

  export type GetClient_detailsAggregateType<T extends Client_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateClient_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient_details[P]>
      : GetScalarType<T[P], AggregateClient_details[P]>
  }




  export type client_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: client_detailsWhereInput
    orderBy?: client_detailsOrderByWithAggregationInput | client_detailsOrderByWithAggregationInput[]
    by: Client_detailsScalarFieldEnum[] | Client_detailsScalarFieldEnum
    having?: client_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Client_detailsCountAggregateInputType | true
    _min?: Client_detailsMinAggregateInputType
    _max?: Client_detailsMaxAggregateInputType
  }

  export type Client_detailsGroupByOutputType = {
    id: string
    client_id: string | null
    c_parameter_id: string | null
    value: string | null
    _count: Client_detailsCountAggregateOutputType | null
    _min: Client_detailsMinAggregateOutputType | null
    _max: Client_detailsMaxAggregateOutputType | null
  }

  type GetClient_detailsGroupByPayload<T extends client_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Client_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Client_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Client_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Client_detailsGroupByOutputType[P]>
        }
      >
    >


  export type client_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    c_parameter_id?: boolean
    value?: boolean
    client_parameter?: boolean | client_details$client_parameterArgs<ExtArgs>
    client?: boolean | client_details$clientArgs<ExtArgs>
  }, ExtArgs["result"]["client_details"]>

  export type client_detailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    c_parameter_id?: boolean
    value?: boolean
    client_parameter?: boolean | client_details$client_parameterArgs<ExtArgs>
    client?: boolean | client_details$clientArgs<ExtArgs>
  }, ExtArgs["result"]["client_details"]>

  export type client_detailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    c_parameter_id?: boolean
    value?: boolean
    client_parameter?: boolean | client_details$client_parameterArgs<ExtArgs>
    client?: boolean | client_details$clientArgs<ExtArgs>
  }, ExtArgs["result"]["client_details"]>

  export type client_detailsSelectScalar = {
    id?: boolean
    client_id?: boolean
    c_parameter_id?: boolean
    value?: boolean
  }

  export type client_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "client_id" | "c_parameter_id" | "value", ExtArgs["result"]["client_details"]>
  export type client_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_parameter?: boolean | client_details$client_parameterArgs<ExtArgs>
    client?: boolean | client_details$clientArgs<ExtArgs>
  }
  export type client_detailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_parameter?: boolean | client_details$client_parameterArgs<ExtArgs>
    client?: boolean | client_details$clientArgs<ExtArgs>
  }
  export type client_detailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_parameter?: boolean | client_details$client_parameterArgs<ExtArgs>
    client?: boolean | client_details$clientArgs<ExtArgs>
  }

  export type $client_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "client_details"
    objects: {
      client_parameter: Prisma.$client_parameterPayload<ExtArgs> | null
      client: Prisma.$clientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      client_id: string | null
      c_parameter_id: string | null
      value: string | null
    }, ExtArgs["result"]["client_details"]>
    composites: {}
  }

  type client_detailsGetPayload<S extends boolean | null | undefined | client_detailsDefaultArgs> = $Result.GetResult<Prisma.$client_detailsPayload, S>

  type client_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<client_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Client_detailsCountAggregateInputType | true
    }

  export interface client_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['client_details'], meta: { name: 'client_details' } }
    /**
     * Find zero or one Client_details that matches the filter.
     * @param {client_detailsFindUniqueArgs} args - Arguments to find a Client_details
     * @example
     * // Get one Client_details
     * const client_details = await prisma.client_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends client_detailsFindUniqueArgs>(args: SelectSubset<T, client_detailsFindUniqueArgs<ExtArgs>>): Prisma__client_detailsClient<$Result.GetResult<Prisma.$client_detailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {client_detailsFindUniqueOrThrowArgs} args - Arguments to find a Client_details
     * @example
     * // Get one Client_details
     * const client_details = await prisma.client_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends client_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, client_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__client_detailsClient<$Result.GetResult<Prisma.$client_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_detailsFindFirstArgs} args - Arguments to find a Client_details
     * @example
     * // Get one Client_details
     * const client_details = await prisma.client_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends client_detailsFindFirstArgs>(args?: SelectSubset<T, client_detailsFindFirstArgs<ExtArgs>>): Prisma__client_detailsClient<$Result.GetResult<Prisma.$client_detailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_detailsFindFirstOrThrowArgs} args - Arguments to find a Client_details
     * @example
     * // Get one Client_details
     * const client_details = await prisma.client_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends client_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, client_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__client_detailsClient<$Result.GetResult<Prisma.$client_detailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Client_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Client_details
     * const client_details = await prisma.client_details.findMany()
     * 
     * // Get first 10 Client_details
     * const client_details = await prisma.client_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const client_detailsWithIdOnly = await prisma.client_details.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends client_detailsFindManyArgs>(args?: SelectSubset<T, client_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client_details.
     * @param {client_detailsCreateArgs} args - Arguments to create a Client_details.
     * @example
     * // Create one Client_details
     * const Client_details = await prisma.client_details.create({
     *   data: {
     *     // ... data to create a Client_details
     *   }
     * })
     * 
     */
    create<T extends client_detailsCreateArgs>(args: SelectSubset<T, client_detailsCreateArgs<ExtArgs>>): Prisma__client_detailsClient<$Result.GetResult<Prisma.$client_detailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Client_details.
     * @param {client_detailsCreateManyArgs} args - Arguments to create many Client_details.
     * @example
     * // Create many Client_details
     * const client_details = await prisma.client_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends client_detailsCreateManyArgs>(args?: SelectSubset<T, client_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Client_details and returns the data saved in the database.
     * @param {client_detailsCreateManyAndReturnArgs} args - Arguments to create many Client_details.
     * @example
     * // Create many Client_details
     * const client_details = await prisma.client_details.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Client_details and only return the `id`
     * const client_detailsWithIdOnly = await prisma.client_details.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends client_detailsCreateManyAndReturnArgs>(args?: SelectSubset<T, client_detailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_detailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client_details.
     * @param {client_detailsDeleteArgs} args - Arguments to delete one Client_details.
     * @example
     * // Delete one Client_details
     * const Client_details = await prisma.client_details.delete({
     *   where: {
     *     // ... filter to delete one Client_details
     *   }
     * })
     * 
     */
    delete<T extends client_detailsDeleteArgs>(args: SelectSubset<T, client_detailsDeleteArgs<ExtArgs>>): Prisma__client_detailsClient<$Result.GetResult<Prisma.$client_detailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client_details.
     * @param {client_detailsUpdateArgs} args - Arguments to update one Client_details.
     * @example
     * // Update one Client_details
     * const client_details = await prisma.client_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends client_detailsUpdateArgs>(args: SelectSubset<T, client_detailsUpdateArgs<ExtArgs>>): Prisma__client_detailsClient<$Result.GetResult<Prisma.$client_detailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Client_details.
     * @param {client_detailsDeleteManyArgs} args - Arguments to filter Client_details to delete.
     * @example
     * // Delete a few Client_details
     * const { count } = await prisma.client_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends client_detailsDeleteManyArgs>(args?: SelectSubset<T, client_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Client_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Client_details
     * const client_details = await prisma.client_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends client_detailsUpdateManyArgs>(args: SelectSubset<T, client_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Client_details and returns the data updated in the database.
     * @param {client_detailsUpdateManyAndReturnArgs} args - Arguments to update many Client_details.
     * @example
     * // Update many Client_details
     * const client_details = await prisma.client_details.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Client_details and only return the `id`
     * const client_detailsWithIdOnly = await prisma.client_details.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends client_detailsUpdateManyAndReturnArgs>(args: SelectSubset<T, client_detailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_detailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client_details.
     * @param {client_detailsUpsertArgs} args - Arguments to update or create a Client_details.
     * @example
     * // Update or create a Client_details
     * const client_details = await prisma.client_details.upsert({
     *   create: {
     *     // ... data to create a Client_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client_details we want to update
     *   }
     * })
     */
    upsert<T extends client_detailsUpsertArgs>(args: SelectSubset<T, client_detailsUpsertArgs<ExtArgs>>): Prisma__client_detailsClient<$Result.GetResult<Prisma.$client_detailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Client_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_detailsCountArgs} args - Arguments to filter Client_details to count.
     * @example
     * // Count the number of Client_details
     * const count = await prisma.client_details.count({
     *   where: {
     *     // ... the filter for the Client_details we want to count
     *   }
     * })
    **/
    count<T extends client_detailsCountArgs>(
      args?: Subset<T, client_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Client_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Client_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Client_detailsAggregateArgs>(args: Subset<T, Client_detailsAggregateArgs>): Prisma.PrismaPromise<GetClient_detailsAggregateType<T>>

    /**
     * Group by Client_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends client_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: client_detailsGroupByArgs['orderBy'] }
        : { orderBy?: client_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, client_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClient_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the client_details model
   */
  readonly fields: client_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for client_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__client_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client_parameter<T extends client_details$client_parameterArgs<ExtArgs> = {}>(args?: Subset<T, client_details$client_parameterArgs<ExtArgs>>): Prisma__client_parameterClient<$Result.GetResult<Prisma.$client_parameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends client_details$clientArgs<ExtArgs> = {}>(args?: Subset<T, client_details$clientArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the client_details model
   */
  interface client_detailsFieldRefs {
    readonly id: FieldRef<"client_details", 'String'>
    readonly client_id: FieldRef<"client_details", 'String'>
    readonly c_parameter_id: FieldRef<"client_details", 'String'>
    readonly value: FieldRef<"client_details", 'String'>
  }
    

  // Custom InputTypes
  /**
   * client_details findUnique
   */
  export type client_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_details
     */
    select?: client_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_details
     */
    omit?: client_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_detailsInclude<ExtArgs> | null
    /**
     * Filter, which client_details to fetch.
     */
    where: client_detailsWhereUniqueInput
  }

  /**
   * client_details findUniqueOrThrow
   */
  export type client_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_details
     */
    select?: client_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_details
     */
    omit?: client_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_detailsInclude<ExtArgs> | null
    /**
     * Filter, which client_details to fetch.
     */
    where: client_detailsWhereUniqueInput
  }

  /**
   * client_details findFirst
   */
  export type client_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_details
     */
    select?: client_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_details
     */
    omit?: client_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_detailsInclude<ExtArgs> | null
    /**
     * Filter, which client_details to fetch.
     */
    where?: client_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_details to fetch.
     */
    orderBy?: client_detailsOrderByWithRelationInput | client_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for client_details.
     */
    cursor?: client_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of client_details.
     */
    distinct?: Client_detailsScalarFieldEnum | Client_detailsScalarFieldEnum[]
  }

  /**
   * client_details findFirstOrThrow
   */
  export type client_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_details
     */
    select?: client_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_details
     */
    omit?: client_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_detailsInclude<ExtArgs> | null
    /**
     * Filter, which client_details to fetch.
     */
    where?: client_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_details to fetch.
     */
    orderBy?: client_detailsOrderByWithRelationInput | client_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for client_details.
     */
    cursor?: client_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of client_details.
     */
    distinct?: Client_detailsScalarFieldEnum | Client_detailsScalarFieldEnum[]
  }

  /**
   * client_details findMany
   */
  export type client_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_details
     */
    select?: client_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_details
     */
    omit?: client_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_detailsInclude<ExtArgs> | null
    /**
     * Filter, which client_details to fetch.
     */
    where?: client_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_details to fetch.
     */
    orderBy?: client_detailsOrderByWithRelationInput | client_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing client_details.
     */
    cursor?: client_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_details.
     */
    skip?: number
    distinct?: Client_detailsScalarFieldEnum | Client_detailsScalarFieldEnum[]
  }

  /**
   * client_details create
   */
  export type client_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_details
     */
    select?: client_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_details
     */
    omit?: client_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a client_details.
     */
    data: XOR<client_detailsCreateInput, client_detailsUncheckedCreateInput>
  }

  /**
   * client_details createMany
   */
  export type client_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many client_details.
     */
    data: client_detailsCreateManyInput | client_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * client_details createManyAndReturn
   */
  export type client_detailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_details
     */
    select?: client_detailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the client_details
     */
    omit?: client_detailsOmit<ExtArgs> | null
    /**
     * The data used to create many client_details.
     */
    data: client_detailsCreateManyInput | client_detailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_detailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * client_details update
   */
  export type client_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_details
     */
    select?: client_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_details
     */
    omit?: client_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a client_details.
     */
    data: XOR<client_detailsUpdateInput, client_detailsUncheckedUpdateInput>
    /**
     * Choose, which client_details to update.
     */
    where: client_detailsWhereUniqueInput
  }

  /**
   * client_details updateMany
   */
  export type client_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update client_details.
     */
    data: XOR<client_detailsUpdateManyMutationInput, client_detailsUncheckedUpdateManyInput>
    /**
     * Filter which client_details to update
     */
    where?: client_detailsWhereInput
    /**
     * Limit how many client_details to update.
     */
    limit?: number
  }

  /**
   * client_details updateManyAndReturn
   */
  export type client_detailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_details
     */
    select?: client_detailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the client_details
     */
    omit?: client_detailsOmit<ExtArgs> | null
    /**
     * The data used to update client_details.
     */
    data: XOR<client_detailsUpdateManyMutationInput, client_detailsUncheckedUpdateManyInput>
    /**
     * Filter which client_details to update
     */
    where?: client_detailsWhereInput
    /**
     * Limit how many client_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_detailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * client_details upsert
   */
  export type client_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_details
     */
    select?: client_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_details
     */
    omit?: client_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the client_details to update in case it exists.
     */
    where: client_detailsWhereUniqueInput
    /**
     * In case the client_details found by the `where` argument doesn't exist, create a new client_details with this data.
     */
    create: XOR<client_detailsCreateInput, client_detailsUncheckedCreateInput>
    /**
     * In case the client_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<client_detailsUpdateInput, client_detailsUncheckedUpdateInput>
  }

  /**
   * client_details delete
   */
  export type client_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_details
     */
    select?: client_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_details
     */
    omit?: client_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_detailsInclude<ExtArgs> | null
    /**
     * Filter which client_details to delete.
     */
    where: client_detailsWhereUniqueInput
  }

  /**
   * client_details deleteMany
   */
  export type client_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which client_details to delete
     */
    where?: client_detailsWhereInput
    /**
     * Limit how many client_details to delete.
     */
    limit?: number
  }

  /**
   * client_details.client_parameter
   */
  export type client_details$client_parameterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_parameter
     */
    select?: client_parameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_parameter
     */
    omit?: client_parameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_parameterInclude<ExtArgs> | null
    where?: client_parameterWhereInput
  }

  /**
   * client_details.client
   */
  export type client_details$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    where?: clientWhereInput
  }

  /**
   * client_details without action
   */
  export type client_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_details
     */
    select?: client_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_details
     */
    omit?: client_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_detailsInclude<ExtArgs> | null
  }


  /**
   * Model client_parameter
   */

  export type AggregateClient_parameter = {
    _count: Client_parameterCountAggregateOutputType | null
    _min: Client_parameterMinAggregateOutputType | null
    _max: Client_parameterMaxAggregateOutputType | null
  }

  export type Client_parameterMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type Client_parameterMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type Client_parameterCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Client_parameterMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Client_parameterMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Client_parameterCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Client_parameterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which client_parameter to aggregate.
     */
    where?: client_parameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_parameters to fetch.
     */
    orderBy?: client_parameterOrderByWithRelationInput | client_parameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: client_parameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned client_parameters
    **/
    _count?: true | Client_parameterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Client_parameterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Client_parameterMaxAggregateInputType
  }

  export type GetClient_parameterAggregateType<T extends Client_parameterAggregateArgs> = {
        [P in keyof T & keyof AggregateClient_parameter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient_parameter[P]>
      : GetScalarType<T[P], AggregateClient_parameter[P]>
  }




  export type client_parameterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: client_parameterWhereInput
    orderBy?: client_parameterOrderByWithAggregationInput | client_parameterOrderByWithAggregationInput[]
    by: Client_parameterScalarFieldEnum[] | Client_parameterScalarFieldEnum
    having?: client_parameterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Client_parameterCountAggregateInputType | true
    _min?: Client_parameterMinAggregateInputType
    _max?: Client_parameterMaxAggregateInputType
  }

  export type Client_parameterGroupByOutputType = {
    id: string
    name: string | null
    _count: Client_parameterCountAggregateOutputType | null
    _min: Client_parameterMinAggregateOutputType | null
    _max: Client_parameterMaxAggregateOutputType | null
  }

  type GetClient_parameterGroupByPayload<T extends client_parameterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Client_parameterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Client_parameterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Client_parameterGroupByOutputType[P]>
            : GetScalarType<T[P], Client_parameterGroupByOutputType[P]>
        }
      >
    >


  export type client_parameterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    client_details?: boolean | client_parameter$client_detailsArgs<ExtArgs>
    _count?: boolean | Client_parameterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client_parameter"]>

  export type client_parameterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["client_parameter"]>

  export type client_parameterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["client_parameter"]>

  export type client_parameterSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type client_parameterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["client_parameter"]>
  export type client_parameterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_details?: boolean | client_parameter$client_detailsArgs<ExtArgs>
    _count?: boolean | Client_parameterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type client_parameterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type client_parameterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $client_parameterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "client_parameter"
    objects: {
      client_details: Prisma.$client_detailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
    }, ExtArgs["result"]["client_parameter"]>
    composites: {}
  }

  type client_parameterGetPayload<S extends boolean | null | undefined | client_parameterDefaultArgs> = $Result.GetResult<Prisma.$client_parameterPayload, S>

  type client_parameterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<client_parameterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Client_parameterCountAggregateInputType | true
    }

  export interface client_parameterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['client_parameter'], meta: { name: 'client_parameter' } }
    /**
     * Find zero or one Client_parameter that matches the filter.
     * @param {client_parameterFindUniqueArgs} args - Arguments to find a Client_parameter
     * @example
     * // Get one Client_parameter
     * const client_parameter = await prisma.client_parameter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends client_parameterFindUniqueArgs>(args: SelectSubset<T, client_parameterFindUniqueArgs<ExtArgs>>): Prisma__client_parameterClient<$Result.GetResult<Prisma.$client_parameterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client_parameter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {client_parameterFindUniqueOrThrowArgs} args - Arguments to find a Client_parameter
     * @example
     * // Get one Client_parameter
     * const client_parameter = await prisma.client_parameter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends client_parameterFindUniqueOrThrowArgs>(args: SelectSubset<T, client_parameterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__client_parameterClient<$Result.GetResult<Prisma.$client_parameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client_parameter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_parameterFindFirstArgs} args - Arguments to find a Client_parameter
     * @example
     * // Get one Client_parameter
     * const client_parameter = await prisma.client_parameter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends client_parameterFindFirstArgs>(args?: SelectSubset<T, client_parameterFindFirstArgs<ExtArgs>>): Prisma__client_parameterClient<$Result.GetResult<Prisma.$client_parameterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client_parameter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_parameterFindFirstOrThrowArgs} args - Arguments to find a Client_parameter
     * @example
     * // Get one Client_parameter
     * const client_parameter = await prisma.client_parameter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends client_parameterFindFirstOrThrowArgs>(args?: SelectSubset<T, client_parameterFindFirstOrThrowArgs<ExtArgs>>): Prisma__client_parameterClient<$Result.GetResult<Prisma.$client_parameterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Client_parameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_parameterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Client_parameters
     * const client_parameters = await prisma.client_parameter.findMany()
     * 
     * // Get first 10 Client_parameters
     * const client_parameters = await prisma.client_parameter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const client_parameterWithIdOnly = await prisma.client_parameter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends client_parameterFindManyArgs>(args?: SelectSubset<T, client_parameterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_parameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client_parameter.
     * @param {client_parameterCreateArgs} args - Arguments to create a Client_parameter.
     * @example
     * // Create one Client_parameter
     * const Client_parameter = await prisma.client_parameter.create({
     *   data: {
     *     // ... data to create a Client_parameter
     *   }
     * })
     * 
     */
    create<T extends client_parameterCreateArgs>(args: SelectSubset<T, client_parameterCreateArgs<ExtArgs>>): Prisma__client_parameterClient<$Result.GetResult<Prisma.$client_parameterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Client_parameters.
     * @param {client_parameterCreateManyArgs} args - Arguments to create many Client_parameters.
     * @example
     * // Create many Client_parameters
     * const client_parameter = await prisma.client_parameter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends client_parameterCreateManyArgs>(args?: SelectSubset<T, client_parameterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Client_parameters and returns the data saved in the database.
     * @param {client_parameterCreateManyAndReturnArgs} args - Arguments to create many Client_parameters.
     * @example
     * // Create many Client_parameters
     * const client_parameter = await prisma.client_parameter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Client_parameters and only return the `id`
     * const client_parameterWithIdOnly = await prisma.client_parameter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends client_parameterCreateManyAndReturnArgs>(args?: SelectSubset<T, client_parameterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_parameterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client_parameter.
     * @param {client_parameterDeleteArgs} args - Arguments to delete one Client_parameter.
     * @example
     * // Delete one Client_parameter
     * const Client_parameter = await prisma.client_parameter.delete({
     *   where: {
     *     // ... filter to delete one Client_parameter
     *   }
     * })
     * 
     */
    delete<T extends client_parameterDeleteArgs>(args: SelectSubset<T, client_parameterDeleteArgs<ExtArgs>>): Prisma__client_parameterClient<$Result.GetResult<Prisma.$client_parameterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client_parameter.
     * @param {client_parameterUpdateArgs} args - Arguments to update one Client_parameter.
     * @example
     * // Update one Client_parameter
     * const client_parameter = await prisma.client_parameter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends client_parameterUpdateArgs>(args: SelectSubset<T, client_parameterUpdateArgs<ExtArgs>>): Prisma__client_parameterClient<$Result.GetResult<Prisma.$client_parameterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Client_parameters.
     * @param {client_parameterDeleteManyArgs} args - Arguments to filter Client_parameters to delete.
     * @example
     * // Delete a few Client_parameters
     * const { count } = await prisma.client_parameter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends client_parameterDeleteManyArgs>(args?: SelectSubset<T, client_parameterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Client_parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_parameterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Client_parameters
     * const client_parameter = await prisma.client_parameter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends client_parameterUpdateManyArgs>(args: SelectSubset<T, client_parameterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Client_parameters and returns the data updated in the database.
     * @param {client_parameterUpdateManyAndReturnArgs} args - Arguments to update many Client_parameters.
     * @example
     * // Update many Client_parameters
     * const client_parameter = await prisma.client_parameter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Client_parameters and only return the `id`
     * const client_parameterWithIdOnly = await prisma.client_parameter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends client_parameterUpdateManyAndReturnArgs>(args: SelectSubset<T, client_parameterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_parameterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client_parameter.
     * @param {client_parameterUpsertArgs} args - Arguments to update or create a Client_parameter.
     * @example
     * // Update or create a Client_parameter
     * const client_parameter = await prisma.client_parameter.upsert({
     *   create: {
     *     // ... data to create a Client_parameter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client_parameter we want to update
     *   }
     * })
     */
    upsert<T extends client_parameterUpsertArgs>(args: SelectSubset<T, client_parameterUpsertArgs<ExtArgs>>): Prisma__client_parameterClient<$Result.GetResult<Prisma.$client_parameterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Client_parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_parameterCountArgs} args - Arguments to filter Client_parameters to count.
     * @example
     * // Count the number of Client_parameters
     * const count = await prisma.client_parameter.count({
     *   where: {
     *     // ... the filter for the Client_parameters we want to count
     *   }
     * })
    **/
    count<T extends client_parameterCountArgs>(
      args?: Subset<T, client_parameterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Client_parameterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client_parameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Client_parameterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Client_parameterAggregateArgs>(args: Subset<T, Client_parameterAggregateArgs>): Prisma.PrismaPromise<GetClient_parameterAggregateType<T>>

    /**
     * Group by Client_parameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_parameterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends client_parameterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: client_parameterGroupByArgs['orderBy'] }
        : { orderBy?: client_parameterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, client_parameterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClient_parameterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the client_parameter model
   */
  readonly fields: client_parameterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for client_parameter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__client_parameterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client_details<T extends client_parameter$client_detailsArgs<ExtArgs> = {}>(args?: Subset<T, client_parameter$client_detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the client_parameter model
   */
  interface client_parameterFieldRefs {
    readonly id: FieldRef<"client_parameter", 'String'>
    readonly name: FieldRef<"client_parameter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * client_parameter findUnique
   */
  export type client_parameterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_parameter
     */
    select?: client_parameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_parameter
     */
    omit?: client_parameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_parameterInclude<ExtArgs> | null
    /**
     * Filter, which client_parameter to fetch.
     */
    where: client_parameterWhereUniqueInput
  }

  /**
   * client_parameter findUniqueOrThrow
   */
  export type client_parameterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_parameter
     */
    select?: client_parameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_parameter
     */
    omit?: client_parameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_parameterInclude<ExtArgs> | null
    /**
     * Filter, which client_parameter to fetch.
     */
    where: client_parameterWhereUniqueInput
  }

  /**
   * client_parameter findFirst
   */
  export type client_parameterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_parameter
     */
    select?: client_parameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_parameter
     */
    omit?: client_parameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_parameterInclude<ExtArgs> | null
    /**
     * Filter, which client_parameter to fetch.
     */
    where?: client_parameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_parameters to fetch.
     */
    orderBy?: client_parameterOrderByWithRelationInput | client_parameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for client_parameters.
     */
    cursor?: client_parameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of client_parameters.
     */
    distinct?: Client_parameterScalarFieldEnum | Client_parameterScalarFieldEnum[]
  }

  /**
   * client_parameter findFirstOrThrow
   */
  export type client_parameterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_parameter
     */
    select?: client_parameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_parameter
     */
    omit?: client_parameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_parameterInclude<ExtArgs> | null
    /**
     * Filter, which client_parameter to fetch.
     */
    where?: client_parameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_parameters to fetch.
     */
    orderBy?: client_parameterOrderByWithRelationInput | client_parameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for client_parameters.
     */
    cursor?: client_parameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of client_parameters.
     */
    distinct?: Client_parameterScalarFieldEnum | Client_parameterScalarFieldEnum[]
  }

  /**
   * client_parameter findMany
   */
  export type client_parameterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_parameter
     */
    select?: client_parameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_parameter
     */
    omit?: client_parameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_parameterInclude<ExtArgs> | null
    /**
     * Filter, which client_parameters to fetch.
     */
    where?: client_parameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_parameters to fetch.
     */
    orderBy?: client_parameterOrderByWithRelationInput | client_parameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing client_parameters.
     */
    cursor?: client_parameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_parameters.
     */
    skip?: number
    distinct?: Client_parameterScalarFieldEnum | Client_parameterScalarFieldEnum[]
  }

  /**
   * client_parameter create
   */
  export type client_parameterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_parameter
     */
    select?: client_parameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_parameter
     */
    omit?: client_parameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_parameterInclude<ExtArgs> | null
    /**
     * The data needed to create a client_parameter.
     */
    data: XOR<client_parameterCreateInput, client_parameterUncheckedCreateInput>
  }

  /**
   * client_parameter createMany
   */
  export type client_parameterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many client_parameters.
     */
    data: client_parameterCreateManyInput | client_parameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * client_parameter createManyAndReturn
   */
  export type client_parameterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_parameter
     */
    select?: client_parameterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the client_parameter
     */
    omit?: client_parameterOmit<ExtArgs> | null
    /**
     * The data used to create many client_parameters.
     */
    data: client_parameterCreateManyInput | client_parameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * client_parameter update
   */
  export type client_parameterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_parameter
     */
    select?: client_parameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_parameter
     */
    omit?: client_parameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_parameterInclude<ExtArgs> | null
    /**
     * The data needed to update a client_parameter.
     */
    data: XOR<client_parameterUpdateInput, client_parameterUncheckedUpdateInput>
    /**
     * Choose, which client_parameter to update.
     */
    where: client_parameterWhereUniqueInput
  }

  /**
   * client_parameter updateMany
   */
  export type client_parameterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update client_parameters.
     */
    data: XOR<client_parameterUpdateManyMutationInput, client_parameterUncheckedUpdateManyInput>
    /**
     * Filter which client_parameters to update
     */
    where?: client_parameterWhereInput
    /**
     * Limit how many client_parameters to update.
     */
    limit?: number
  }

  /**
   * client_parameter updateManyAndReturn
   */
  export type client_parameterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_parameter
     */
    select?: client_parameterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the client_parameter
     */
    omit?: client_parameterOmit<ExtArgs> | null
    /**
     * The data used to update client_parameters.
     */
    data: XOR<client_parameterUpdateManyMutationInput, client_parameterUncheckedUpdateManyInput>
    /**
     * Filter which client_parameters to update
     */
    where?: client_parameterWhereInput
    /**
     * Limit how many client_parameters to update.
     */
    limit?: number
  }

  /**
   * client_parameter upsert
   */
  export type client_parameterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_parameter
     */
    select?: client_parameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_parameter
     */
    omit?: client_parameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_parameterInclude<ExtArgs> | null
    /**
     * The filter to search for the client_parameter to update in case it exists.
     */
    where: client_parameterWhereUniqueInput
    /**
     * In case the client_parameter found by the `where` argument doesn't exist, create a new client_parameter with this data.
     */
    create: XOR<client_parameterCreateInput, client_parameterUncheckedCreateInput>
    /**
     * In case the client_parameter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<client_parameterUpdateInput, client_parameterUncheckedUpdateInput>
  }

  /**
   * client_parameter delete
   */
  export type client_parameterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_parameter
     */
    select?: client_parameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_parameter
     */
    omit?: client_parameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_parameterInclude<ExtArgs> | null
    /**
     * Filter which client_parameter to delete.
     */
    where: client_parameterWhereUniqueInput
  }

  /**
   * client_parameter deleteMany
   */
  export type client_parameterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which client_parameters to delete
     */
    where?: client_parameterWhereInput
    /**
     * Limit how many client_parameters to delete.
     */
    limit?: number
  }

  /**
   * client_parameter.client_details
   */
  export type client_parameter$client_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_details
     */
    select?: client_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_details
     */
    omit?: client_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_detailsInclude<ExtArgs> | null
    where?: client_detailsWhereInput
    orderBy?: client_detailsOrderByWithRelationInput | client_detailsOrderByWithRelationInput[]
    cursor?: client_detailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Client_detailsScalarFieldEnum | Client_detailsScalarFieldEnum[]
  }

  /**
   * client_parameter without action
   */
  export type client_parameterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_parameter
     */
    select?: client_parameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_parameter
     */
    omit?: client_parameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_parameterInclude<ExtArgs> | null
  }


  /**
   * Model client_service
   */

  export type AggregateClient_service = {
    _count: Client_serviceCountAggregateOutputType | null
    _min: Client_serviceMinAggregateOutputType | null
    _max: Client_serviceMaxAggregateOutputType | null
  }

  export type Client_serviceMinAggregateOutputType = {
    id: string | null
    client_id: string | null
    service_id: string | null
    created: Date | null
    updated: Date | null
    started: Date | null
    delivery: Date | null
    expiry: Date | null
    frequency: string | null
    unit: string | null
    url_api: string | null
    token_api: string | null
  }

  export type Client_serviceMaxAggregateOutputType = {
    id: string | null
    client_id: string | null
    service_id: string | null
    created: Date | null
    updated: Date | null
    started: Date | null
    delivery: Date | null
    expiry: Date | null
    frequency: string | null
    unit: string | null
    url_api: string | null
    token_api: string | null
  }

  export type Client_serviceCountAggregateOutputType = {
    id: number
    client_id: number
    service_id: number
    created: number
    updated: number
    started: number
    delivery: number
    expiry: number
    frequency: number
    unit: number
    url_api: number
    token_api: number
    _all: number
  }


  export type Client_serviceMinAggregateInputType = {
    id?: true
    client_id?: true
    service_id?: true
    created?: true
    updated?: true
    started?: true
    delivery?: true
    expiry?: true
    frequency?: true
    unit?: true
    url_api?: true
    token_api?: true
  }

  export type Client_serviceMaxAggregateInputType = {
    id?: true
    client_id?: true
    service_id?: true
    created?: true
    updated?: true
    started?: true
    delivery?: true
    expiry?: true
    frequency?: true
    unit?: true
    url_api?: true
    token_api?: true
  }

  export type Client_serviceCountAggregateInputType = {
    id?: true
    client_id?: true
    service_id?: true
    created?: true
    updated?: true
    started?: true
    delivery?: true
    expiry?: true
    frequency?: true
    unit?: true
    url_api?: true
    token_api?: true
    _all?: true
  }

  export type Client_serviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which client_service to aggregate.
     */
    where?: client_serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_services to fetch.
     */
    orderBy?: client_serviceOrderByWithRelationInput | client_serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: client_serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned client_services
    **/
    _count?: true | Client_serviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Client_serviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Client_serviceMaxAggregateInputType
  }

  export type GetClient_serviceAggregateType<T extends Client_serviceAggregateArgs> = {
        [P in keyof T & keyof AggregateClient_service]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient_service[P]>
      : GetScalarType<T[P], AggregateClient_service[P]>
  }




  export type client_serviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: client_serviceWhereInput
    orderBy?: client_serviceOrderByWithAggregationInput | client_serviceOrderByWithAggregationInput[]
    by: Client_serviceScalarFieldEnum[] | Client_serviceScalarFieldEnum
    having?: client_serviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Client_serviceCountAggregateInputType | true
    _min?: Client_serviceMinAggregateInputType
    _max?: Client_serviceMaxAggregateInputType
  }

  export type Client_serviceGroupByOutputType = {
    id: string
    client_id: string | null
    service_id: string | null
    created: Date | null
    updated: Date | null
    started: Date | null
    delivery: Date | null
    expiry: Date | null
    frequency: string | null
    unit: string | null
    url_api: string | null
    token_api: string | null
    _count: Client_serviceCountAggregateOutputType | null
    _min: Client_serviceMinAggregateOutputType | null
    _max: Client_serviceMaxAggregateOutputType | null
  }

  type GetClient_serviceGroupByPayload<T extends client_serviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Client_serviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Client_serviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Client_serviceGroupByOutputType[P]>
            : GetScalarType<T[P], Client_serviceGroupByOutputType[P]>
        }
      >
    >


  export type client_serviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    service_id?: boolean
    created?: boolean
    updated?: boolean
    started?: boolean
    delivery?: boolean
    expiry?: boolean
    frequency?: boolean
    unit?: boolean
    url_api?: boolean
    token_api?: boolean
    client?: boolean | client_service$clientArgs<ExtArgs>
    service?: boolean | client_service$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["client_service"]>

  export type client_serviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    service_id?: boolean
    created?: boolean
    updated?: boolean
    started?: boolean
    delivery?: boolean
    expiry?: boolean
    frequency?: boolean
    unit?: boolean
    url_api?: boolean
    token_api?: boolean
    client?: boolean | client_service$clientArgs<ExtArgs>
    service?: boolean | client_service$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["client_service"]>

  export type client_serviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    service_id?: boolean
    created?: boolean
    updated?: boolean
    started?: boolean
    delivery?: boolean
    expiry?: boolean
    frequency?: boolean
    unit?: boolean
    url_api?: boolean
    token_api?: boolean
    client?: boolean | client_service$clientArgs<ExtArgs>
    service?: boolean | client_service$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["client_service"]>

  export type client_serviceSelectScalar = {
    id?: boolean
    client_id?: boolean
    service_id?: boolean
    created?: boolean
    updated?: boolean
    started?: boolean
    delivery?: boolean
    expiry?: boolean
    frequency?: boolean
    unit?: boolean
    url_api?: boolean
    token_api?: boolean
  }

  export type client_serviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "client_id" | "service_id" | "created" | "updated" | "started" | "delivery" | "expiry" | "frequency" | "unit" | "url_api" | "token_api", ExtArgs["result"]["client_service"]>
  export type client_serviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | client_service$clientArgs<ExtArgs>
    service?: boolean | client_service$serviceArgs<ExtArgs>
  }
  export type client_serviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | client_service$clientArgs<ExtArgs>
    service?: boolean | client_service$serviceArgs<ExtArgs>
  }
  export type client_serviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | client_service$clientArgs<ExtArgs>
    service?: boolean | client_service$serviceArgs<ExtArgs>
  }

  export type $client_servicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "client_service"
    objects: {
      client: Prisma.$clientPayload<ExtArgs> | null
      service: Prisma.$servicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      client_id: string | null
      service_id: string | null
      created: Date | null
      updated: Date | null
      started: Date | null
      delivery: Date | null
      expiry: Date | null
      frequency: string | null
      unit: string | null
      url_api: string | null
      token_api: string | null
    }, ExtArgs["result"]["client_service"]>
    composites: {}
  }

  type client_serviceGetPayload<S extends boolean | null | undefined | client_serviceDefaultArgs> = $Result.GetResult<Prisma.$client_servicePayload, S>

  type client_serviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<client_serviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Client_serviceCountAggregateInputType | true
    }

  export interface client_serviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['client_service'], meta: { name: 'client_service' } }
    /**
     * Find zero or one Client_service that matches the filter.
     * @param {client_serviceFindUniqueArgs} args - Arguments to find a Client_service
     * @example
     * // Get one Client_service
     * const client_service = await prisma.client_service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends client_serviceFindUniqueArgs>(args: SelectSubset<T, client_serviceFindUniqueArgs<ExtArgs>>): Prisma__client_serviceClient<$Result.GetResult<Prisma.$client_servicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client_service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {client_serviceFindUniqueOrThrowArgs} args - Arguments to find a Client_service
     * @example
     * // Get one Client_service
     * const client_service = await prisma.client_service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends client_serviceFindUniqueOrThrowArgs>(args: SelectSubset<T, client_serviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__client_serviceClient<$Result.GetResult<Prisma.$client_servicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client_service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_serviceFindFirstArgs} args - Arguments to find a Client_service
     * @example
     * // Get one Client_service
     * const client_service = await prisma.client_service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends client_serviceFindFirstArgs>(args?: SelectSubset<T, client_serviceFindFirstArgs<ExtArgs>>): Prisma__client_serviceClient<$Result.GetResult<Prisma.$client_servicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client_service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_serviceFindFirstOrThrowArgs} args - Arguments to find a Client_service
     * @example
     * // Get one Client_service
     * const client_service = await prisma.client_service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends client_serviceFindFirstOrThrowArgs>(args?: SelectSubset<T, client_serviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__client_serviceClient<$Result.GetResult<Prisma.$client_servicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Client_services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_serviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Client_services
     * const client_services = await prisma.client_service.findMany()
     * 
     * // Get first 10 Client_services
     * const client_services = await prisma.client_service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const client_serviceWithIdOnly = await prisma.client_service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends client_serviceFindManyArgs>(args?: SelectSubset<T, client_serviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_servicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client_service.
     * @param {client_serviceCreateArgs} args - Arguments to create a Client_service.
     * @example
     * // Create one Client_service
     * const Client_service = await prisma.client_service.create({
     *   data: {
     *     // ... data to create a Client_service
     *   }
     * })
     * 
     */
    create<T extends client_serviceCreateArgs>(args: SelectSubset<T, client_serviceCreateArgs<ExtArgs>>): Prisma__client_serviceClient<$Result.GetResult<Prisma.$client_servicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Client_services.
     * @param {client_serviceCreateManyArgs} args - Arguments to create many Client_services.
     * @example
     * // Create many Client_services
     * const client_service = await prisma.client_service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends client_serviceCreateManyArgs>(args?: SelectSubset<T, client_serviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Client_services and returns the data saved in the database.
     * @param {client_serviceCreateManyAndReturnArgs} args - Arguments to create many Client_services.
     * @example
     * // Create many Client_services
     * const client_service = await prisma.client_service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Client_services and only return the `id`
     * const client_serviceWithIdOnly = await prisma.client_service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends client_serviceCreateManyAndReturnArgs>(args?: SelectSubset<T, client_serviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_servicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client_service.
     * @param {client_serviceDeleteArgs} args - Arguments to delete one Client_service.
     * @example
     * // Delete one Client_service
     * const Client_service = await prisma.client_service.delete({
     *   where: {
     *     // ... filter to delete one Client_service
     *   }
     * })
     * 
     */
    delete<T extends client_serviceDeleteArgs>(args: SelectSubset<T, client_serviceDeleteArgs<ExtArgs>>): Prisma__client_serviceClient<$Result.GetResult<Prisma.$client_servicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client_service.
     * @param {client_serviceUpdateArgs} args - Arguments to update one Client_service.
     * @example
     * // Update one Client_service
     * const client_service = await prisma.client_service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends client_serviceUpdateArgs>(args: SelectSubset<T, client_serviceUpdateArgs<ExtArgs>>): Prisma__client_serviceClient<$Result.GetResult<Prisma.$client_servicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Client_services.
     * @param {client_serviceDeleteManyArgs} args - Arguments to filter Client_services to delete.
     * @example
     * // Delete a few Client_services
     * const { count } = await prisma.client_service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends client_serviceDeleteManyArgs>(args?: SelectSubset<T, client_serviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Client_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_serviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Client_services
     * const client_service = await prisma.client_service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends client_serviceUpdateManyArgs>(args: SelectSubset<T, client_serviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Client_services and returns the data updated in the database.
     * @param {client_serviceUpdateManyAndReturnArgs} args - Arguments to update many Client_services.
     * @example
     * // Update many Client_services
     * const client_service = await prisma.client_service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Client_services and only return the `id`
     * const client_serviceWithIdOnly = await prisma.client_service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends client_serviceUpdateManyAndReturnArgs>(args: SelectSubset<T, client_serviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_servicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client_service.
     * @param {client_serviceUpsertArgs} args - Arguments to update or create a Client_service.
     * @example
     * // Update or create a Client_service
     * const client_service = await prisma.client_service.upsert({
     *   create: {
     *     // ... data to create a Client_service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client_service we want to update
     *   }
     * })
     */
    upsert<T extends client_serviceUpsertArgs>(args: SelectSubset<T, client_serviceUpsertArgs<ExtArgs>>): Prisma__client_serviceClient<$Result.GetResult<Prisma.$client_servicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Client_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_serviceCountArgs} args - Arguments to filter Client_services to count.
     * @example
     * // Count the number of Client_services
     * const count = await prisma.client_service.count({
     *   where: {
     *     // ... the filter for the Client_services we want to count
     *   }
     * })
    **/
    count<T extends client_serviceCountArgs>(
      args?: Subset<T, client_serviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Client_serviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client_service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Client_serviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Client_serviceAggregateArgs>(args: Subset<T, Client_serviceAggregateArgs>): Prisma.PrismaPromise<GetClient_serviceAggregateType<T>>

    /**
     * Group by Client_service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_serviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends client_serviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: client_serviceGroupByArgs['orderBy'] }
        : { orderBy?: client_serviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, client_serviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClient_serviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the client_service model
   */
  readonly fields: client_serviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for client_service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__client_serviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends client_service$clientArgs<ExtArgs> = {}>(args?: Subset<T, client_service$clientArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    service<T extends client_service$serviceArgs<ExtArgs> = {}>(args?: Subset<T, client_service$serviceArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the client_service model
   */
  interface client_serviceFieldRefs {
    readonly id: FieldRef<"client_service", 'String'>
    readonly client_id: FieldRef<"client_service", 'String'>
    readonly service_id: FieldRef<"client_service", 'String'>
    readonly created: FieldRef<"client_service", 'DateTime'>
    readonly updated: FieldRef<"client_service", 'DateTime'>
    readonly started: FieldRef<"client_service", 'DateTime'>
    readonly delivery: FieldRef<"client_service", 'DateTime'>
    readonly expiry: FieldRef<"client_service", 'DateTime'>
    readonly frequency: FieldRef<"client_service", 'String'>
    readonly unit: FieldRef<"client_service", 'String'>
    readonly url_api: FieldRef<"client_service", 'String'>
    readonly token_api: FieldRef<"client_service", 'String'>
  }
    

  // Custom InputTypes
  /**
   * client_service findUnique
   */
  export type client_serviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_service
     */
    select?: client_serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_service
     */
    omit?: client_serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_serviceInclude<ExtArgs> | null
    /**
     * Filter, which client_service to fetch.
     */
    where: client_serviceWhereUniqueInput
  }

  /**
   * client_service findUniqueOrThrow
   */
  export type client_serviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_service
     */
    select?: client_serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_service
     */
    omit?: client_serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_serviceInclude<ExtArgs> | null
    /**
     * Filter, which client_service to fetch.
     */
    where: client_serviceWhereUniqueInput
  }

  /**
   * client_service findFirst
   */
  export type client_serviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_service
     */
    select?: client_serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_service
     */
    omit?: client_serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_serviceInclude<ExtArgs> | null
    /**
     * Filter, which client_service to fetch.
     */
    where?: client_serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_services to fetch.
     */
    orderBy?: client_serviceOrderByWithRelationInput | client_serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for client_services.
     */
    cursor?: client_serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of client_services.
     */
    distinct?: Client_serviceScalarFieldEnum | Client_serviceScalarFieldEnum[]
  }

  /**
   * client_service findFirstOrThrow
   */
  export type client_serviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_service
     */
    select?: client_serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_service
     */
    omit?: client_serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_serviceInclude<ExtArgs> | null
    /**
     * Filter, which client_service to fetch.
     */
    where?: client_serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_services to fetch.
     */
    orderBy?: client_serviceOrderByWithRelationInput | client_serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for client_services.
     */
    cursor?: client_serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of client_services.
     */
    distinct?: Client_serviceScalarFieldEnum | Client_serviceScalarFieldEnum[]
  }

  /**
   * client_service findMany
   */
  export type client_serviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_service
     */
    select?: client_serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_service
     */
    omit?: client_serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_serviceInclude<ExtArgs> | null
    /**
     * Filter, which client_services to fetch.
     */
    where?: client_serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_services to fetch.
     */
    orderBy?: client_serviceOrderByWithRelationInput | client_serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing client_services.
     */
    cursor?: client_serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_services.
     */
    skip?: number
    distinct?: Client_serviceScalarFieldEnum | Client_serviceScalarFieldEnum[]
  }

  /**
   * client_service create
   */
  export type client_serviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_service
     */
    select?: client_serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_service
     */
    omit?: client_serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_serviceInclude<ExtArgs> | null
    /**
     * The data needed to create a client_service.
     */
    data: XOR<client_serviceCreateInput, client_serviceUncheckedCreateInput>
  }

  /**
   * client_service createMany
   */
  export type client_serviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many client_services.
     */
    data: client_serviceCreateManyInput | client_serviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * client_service createManyAndReturn
   */
  export type client_serviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_service
     */
    select?: client_serviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the client_service
     */
    omit?: client_serviceOmit<ExtArgs> | null
    /**
     * The data used to create many client_services.
     */
    data: client_serviceCreateManyInput | client_serviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_serviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * client_service update
   */
  export type client_serviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_service
     */
    select?: client_serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_service
     */
    omit?: client_serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_serviceInclude<ExtArgs> | null
    /**
     * The data needed to update a client_service.
     */
    data: XOR<client_serviceUpdateInput, client_serviceUncheckedUpdateInput>
    /**
     * Choose, which client_service to update.
     */
    where: client_serviceWhereUniqueInput
  }

  /**
   * client_service updateMany
   */
  export type client_serviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update client_services.
     */
    data: XOR<client_serviceUpdateManyMutationInput, client_serviceUncheckedUpdateManyInput>
    /**
     * Filter which client_services to update
     */
    where?: client_serviceWhereInput
    /**
     * Limit how many client_services to update.
     */
    limit?: number
  }

  /**
   * client_service updateManyAndReturn
   */
  export type client_serviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_service
     */
    select?: client_serviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the client_service
     */
    omit?: client_serviceOmit<ExtArgs> | null
    /**
     * The data used to update client_services.
     */
    data: XOR<client_serviceUpdateManyMutationInput, client_serviceUncheckedUpdateManyInput>
    /**
     * Filter which client_services to update
     */
    where?: client_serviceWhereInput
    /**
     * Limit how many client_services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_serviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * client_service upsert
   */
  export type client_serviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_service
     */
    select?: client_serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_service
     */
    omit?: client_serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_serviceInclude<ExtArgs> | null
    /**
     * The filter to search for the client_service to update in case it exists.
     */
    where: client_serviceWhereUniqueInput
    /**
     * In case the client_service found by the `where` argument doesn't exist, create a new client_service with this data.
     */
    create: XOR<client_serviceCreateInput, client_serviceUncheckedCreateInput>
    /**
     * In case the client_service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<client_serviceUpdateInput, client_serviceUncheckedUpdateInput>
  }

  /**
   * client_service delete
   */
  export type client_serviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_service
     */
    select?: client_serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_service
     */
    omit?: client_serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_serviceInclude<ExtArgs> | null
    /**
     * Filter which client_service to delete.
     */
    where: client_serviceWhereUniqueInput
  }

  /**
   * client_service deleteMany
   */
  export type client_serviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which client_services to delete
     */
    where?: client_serviceWhereInput
    /**
     * Limit how many client_services to delete.
     */
    limit?: number
  }

  /**
   * client_service.client
   */
  export type client_service$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    where?: clientWhereInput
  }

  /**
   * client_service.service
   */
  export type client_service$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    where?: serviceWhereInput
  }

  /**
   * client_service without action
   */
  export type client_serviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_service
     */
    select?: client_serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_service
     */
    omit?: client_serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_serviceInclude<ExtArgs> | null
  }


  /**
   * Model invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    client_id: string | null
    description: string | null
    value: string | null
    url: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    client_id: string | null
    description: string | null
    value: string | null
    url: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    client_id: number
    description: number
    value: number
    url: number
    created: number
    updated: number
    status: number
    _all: number
  }


  export type InvoiceMinAggregateInputType = {
    id?: true
    client_id?: true
    description?: true
    value?: true
    url?: true
    created?: true
    updated?: true
    status?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    client_id?: true
    description?: true
    value?: true
    url?: true
    created?: true
    updated?: true
    status?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    client_id?: true
    description?: true
    value?: true
    url?: true
    created?: true
    updated?: true
    status?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoice to aggregate.
     */
    where?: invoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type invoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoiceWhereInput
    orderBy?: invoiceOrderByWithAggregationInput | invoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: invoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    client_id: string | null
    description: string | null
    value: string | null
    url: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
    _count: InvoiceCountAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends invoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type invoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    description?: boolean
    value?: boolean
    url?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    client?: boolean | invoice$clientArgs<ExtArgs>
    invoice_detail?: boolean | invoice$invoice_detailArgs<ExtArgs>
    payment_attachment?: boolean | invoice$payment_attachmentArgs<ExtArgs>
    quote_attachment?: boolean | invoice$quote_attachmentArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type invoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    description?: boolean
    value?: boolean
    url?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    client?: boolean | invoice$clientArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type invoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    description?: boolean
    value?: boolean
    url?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    client?: boolean | invoice$clientArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type invoiceSelectScalar = {
    id?: boolean
    client_id?: boolean
    description?: boolean
    value?: boolean
    url?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
  }

  export type invoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "client_id" | "description" | "value" | "url" | "created" | "updated" | "status", ExtArgs["result"]["invoice"]>
  export type invoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | invoice$clientArgs<ExtArgs>
    invoice_detail?: boolean | invoice$invoice_detailArgs<ExtArgs>
    payment_attachment?: boolean | invoice$payment_attachmentArgs<ExtArgs>
    quote_attachment?: boolean | invoice$quote_attachmentArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type invoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | invoice$clientArgs<ExtArgs>
  }
  export type invoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | invoice$clientArgs<ExtArgs>
  }

  export type $invoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invoice"
    objects: {
      client: Prisma.$clientPayload<ExtArgs> | null
      invoice_detail: Prisma.$invoice_detailPayload<ExtArgs>[]
      payment_attachment: Prisma.$payment_attachmentPayload<ExtArgs>[]
      quote_attachment: Prisma.$quote_attachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      client_id: string | null
      description: string | null
      value: string | null
      url: string | null
      created: Date | null
      updated: Date | null
      status: boolean | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type invoiceGetPayload<S extends boolean | null | undefined | invoiceDefaultArgs> = $Result.GetResult<Prisma.$invoicePayload, S>

  type invoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<invoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface invoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invoice'], meta: { name: 'invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {invoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invoiceFindUniqueArgs>(args: SelectSubset<T, invoiceFindUniqueArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {invoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, invoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invoiceFindFirstArgs>(args?: SelectSubset<T, invoiceFindFirstArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, invoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invoiceFindManyArgs>(args?: SelectSubset<T, invoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {invoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends invoiceCreateArgs>(args: SelectSubset<T, invoiceCreateArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {invoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invoiceCreateManyArgs>(args?: SelectSubset<T, invoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {invoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends invoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, invoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {invoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends invoiceDeleteArgs>(args: SelectSubset<T, invoiceDeleteArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {invoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invoiceUpdateArgs>(args: SelectSubset<T, invoiceUpdateArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {invoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invoiceDeleteManyArgs>(args?: SelectSubset<T, invoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invoiceUpdateManyArgs>(args: SelectSubset<T, invoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {invoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends invoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, invoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {invoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends invoiceUpsertArgs>(args: SelectSubset<T, invoiceUpsertArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends invoiceCountArgs>(
      args?: Subset<T, invoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invoiceGroupByArgs['orderBy'] }
        : { orderBy?: invoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invoice model
   */
  readonly fields: invoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends invoice$clientArgs<ExtArgs> = {}>(args?: Subset<T, invoice$clientArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoice_detail<T extends invoice$invoice_detailArgs<ExtArgs> = {}>(args?: Subset<T, invoice$invoice_detailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_detailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment_attachment<T extends invoice$payment_attachmentArgs<ExtArgs> = {}>(args?: Subset<T, invoice$payment_attachmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_attachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quote_attachment<T extends invoice$quote_attachmentArgs<ExtArgs> = {}>(args?: Subset<T, invoice$quote_attachmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_attachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invoice model
   */
  interface invoiceFieldRefs {
    readonly id: FieldRef<"invoice", 'String'>
    readonly client_id: FieldRef<"invoice", 'String'>
    readonly description: FieldRef<"invoice", 'String'>
    readonly value: FieldRef<"invoice", 'String'>
    readonly url: FieldRef<"invoice", 'String'>
    readonly created: FieldRef<"invoice", 'DateTime'>
    readonly updated: FieldRef<"invoice", 'DateTime'>
    readonly status: FieldRef<"invoice", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * invoice findUnique
   */
  export type invoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter, which invoice to fetch.
     */
    where: invoiceWhereUniqueInput
  }

  /**
   * invoice findUniqueOrThrow
   */
  export type invoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter, which invoice to fetch.
     */
    where: invoiceWhereUniqueInput
  }

  /**
   * invoice findFirst
   */
  export type invoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter, which invoice to fetch.
     */
    where?: invoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoices.
     */
    cursor?: invoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * invoice findFirstOrThrow
   */
  export type invoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter, which invoice to fetch.
     */
    where?: invoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoices.
     */
    cursor?: invoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * invoice findMany
   */
  export type invoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where?: invoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invoices.
     */
    cursor?: invoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * invoice create
   */
  export type invoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a invoice.
     */
    data: XOR<invoiceCreateInput, invoiceUncheckedCreateInput>
  }

  /**
   * invoice createMany
   */
  export type invoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invoices.
     */
    data: invoiceCreateManyInput | invoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invoice createManyAndReturn
   */
  export type invoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * The data used to create many invoices.
     */
    data: invoiceCreateManyInput | invoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * invoice update
   */
  export type invoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a invoice.
     */
    data: XOR<invoiceUpdateInput, invoiceUncheckedUpdateInput>
    /**
     * Choose, which invoice to update.
     */
    where: invoiceWhereUniqueInput
  }

  /**
   * invoice updateMany
   */
  export type invoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invoices.
     */
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyInput>
    /**
     * Filter which invoices to update
     */
    where?: invoiceWhereInput
    /**
     * Limit how many invoices to update.
     */
    limit?: number
  }

  /**
   * invoice updateManyAndReturn
   */
  export type invoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * The data used to update invoices.
     */
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyInput>
    /**
     * Filter which invoices to update
     */
    where?: invoiceWhereInput
    /**
     * Limit how many invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * invoice upsert
   */
  export type invoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the invoice to update in case it exists.
     */
    where: invoiceWhereUniqueInput
    /**
     * In case the invoice found by the `where` argument doesn't exist, create a new invoice with this data.
     */
    create: XOR<invoiceCreateInput, invoiceUncheckedCreateInput>
    /**
     * In case the invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invoiceUpdateInput, invoiceUncheckedUpdateInput>
  }

  /**
   * invoice delete
   */
  export type invoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter which invoice to delete.
     */
    where: invoiceWhereUniqueInput
  }

  /**
   * invoice deleteMany
   */
  export type invoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoices to delete
     */
    where?: invoiceWhereInput
    /**
     * Limit how many invoices to delete.
     */
    limit?: number
  }

  /**
   * invoice.client
   */
  export type invoice$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    where?: clientWhereInput
  }

  /**
   * invoice.invoice_detail
   */
  export type invoice$invoice_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_detail
     */
    select?: invoice_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_detail
     */
    omit?: invoice_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_detailInclude<ExtArgs> | null
    where?: invoice_detailWhereInput
    orderBy?: invoice_detailOrderByWithRelationInput | invoice_detailOrderByWithRelationInput[]
    cursor?: invoice_detailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Invoice_detailScalarFieldEnum | Invoice_detailScalarFieldEnum[]
  }

  /**
   * invoice.payment_attachment
   */
  export type invoice$payment_attachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_attachment
     */
    select?: payment_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_attachment
     */
    omit?: payment_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_attachmentInclude<ExtArgs> | null
    where?: payment_attachmentWhereInput
    orderBy?: payment_attachmentOrderByWithRelationInput | payment_attachmentOrderByWithRelationInput[]
    cursor?: payment_attachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Payment_attachmentScalarFieldEnum | Payment_attachmentScalarFieldEnum[]
  }

  /**
   * invoice.quote_attachment
   */
  export type invoice$quote_attachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_attachment
     */
    select?: quote_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_attachment
     */
    omit?: quote_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_attachmentInclude<ExtArgs> | null
    where?: quote_attachmentWhereInput
    orderBy?: quote_attachmentOrderByWithRelationInput | quote_attachmentOrderByWithRelationInput[]
    cursor?: quote_attachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Quote_attachmentScalarFieldEnum | Quote_attachmentScalarFieldEnum[]
  }

  /**
   * invoice without action
   */
  export type invoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
  }


  /**
   * Model invoice_detail
   */

  export type AggregateInvoice_detail = {
    _count: Invoice_detailCountAggregateOutputType | null
    _avg: Invoice_detailAvgAggregateOutputType | null
    _sum: Invoice_detailSumAggregateOutputType | null
    _min: Invoice_detailMinAggregateOutputType | null
    _max: Invoice_detailMaxAggregateOutputType | null
  }

  export type Invoice_detailAvgAggregateOutputType = {
    item: number | null
    quantity: number | null
    total_value: number | null
  }

  export type Invoice_detailSumAggregateOutputType = {
    item: number | null
    quantity: number | null
    total_value: number | null
  }

  export type Invoice_detailMinAggregateOutputType = {
    id: string | null
    invoice_id: string | null
    service_id: string | null
    item: number | null
    quantity: number | null
    total_value: number | null
    created: Date | null
    updated: Date | null
    status: boolean | null
  }

  export type Invoice_detailMaxAggregateOutputType = {
    id: string | null
    invoice_id: string | null
    service_id: string | null
    item: number | null
    quantity: number | null
    total_value: number | null
    created: Date | null
    updated: Date | null
    status: boolean | null
  }

  export type Invoice_detailCountAggregateOutputType = {
    id: number
    invoice_id: number
    service_id: number
    item: number
    quantity: number
    total_value: number
    created: number
    updated: number
    status: number
    _all: number
  }


  export type Invoice_detailAvgAggregateInputType = {
    item?: true
    quantity?: true
    total_value?: true
  }

  export type Invoice_detailSumAggregateInputType = {
    item?: true
    quantity?: true
    total_value?: true
  }

  export type Invoice_detailMinAggregateInputType = {
    id?: true
    invoice_id?: true
    service_id?: true
    item?: true
    quantity?: true
    total_value?: true
    created?: true
    updated?: true
    status?: true
  }

  export type Invoice_detailMaxAggregateInputType = {
    id?: true
    invoice_id?: true
    service_id?: true
    item?: true
    quantity?: true
    total_value?: true
    created?: true
    updated?: true
    status?: true
  }

  export type Invoice_detailCountAggregateInputType = {
    id?: true
    invoice_id?: true
    service_id?: true
    item?: true
    quantity?: true
    total_value?: true
    created?: true
    updated?: true
    status?: true
    _all?: true
  }

  export type Invoice_detailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoice_detail to aggregate.
     */
    where?: invoice_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoice_details to fetch.
     */
    orderBy?: invoice_detailOrderByWithRelationInput | invoice_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invoice_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoice_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoice_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invoice_details
    **/
    _count?: true | Invoice_detailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Invoice_detailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Invoice_detailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Invoice_detailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Invoice_detailMaxAggregateInputType
  }

  export type GetInvoice_detailAggregateType<T extends Invoice_detailAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice_detail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice_detail[P]>
      : GetScalarType<T[P], AggregateInvoice_detail[P]>
  }




  export type invoice_detailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoice_detailWhereInput
    orderBy?: invoice_detailOrderByWithAggregationInput | invoice_detailOrderByWithAggregationInput[]
    by: Invoice_detailScalarFieldEnum[] | Invoice_detailScalarFieldEnum
    having?: invoice_detailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Invoice_detailCountAggregateInputType | true
    _avg?: Invoice_detailAvgAggregateInputType
    _sum?: Invoice_detailSumAggregateInputType
    _min?: Invoice_detailMinAggregateInputType
    _max?: Invoice_detailMaxAggregateInputType
  }

  export type Invoice_detailGroupByOutputType = {
    id: string
    invoice_id: string | null
    service_id: string | null
    item: number | null
    quantity: number | null
    total_value: number | null
    created: Date | null
    updated: Date | null
    status: boolean | null
    _count: Invoice_detailCountAggregateOutputType | null
    _avg: Invoice_detailAvgAggregateOutputType | null
    _sum: Invoice_detailSumAggregateOutputType | null
    _min: Invoice_detailMinAggregateOutputType | null
    _max: Invoice_detailMaxAggregateOutputType | null
  }

  type GetInvoice_detailGroupByPayload<T extends invoice_detailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Invoice_detailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Invoice_detailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Invoice_detailGroupByOutputType[P]>
            : GetScalarType<T[P], Invoice_detailGroupByOutputType[P]>
        }
      >
    >


  export type invoice_detailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    service_id?: boolean
    item?: boolean
    quantity?: boolean
    total_value?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    invoice?: boolean | invoice_detail$invoiceArgs<ExtArgs>
    service?: boolean | invoice_detail$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["invoice_detail"]>

  export type invoice_detailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    service_id?: boolean
    item?: boolean
    quantity?: boolean
    total_value?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    invoice?: boolean | invoice_detail$invoiceArgs<ExtArgs>
    service?: boolean | invoice_detail$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["invoice_detail"]>

  export type invoice_detailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    service_id?: boolean
    item?: boolean
    quantity?: boolean
    total_value?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    invoice?: boolean | invoice_detail$invoiceArgs<ExtArgs>
    service?: boolean | invoice_detail$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["invoice_detail"]>

  export type invoice_detailSelectScalar = {
    id?: boolean
    invoice_id?: boolean
    service_id?: boolean
    item?: boolean
    quantity?: boolean
    total_value?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
  }

  export type invoice_detailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoice_id" | "service_id" | "item" | "quantity" | "total_value" | "created" | "updated" | "status", ExtArgs["result"]["invoice_detail"]>
  export type invoice_detailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | invoice_detail$invoiceArgs<ExtArgs>
    service?: boolean | invoice_detail$serviceArgs<ExtArgs>
  }
  export type invoice_detailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | invoice_detail$invoiceArgs<ExtArgs>
    service?: boolean | invoice_detail$serviceArgs<ExtArgs>
  }
  export type invoice_detailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | invoice_detail$invoiceArgs<ExtArgs>
    service?: boolean | invoice_detail$serviceArgs<ExtArgs>
  }

  export type $invoice_detailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invoice_detail"
    objects: {
      invoice: Prisma.$invoicePayload<ExtArgs> | null
      service: Prisma.$servicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoice_id: string | null
      service_id: string | null
      item: number | null
      quantity: number | null
      total_value: number | null
      created: Date | null
      updated: Date | null
      status: boolean | null
    }, ExtArgs["result"]["invoice_detail"]>
    composites: {}
  }

  type invoice_detailGetPayload<S extends boolean | null | undefined | invoice_detailDefaultArgs> = $Result.GetResult<Prisma.$invoice_detailPayload, S>

  type invoice_detailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<invoice_detailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Invoice_detailCountAggregateInputType | true
    }

  export interface invoice_detailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invoice_detail'], meta: { name: 'invoice_detail' } }
    /**
     * Find zero or one Invoice_detail that matches the filter.
     * @param {invoice_detailFindUniqueArgs} args - Arguments to find a Invoice_detail
     * @example
     * // Get one Invoice_detail
     * const invoice_detail = await prisma.invoice_detail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invoice_detailFindUniqueArgs>(args: SelectSubset<T, invoice_detailFindUniqueArgs<ExtArgs>>): Prisma__invoice_detailClient<$Result.GetResult<Prisma.$invoice_detailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice_detail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {invoice_detailFindUniqueOrThrowArgs} args - Arguments to find a Invoice_detail
     * @example
     * // Get one Invoice_detail
     * const invoice_detail = await prisma.invoice_detail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invoice_detailFindUniqueOrThrowArgs>(args: SelectSubset<T, invoice_detailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invoice_detailClient<$Result.GetResult<Prisma.$invoice_detailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice_detail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_detailFindFirstArgs} args - Arguments to find a Invoice_detail
     * @example
     * // Get one Invoice_detail
     * const invoice_detail = await prisma.invoice_detail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invoice_detailFindFirstArgs>(args?: SelectSubset<T, invoice_detailFindFirstArgs<ExtArgs>>): Prisma__invoice_detailClient<$Result.GetResult<Prisma.$invoice_detailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice_detail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_detailFindFirstOrThrowArgs} args - Arguments to find a Invoice_detail
     * @example
     * // Get one Invoice_detail
     * const invoice_detail = await prisma.invoice_detail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invoice_detailFindFirstOrThrowArgs>(args?: SelectSubset<T, invoice_detailFindFirstOrThrowArgs<ExtArgs>>): Prisma__invoice_detailClient<$Result.GetResult<Prisma.$invoice_detailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoice_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_detailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoice_details
     * const invoice_details = await prisma.invoice_detail.findMany()
     * 
     * // Get first 10 Invoice_details
     * const invoice_details = await prisma.invoice_detail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoice_detailWithIdOnly = await prisma.invoice_detail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invoice_detailFindManyArgs>(args?: SelectSubset<T, invoice_detailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_detailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice_detail.
     * @param {invoice_detailCreateArgs} args - Arguments to create a Invoice_detail.
     * @example
     * // Create one Invoice_detail
     * const Invoice_detail = await prisma.invoice_detail.create({
     *   data: {
     *     // ... data to create a Invoice_detail
     *   }
     * })
     * 
     */
    create<T extends invoice_detailCreateArgs>(args: SelectSubset<T, invoice_detailCreateArgs<ExtArgs>>): Prisma__invoice_detailClient<$Result.GetResult<Prisma.$invoice_detailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoice_details.
     * @param {invoice_detailCreateManyArgs} args - Arguments to create many Invoice_details.
     * @example
     * // Create many Invoice_details
     * const invoice_detail = await prisma.invoice_detail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invoice_detailCreateManyArgs>(args?: SelectSubset<T, invoice_detailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoice_details and returns the data saved in the database.
     * @param {invoice_detailCreateManyAndReturnArgs} args - Arguments to create many Invoice_details.
     * @example
     * // Create many Invoice_details
     * const invoice_detail = await prisma.invoice_detail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoice_details and only return the `id`
     * const invoice_detailWithIdOnly = await prisma.invoice_detail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends invoice_detailCreateManyAndReturnArgs>(args?: SelectSubset<T, invoice_detailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_detailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice_detail.
     * @param {invoice_detailDeleteArgs} args - Arguments to delete one Invoice_detail.
     * @example
     * // Delete one Invoice_detail
     * const Invoice_detail = await prisma.invoice_detail.delete({
     *   where: {
     *     // ... filter to delete one Invoice_detail
     *   }
     * })
     * 
     */
    delete<T extends invoice_detailDeleteArgs>(args: SelectSubset<T, invoice_detailDeleteArgs<ExtArgs>>): Prisma__invoice_detailClient<$Result.GetResult<Prisma.$invoice_detailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice_detail.
     * @param {invoice_detailUpdateArgs} args - Arguments to update one Invoice_detail.
     * @example
     * // Update one Invoice_detail
     * const invoice_detail = await prisma.invoice_detail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invoice_detailUpdateArgs>(args: SelectSubset<T, invoice_detailUpdateArgs<ExtArgs>>): Prisma__invoice_detailClient<$Result.GetResult<Prisma.$invoice_detailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoice_details.
     * @param {invoice_detailDeleteManyArgs} args - Arguments to filter Invoice_details to delete.
     * @example
     * // Delete a few Invoice_details
     * const { count } = await prisma.invoice_detail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invoice_detailDeleteManyArgs>(args?: SelectSubset<T, invoice_detailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoice_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_detailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoice_details
     * const invoice_detail = await prisma.invoice_detail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invoice_detailUpdateManyArgs>(args: SelectSubset<T, invoice_detailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoice_details and returns the data updated in the database.
     * @param {invoice_detailUpdateManyAndReturnArgs} args - Arguments to update many Invoice_details.
     * @example
     * // Update many Invoice_details
     * const invoice_detail = await prisma.invoice_detail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoice_details and only return the `id`
     * const invoice_detailWithIdOnly = await prisma.invoice_detail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends invoice_detailUpdateManyAndReturnArgs>(args: SelectSubset<T, invoice_detailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_detailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice_detail.
     * @param {invoice_detailUpsertArgs} args - Arguments to update or create a Invoice_detail.
     * @example
     * // Update or create a Invoice_detail
     * const invoice_detail = await prisma.invoice_detail.upsert({
     *   create: {
     *     // ... data to create a Invoice_detail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice_detail we want to update
     *   }
     * })
     */
    upsert<T extends invoice_detailUpsertArgs>(args: SelectSubset<T, invoice_detailUpsertArgs<ExtArgs>>): Prisma__invoice_detailClient<$Result.GetResult<Prisma.$invoice_detailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoice_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_detailCountArgs} args - Arguments to filter Invoice_details to count.
     * @example
     * // Count the number of Invoice_details
     * const count = await prisma.invoice_detail.count({
     *   where: {
     *     // ... the filter for the Invoice_details we want to count
     *   }
     * })
    **/
    count<T extends invoice_detailCountArgs>(
      args?: Subset<T, invoice_detailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Invoice_detailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice_detail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Invoice_detailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Invoice_detailAggregateArgs>(args: Subset<T, Invoice_detailAggregateArgs>): Prisma.PrismaPromise<GetInvoice_detailAggregateType<T>>

    /**
     * Group by Invoice_detail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_detailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invoice_detailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invoice_detailGroupByArgs['orderBy'] }
        : { orderBy?: invoice_detailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invoice_detailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoice_detailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invoice_detail model
   */
  readonly fields: invoice_detailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invoice_detail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invoice_detailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends invoice_detail$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, invoice_detail$invoiceArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    service<T extends invoice_detail$serviceArgs<ExtArgs> = {}>(args?: Subset<T, invoice_detail$serviceArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invoice_detail model
   */
  interface invoice_detailFieldRefs {
    readonly id: FieldRef<"invoice_detail", 'String'>
    readonly invoice_id: FieldRef<"invoice_detail", 'String'>
    readonly service_id: FieldRef<"invoice_detail", 'String'>
    readonly item: FieldRef<"invoice_detail", 'Int'>
    readonly quantity: FieldRef<"invoice_detail", 'Int'>
    readonly total_value: FieldRef<"invoice_detail", 'Float'>
    readonly created: FieldRef<"invoice_detail", 'DateTime'>
    readonly updated: FieldRef<"invoice_detail", 'DateTime'>
    readonly status: FieldRef<"invoice_detail", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * invoice_detail findUnique
   */
  export type invoice_detailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_detail
     */
    select?: invoice_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_detail
     */
    omit?: invoice_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_detailInclude<ExtArgs> | null
    /**
     * Filter, which invoice_detail to fetch.
     */
    where: invoice_detailWhereUniqueInput
  }

  /**
   * invoice_detail findUniqueOrThrow
   */
  export type invoice_detailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_detail
     */
    select?: invoice_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_detail
     */
    omit?: invoice_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_detailInclude<ExtArgs> | null
    /**
     * Filter, which invoice_detail to fetch.
     */
    where: invoice_detailWhereUniqueInput
  }

  /**
   * invoice_detail findFirst
   */
  export type invoice_detailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_detail
     */
    select?: invoice_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_detail
     */
    omit?: invoice_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_detailInclude<ExtArgs> | null
    /**
     * Filter, which invoice_detail to fetch.
     */
    where?: invoice_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoice_details to fetch.
     */
    orderBy?: invoice_detailOrderByWithRelationInput | invoice_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoice_details.
     */
    cursor?: invoice_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoice_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoice_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoice_details.
     */
    distinct?: Invoice_detailScalarFieldEnum | Invoice_detailScalarFieldEnum[]
  }

  /**
   * invoice_detail findFirstOrThrow
   */
  export type invoice_detailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_detail
     */
    select?: invoice_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_detail
     */
    omit?: invoice_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_detailInclude<ExtArgs> | null
    /**
     * Filter, which invoice_detail to fetch.
     */
    where?: invoice_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoice_details to fetch.
     */
    orderBy?: invoice_detailOrderByWithRelationInput | invoice_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoice_details.
     */
    cursor?: invoice_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoice_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoice_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoice_details.
     */
    distinct?: Invoice_detailScalarFieldEnum | Invoice_detailScalarFieldEnum[]
  }

  /**
   * invoice_detail findMany
   */
  export type invoice_detailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_detail
     */
    select?: invoice_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_detail
     */
    omit?: invoice_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_detailInclude<ExtArgs> | null
    /**
     * Filter, which invoice_details to fetch.
     */
    where?: invoice_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoice_details to fetch.
     */
    orderBy?: invoice_detailOrderByWithRelationInput | invoice_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invoice_details.
     */
    cursor?: invoice_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoice_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoice_details.
     */
    skip?: number
    distinct?: Invoice_detailScalarFieldEnum | Invoice_detailScalarFieldEnum[]
  }

  /**
   * invoice_detail create
   */
  export type invoice_detailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_detail
     */
    select?: invoice_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_detail
     */
    omit?: invoice_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_detailInclude<ExtArgs> | null
    /**
     * The data needed to create a invoice_detail.
     */
    data: XOR<invoice_detailCreateInput, invoice_detailUncheckedCreateInput>
  }

  /**
   * invoice_detail createMany
   */
  export type invoice_detailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invoice_details.
     */
    data: invoice_detailCreateManyInput | invoice_detailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invoice_detail createManyAndReturn
   */
  export type invoice_detailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_detail
     */
    select?: invoice_detailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_detail
     */
    omit?: invoice_detailOmit<ExtArgs> | null
    /**
     * The data used to create many invoice_details.
     */
    data: invoice_detailCreateManyInput | invoice_detailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_detailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * invoice_detail update
   */
  export type invoice_detailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_detail
     */
    select?: invoice_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_detail
     */
    omit?: invoice_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_detailInclude<ExtArgs> | null
    /**
     * The data needed to update a invoice_detail.
     */
    data: XOR<invoice_detailUpdateInput, invoice_detailUncheckedUpdateInput>
    /**
     * Choose, which invoice_detail to update.
     */
    where: invoice_detailWhereUniqueInput
  }

  /**
   * invoice_detail updateMany
   */
  export type invoice_detailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invoice_details.
     */
    data: XOR<invoice_detailUpdateManyMutationInput, invoice_detailUncheckedUpdateManyInput>
    /**
     * Filter which invoice_details to update
     */
    where?: invoice_detailWhereInput
    /**
     * Limit how many invoice_details to update.
     */
    limit?: number
  }

  /**
   * invoice_detail updateManyAndReturn
   */
  export type invoice_detailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_detail
     */
    select?: invoice_detailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_detail
     */
    omit?: invoice_detailOmit<ExtArgs> | null
    /**
     * The data used to update invoice_details.
     */
    data: XOR<invoice_detailUpdateManyMutationInput, invoice_detailUncheckedUpdateManyInput>
    /**
     * Filter which invoice_details to update
     */
    where?: invoice_detailWhereInput
    /**
     * Limit how many invoice_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_detailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * invoice_detail upsert
   */
  export type invoice_detailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_detail
     */
    select?: invoice_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_detail
     */
    omit?: invoice_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_detailInclude<ExtArgs> | null
    /**
     * The filter to search for the invoice_detail to update in case it exists.
     */
    where: invoice_detailWhereUniqueInput
    /**
     * In case the invoice_detail found by the `where` argument doesn't exist, create a new invoice_detail with this data.
     */
    create: XOR<invoice_detailCreateInput, invoice_detailUncheckedCreateInput>
    /**
     * In case the invoice_detail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invoice_detailUpdateInput, invoice_detailUncheckedUpdateInput>
  }

  /**
   * invoice_detail delete
   */
  export type invoice_detailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_detail
     */
    select?: invoice_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_detail
     */
    omit?: invoice_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_detailInclude<ExtArgs> | null
    /**
     * Filter which invoice_detail to delete.
     */
    where: invoice_detailWhereUniqueInput
  }

  /**
   * invoice_detail deleteMany
   */
  export type invoice_detailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoice_details to delete
     */
    where?: invoice_detailWhereInput
    /**
     * Limit how many invoice_details to delete.
     */
    limit?: number
  }

  /**
   * invoice_detail.invoice
   */
  export type invoice_detail$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    where?: invoiceWhereInput
  }

  /**
   * invoice_detail.service
   */
  export type invoice_detail$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    where?: serviceWhereInput
  }

  /**
   * invoice_detail without action
   */
  export type invoice_detailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_detail
     */
    select?: invoice_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_detail
     */
    omit?: invoice_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_detailInclude<ExtArgs> | null
  }


  /**
   * Model log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    role_id: string | null
    client_id: string | null
    user_name: string | null
    ip: string | null
    type: string | null
    detail: string | null
    created: Date | null
  }

  export type LogMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    role_id: string | null
    client_id: string | null
    user_name: string | null
    ip: string | null
    type: string | null
    detail: string | null
    created: Date | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    user_id: number
    role_id: number
    client_id: number
    user_name: number
    ip: number
    type: number
    detail: number
    created: number
    _all: number
  }


  export type LogMinAggregateInputType = {
    id?: true
    user_id?: true
    role_id?: true
    client_id?: true
    user_name?: true
    ip?: true
    type?: true
    detail?: true
    created?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    user_id?: true
    role_id?: true
    client_id?: true
    user_name?: true
    ip?: true
    type?: true
    detail?: true
    created?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    user_id?: true
    role_id?: true
    client_id?: true
    user_name?: true
    ip?: true
    type?: true
    detail?: true
    created?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which log to aggregate.
     */
    where?: logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs to fetch.
     */
    orderBy?: logOrderByWithRelationInput | logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: logWhereInput
    orderBy?: logOrderByWithAggregationInput | logOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: string
    user_id: string | null
    role_id: string | null
    client_id: string | null
    user_name: string | null
    ip: string | null
    type: string | null
    detail: string | null
    created: Date | null
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    role_id?: boolean
    client_id?: boolean
    user_name?: boolean
    ip?: boolean
    type?: boolean
    detail?: boolean
    created?: boolean
    client?: boolean | log$clientArgs<ExtArgs>
    role?: boolean | log$roleArgs<ExtArgs>
    user?: boolean | log$userArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type logSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    role_id?: boolean
    client_id?: boolean
    user_name?: boolean
    ip?: boolean
    type?: boolean
    detail?: boolean
    created?: boolean
    client?: boolean | log$clientArgs<ExtArgs>
    role?: boolean | log$roleArgs<ExtArgs>
    user?: boolean | log$userArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type logSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    role_id?: boolean
    client_id?: boolean
    user_name?: boolean
    ip?: boolean
    type?: boolean
    detail?: boolean
    created?: boolean
    client?: boolean | log$clientArgs<ExtArgs>
    role?: boolean | log$roleArgs<ExtArgs>
    user?: boolean | log$userArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type logSelectScalar = {
    id?: boolean
    user_id?: boolean
    role_id?: boolean
    client_id?: boolean
    user_name?: boolean
    ip?: boolean
    type?: boolean
    detail?: boolean
    created?: boolean
  }

  export type logOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "role_id" | "client_id" | "user_name" | "ip" | "type" | "detail" | "created", ExtArgs["result"]["log"]>
  export type logInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | log$clientArgs<ExtArgs>
    role?: boolean | log$roleArgs<ExtArgs>
    user?: boolean | log$userArgs<ExtArgs>
  }
  export type logIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | log$clientArgs<ExtArgs>
    role?: boolean | log$roleArgs<ExtArgs>
    user?: boolean | log$userArgs<ExtArgs>
  }
  export type logIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | log$clientArgs<ExtArgs>
    role?: boolean | log$roleArgs<ExtArgs>
    user?: boolean | log$userArgs<ExtArgs>
  }

  export type $logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "log"
    objects: {
      client: Prisma.$clientPayload<ExtArgs> | null
      role: Prisma.$rolePayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      role_id: string | null
      client_id: string | null
      user_name: string | null
      ip: string | null
      type: string | null
      detail: string | null
      created: Date | null
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type logGetPayload<S extends boolean | null | undefined | logDefaultArgs> = $Result.GetResult<Prisma.$logPayload, S>

  type logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<logFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['log'], meta: { name: 'log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {logFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends logFindUniqueArgs>(args: SelectSubset<T, logFindUniqueArgs<ExtArgs>>): Prisma__logClient<$Result.GetResult<Prisma.$logPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {logFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends logFindUniqueOrThrowArgs>(args: SelectSubset<T, logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__logClient<$Result.GetResult<Prisma.$logPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends logFindFirstArgs>(args?: SelectSubset<T, logFindFirstArgs<ExtArgs>>): Prisma__logClient<$Result.GetResult<Prisma.$logPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends logFindFirstOrThrowArgs>(args?: SelectSubset<T, logFindFirstOrThrowArgs<ExtArgs>>): Prisma__logClient<$Result.GetResult<Prisma.$logPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends logFindManyArgs>(args?: SelectSubset<T, logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Log.
     * @param {logCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends logCreateArgs>(args: SelectSubset<T, logCreateArgs<ExtArgs>>): Prisma__logClient<$Result.GetResult<Prisma.$logPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logs.
     * @param {logCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends logCreateManyArgs>(args?: SelectSubset<T, logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs and returns the data saved in the database.
     * @param {logCreateManyAndReturnArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends logCreateManyAndReturnArgs>(args?: SelectSubset<T, logCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Log.
     * @param {logDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends logDeleteArgs>(args: SelectSubset<T, logDeleteArgs<ExtArgs>>): Prisma__logClient<$Result.GetResult<Prisma.$logPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Log.
     * @param {logUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends logUpdateArgs>(args: SelectSubset<T, logUpdateArgs<ExtArgs>>): Prisma__logClient<$Result.GetResult<Prisma.$logPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logs.
     * @param {logDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends logDeleteManyArgs>(args?: SelectSubset<T, logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends logUpdateManyArgs>(args: SelectSubset<T, logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs and returns the data updated in the database.
     * @param {logUpdateManyAndReturnArgs} args - Arguments to update many Logs.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends logUpdateManyAndReturnArgs>(args: SelectSubset<T, logUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Log.
     * @param {logUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends logUpsertArgs>(args: SelectSubset<T, logUpsertArgs<ExtArgs>>): Prisma__logClient<$Result.GetResult<Prisma.$logPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends logCountArgs>(
      args?: Subset<T, logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: logGroupByArgs['orderBy'] }
        : { orderBy?: logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the log model
   */
  readonly fields: logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends log$clientArgs<ExtArgs> = {}>(args?: Subset<T, log$clientArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    role<T extends log$roleArgs<ExtArgs> = {}>(args?: Subset<T, log$roleArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends log$userArgs<ExtArgs> = {}>(args?: Subset<T, log$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the log model
   */
  interface logFieldRefs {
    readonly id: FieldRef<"log", 'String'>
    readonly user_id: FieldRef<"log", 'String'>
    readonly role_id: FieldRef<"log", 'String'>
    readonly client_id: FieldRef<"log", 'String'>
    readonly user_name: FieldRef<"log", 'String'>
    readonly ip: FieldRef<"log", 'String'>
    readonly type: FieldRef<"log", 'String'>
    readonly detail: FieldRef<"log", 'String'>
    readonly created: FieldRef<"log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * log findUnique
   */
  export type logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the log
     */
    omit?: logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logInclude<ExtArgs> | null
    /**
     * Filter, which log to fetch.
     */
    where: logWhereUniqueInput
  }

  /**
   * log findUniqueOrThrow
   */
  export type logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the log
     */
    omit?: logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logInclude<ExtArgs> | null
    /**
     * Filter, which log to fetch.
     */
    where: logWhereUniqueInput
  }

  /**
   * log findFirst
   */
  export type logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the log
     */
    omit?: logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logInclude<ExtArgs> | null
    /**
     * Filter, which log to fetch.
     */
    where?: logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs to fetch.
     */
    orderBy?: logOrderByWithRelationInput | logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logs.
     */
    cursor?: logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * log findFirstOrThrow
   */
  export type logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the log
     */
    omit?: logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logInclude<ExtArgs> | null
    /**
     * Filter, which log to fetch.
     */
    where?: logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs to fetch.
     */
    orderBy?: logOrderByWithRelationInput | logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logs.
     */
    cursor?: logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * log findMany
   */
  export type logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the log
     */
    omit?: logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logInclude<ExtArgs> | null
    /**
     * Filter, which logs to fetch.
     */
    where?: logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs to fetch.
     */
    orderBy?: logOrderByWithRelationInput | logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing logs.
     */
    cursor?: logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * log create
   */
  export type logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the log
     */
    omit?: logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logInclude<ExtArgs> | null
    /**
     * The data needed to create a log.
     */
    data: XOR<logCreateInput, logUncheckedCreateInput>
  }

  /**
   * log createMany
   */
  export type logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many logs.
     */
    data: logCreateManyInput | logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * log createManyAndReturn
   */
  export type logCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the log
     */
    omit?: logOmit<ExtArgs> | null
    /**
     * The data used to create many logs.
     */
    data: logCreateManyInput | logCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * log update
   */
  export type logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the log
     */
    omit?: logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logInclude<ExtArgs> | null
    /**
     * The data needed to update a log.
     */
    data: XOR<logUpdateInput, logUncheckedUpdateInput>
    /**
     * Choose, which log to update.
     */
    where: logWhereUniqueInput
  }

  /**
   * log updateMany
   */
  export type logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update logs.
     */
    data: XOR<logUpdateManyMutationInput, logUncheckedUpdateManyInput>
    /**
     * Filter which logs to update
     */
    where?: logWhereInput
    /**
     * Limit how many logs to update.
     */
    limit?: number
  }

  /**
   * log updateManyAndReturn
   */
  export type logUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the log
     */
    omit?: logOmit<ExtArgs> | null
    /**
     * The data used to update logs.
     */
    data: XOR<logUpdateManyMutationInput, logUncheckedUpdateManyInput>
    /**
     * Filter which logs to update
     */
    where?: logWhereInput
    /**
     * Limit how many logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * log upsert
   */
  export type logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the log
     */
    omit?: logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logInclude<ExtArgs> | null
    /**
     * The filter to search for the log to update in case it exists.
     */
    where: logWhereUniqueInput
    /**
     * In case the log found by the `where` argument doesn't exist, create a new log with this data.
     */
    create: XOR<logCreateInput, logUncheckedCreateInput>
    /**
     * In case the log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<logUpdateInput, logUncheckedUpdateInput>
  }

  /**
   * log delete
   */
  export type logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the log
     */
    omit?: logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logInclude<ExtArgs> | null
    /**
     * Filter which log to delete.
     */
    where: logWhereUniqueInput
  }

  /**
   * log deleteMany
   */
  export type logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logs to delete
     */
    where?: logWhereInput
    /**
     * Limit how many logs to delete.
     */
    limit?: number
  }

  /**
   * log.client
   */
  export type log$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    where?: clientWhereInput
  }

  /**
   * log.role
   */
  export type log$roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    where?: roleWhereInput
  }

  /**
   * log.user
   */
  export type log$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * log without action
   */
  export type logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the log
     */
    omit?: logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logInclude<ExtArgs> | null
  }


  /**
   * Model payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    client_id: string | null
    code: string | null
    value: string | null
    status_pay: string | null
    method: string | null
    payment_method_id: string | null
    type: string | null
    url: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    client_id: string | null
    code: string | null
    value: string | null
    status_pay: string | null
    method: string | null
    payment_method_id: string | null
    type: string | null
    url: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    client_id: number
    code: number
    value: number
    status_pay: number
    method: number
    payment_method_id: number
    type: number
    url: number
    created: number
    updated: number
    status: number
    _all: number
  }


  export type PaymentMinAggregateInputType = {
    id?: true
    client_id?: true
    code?: true
    value?: true
    status_pay?: true
    method?: true
    payment_method_id?: true
    type?: true
    url?: true
    created?: true
    updated?: true
    status?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    client_id?: true
    code?: true
    value?: true
    status_pay?: true
    method?: true
    payment_method_id?: true
    type?: true
    url?: true
    created?: true
    updated?: true
    status?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    client_id?: true
    code?: true
    value?: true
    status_pay?: true
    method?: true
    payment_method_id?: true
    type?: true
    url?: true
    created?: true
    updated?: true
    status?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment to aggregate.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type paymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithAggregationInput | paymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    client_id: string | null
    code: string | null
    value: string | null
    status_pay: string | null
    method: string | null
    payment_method_id: string | null
    type: string | null
    url: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
    _count: PaymentCountAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends paymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type paymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    code?: boolean
    value?: boolean
    status_pay?: boolean
    method?: boolean
    payment_method_id?: boolean
    type?: boolean
    url?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    client?: boolean | payment$clientArgs<ExtArgs>
    payment_method?: boolean | payment$payment_methodArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type paymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    code?: boolean
    value?: boolean
    status_pay?: boolean
    method?: boolean
    payment_method_id?: boolean
    type?: boolean
    url?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    client?: boolean | payment$clientArgs<ExtArgs>
    payment_method?: boolean | payment$payment_methodArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type paymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    code?: boolean
    value?: boolean
    status_pay?: boolean
    method?: boolean
    payment_method_id?: boolean
    type?: boolean
    url?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    client?: boolean | payment$clientArgs<ExtArgs>
    payment_method?: boolean | payment$payment_methodArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type paymentSelectScalar = {
    id?: boolean
    client_id?: boolean
    code?: boolean
    value?: boolean
    status_pay?: boolean
    method?: boolean
    payment_method_id?: boolean
    type?: boolean
    url?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
  }

  export type paymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "client_id" | "code" | "value" | "status_pay" | "method" | "payment_method_id" | "type" | "url" | "created" | "updated" | "status", ExtArgs["result"]["payment"]>
  export type paymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | payment$clientArgs<ExtArgs>
    payment_method?: boolean | payment$payment_methodArgs<ExtArgs>
  }
  export type paymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | payment$clientArgs<ExtArgs>
    payment_method?: boolean | payment$payment_methodArgs<ExtArgs>
  }
  export type paymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | payment$clientArgs<ExtArgs>
    payment_method?: boolean | payment$payment_methodArgs<ExtArgs>
  }

  export type $paymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment"
    objects: {
      client: Prisma.$clientPayload<ExtArgs> | null
      payment_method: Prisma.$payment_methodPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      client_id: string | null
      code: string | null
      value: string | null
      status_pay: string | null
      method: string | null
      payment_method_id: string | null
      type: string | null
      url: string | null
      created: Date | null
      updated: Date | null
      status: boolean | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type paymentGetPayload<S extends boolean | null | undefined | paymentDefaultArgs> = $Result.GetResult<Prisma.$paymentPayload, S>

  type paymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface paymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment'], meta: { name: 'payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {paymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentFindUniqueArgs>(args: SelectSubset<T, paymentFindUniqueArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentFindFirstArgs>(args?: SelectSubset<T, paymentFindFirstArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentFindManyArgs>(args?: SelectSubset<T, paymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {paymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends paymentCreateArgs>(args: SelectSubset<T, paymentCreateArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentCreateManyArgs>(args?: SelectSubset<T, paymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {paymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends paymentDeleteArgs>(args: SelectSubset<T, paymentDeleteArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {paymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentUpdateArgs>(args: SelectSubset<T, paymentUpdateArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentDeleteManyArgs>(args?: SelectSubset<T, paymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentUpdateManyArgs>(args: SelectSubset<T, paymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {paymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymentUpdateManyAndReturnArgs>(args: SelectSubset<T, paymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {paymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends paymentUpsertArgs>(args: SelectSubset<T, paymentUpsertArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentCountArgs>(
      args?: Subset<T, paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentGroupByArgs['orderBy'] }
        : { orderBy?: paymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment model
   */
  readonly fields: paymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends payment$clientArgs<ExtArgs> = {}>(args?: Subset<T, payment$clientArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payment_method<T extends payment$payment_methodArgs<ExtArgs> = {}>(args?: Subset<T, payment$payment_methodArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment model
   */
  interface paymentFieldRefs {
    readonly id: FieldRef<"payment", 'String'>
    readonly client_id: FieldRef<"payment", 'String'>
    readonly code: FieldRef<"payment", 'String'>
    readonly value: FieldRef<"payment", 'String'>
    readonly status_pay: FieldRef<"payment", 'String'>
    readonly method: FieldRef<"payment", 'String'>
    readonly payment_method_id: FieldRef<"payment", 'String'>
    readonly type: FieldRef<"payment", 'String'>
    readonly url: FieldRef<"payment", 'String'>
    readonly created: FieldRef<"payment", 'DateTime'>
    readonly updated: FieldRef<"payment", 'DateTime'>
    readonly status: FieldRef<"payment", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * payment findUnique
   */
  export type paymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findUniqueOrThrow
   */
  export type paymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findFirst
   */
  export type paymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment findFirstOrThrow
   */
  export type paymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment findMany
   */
  export type paymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment create
   */
  export type paymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The data needed to create a payment.
     */
    data: XOR<paymentCreateInput, paymentUncheckedCreateInput>
  }

  /**
   * payment createMany
   */
  export type paymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentCreateManyInput | paymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment createManyAndReturn
   */
  export type paymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentCreateManyInput | paymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment update
   */
  export type paymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The data needed to update a payment.
     */
    data: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
    /**
     * Choose, which payment to update.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment updateMany
   */
  export type paymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payment updateManyAndReturn
   */
  export type paymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * The data used to update payments.
     */
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment upsert
   */
  export type paymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The filter to search for the payment to update in case it exists.
     */
    where: paymentWhereUniqueInput
    /**
     * In case the payment found by the `where` argument doesn't exist, create a new payment with this data.
     */
    create: XOR<paymentCreateInput, paymentUncheckedCreateInput>
    /**
     * In case the payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
  }

  /**
   * payment delete
   */
  export type paymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter which payment to delete.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment deleteMany
   */
  export type paymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payment.client
   */
  export type payment$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    where?: clientWhereInput
  }

  /**
   * payment.payment_method
   */
  export type payment$payment_methodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    where?: payment_methodWhereInput
  }

  /**
   * payment without action
   */
  export type paymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
  }


  /**
   * Model payment_attachment
   */

  export type AggregatePayment_attachment = {
    _count: Payment_attachmentCountAggregateOutputType | null
    _min: Payment_attachmentMinAggregateOutputType | null
    _max: Payment_attachmentMaxAggregateOutputType | null
  }

  export type Payment_attachmentMinAggregateOutputType = {
    id: string | null
    invoice_id: string | null
  }

  export type Payment_attachmentMaxAggregateOutputType = {
    id: string | null
    invoice_id: string | null
  }

  export type Payment_attachmentCountAggregateOutputType = {
    id: number
    invoice_id: number
    _all: number
  }


  export type Payment_attachmentMinAggregateInputType = {
    id?: true
    invoice_id?: true
  }

  export type Payment_attachmentMaxAggregateInputType = {
    id?: true
    invoice_id?: true
  }

  export type Payment_attachmentCountAggregateInputType = {
    id?: true
    invoice_id?: true
    _all?: true
  }

  export type Payment_attachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_attachment to aggregate.
     */
    where?: payment_attachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_attachments to fetch.
     */
    orderBy?: payment_attachmentOrderByWithRelationInput | payment_attachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_attachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_attachments
    **/
    _count?: true | Payment_attachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_attachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_attachmentMaxAggregateInputType
  }

  export type GetPayment_attachmentAggregateType<T extends Payment_attachmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_attachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_attachment[P]>
      : GetScalarType<T[P], AggregatePayment_attachment[P]>
  }




  export type payment_attachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_attachmentWhereInput
    orderBy?: payment_attachmentOrderByWithAggregationInput | payment_attachmentOrderByWithAggregationInput[]
    by: Payment_attachmentScalarFieldEnum[] | Payment_attachmentScalarFieldEnum
    having?: payment_attachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_attachmentCountAggregateInputType | true
    _min?: Payment_attachmentMinAggregateInputType
    _max?: Payment_attachmentMaxAggregateInputType
  }

  export type Payment_attachmentGroupByOutputType = {
    id: string
    invoice_id: string | null
    _count: Payment_attachmentCountAggregateOutputType | null
    _min: Payment_attachmentMinAggregateOutputType | null
    _max: Payment_attachmentMaxAggregateOutputType | null
  }

  type GetPayment_attachmentGroupByPayload<T extends payment_attachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_attachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_attachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_attachmentGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_attachmentGroupByOutputType[P]>
        }
      >
    >


  export type payment_attachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    invoice?: boolean | payment_attachment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment_attachment"]>

  export type payment_attachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    invoice?: boolean | payment_attachment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment_attachment"]>

  export type payment_attachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    invoice?: boolean | payment_attachment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment_attachment"]>

  export type payment_attachmentSelectScalar = {
    id?: boolean
    invoice_id?: boolean
  }

  export type payment_attachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoice_id", ExtArgs["result"]["payment_attachment"]>
  export type payment_attachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | payment_attachment$invoiceArgs<ExtArgs>
  }
  export type payment_attachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | payment_attachment$invoiceArgs<ExtArgs>
  }
  export type payment_attachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | payment_attachment$invoiceArgs<ExtArgs>
  }

  export type $payment_attachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_attachment"
    objects: {
      invoice: Prisma.$invoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoice_id: string | null
    }, ExtArgs["result"]["payment_attachment"]>
    composites: {}
  }

  type payment_attachmentGetPayload<S extends boolean | null | undefined | payment_attachmentDefaultArgs> = $Result.GetResult<Prisma.$payment_attachmentPayload, S>

  type payment_attachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payment_attachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Payment_attachmentCountAggregateInputType | true
    }

  export interface payment_attachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_attachment'], meta: { name: 'payment_attachment' } }
    /**
     * Find zero or one Payment_attachment that matches the filter.
     * @param {payment_attachmentFindUniqueArgs} args - Arguments to find a Payment_attachment
     * @example
     * // Get one Payment_attachment
     * const payment_attachment = await prisma.payment_attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_attachmentFindUniqueArgs>(args: SelectSubset<T, payment_attachmentFindUniqueArgs<ExtArgs>>): Prisma__payment_attachmentClient<$Result.GetResult<Prisma.$payment_attachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment_attachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_attachmentFindUniqueOrThrowArgs} args - Arguments to find a Payment_attachment
     * @example
     * // Get one Payment_attachment
     * const payment_attachment = await prisma.payment_attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_attachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_attachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_attachmentClient<$Result.GetResult<Prisma.$payment_attachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_attachmentFindFirstArgs} args - Arguments to find a Payment_attachment
     * @example
     * // Get one Payment_attachment
     * const payment_attachment = await prisma.payment_attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_attachmentFindFirstArgs>(args?: SelectSubset<T, payment_attachmentFindFirstArgs<ExtArgs>>): Prisma__payment_attachmentClient<$Result.GetResult<Prisma.$payment_attachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_attachmentFindFirstOrThrowArgs} args - Arguments to find a Payment_attachment
     * @example
     * // Get one Payment_attachment
     * const payment_attachment = await prisma.payment_attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_attachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_attachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_attachmentClient<$Result.GetResult<Prisma.$payment_attachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payment_attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_attachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_attachments
     * const payment_attachments = await prisma.payment_attachment.findMany()
     * 
     * // Get first 10 Payment_attachments
     * const payment_attachments = await prisma.payment_attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payment_attachmentWithIdOnly = await prisma.payment_attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends payment_attachmentFindManyArgs>(args?: SelectSubset<T, payment_attachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_attachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment_attachment.
     * @param {payment_attachmentCreateArgs} args - Arguments to create a Payment_attachment.
     * @example
     * // Create one Payment_attachment
     * const Payment_attachment = await prisma.payment_attachment.create({
     *   data: {
     *     // ... data to create a Payment_attachment
     *   }
     * })
     * 
     */
    create<T extends payment_attachmentCreateArgs>(args: SelectSubset<T, payment_attachmentCreateArgs<ExtArgs>>): Prisma__payment_attachmentClient<$Result.GetResult<Prisma.$payment_attachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payment_attachments.
     * @param {payment_attachmentCreateManyArgs} args - Arguments to create many Payment_attachments.
     * @example
     * // Create many Payment_attachments
     * const payment_attachment = await prisma.payment_attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_attachmentCreateManyArgs>(args?: SelectSubset<T, payment_attachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_attachments and returns the data saved in the database.
     * @param {payment_attachmentCreateManyAndReturnArgs} args - Arguments to create many Payment_attachments.
     * @example
     * // Create many Payment_attachments
     * const payment_attachment = await prisma.payment_attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_attachments and only return the `id`
     * const payment_attachmentWithIdOnly = await prisma.payment_attachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_attachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_attachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_attachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment_attachment.
     * @param {payment_attachmentDeleteArgs} args - Arguments to delete one Payment_attachment.
     * @example
     * // Delete one Payment_attachment
     * const Payment_attachment = await prisma.payment_attachment.delete({
     *   where: {
     *     // ... filter to delete one Payment_attachment
     *   }
     * })
     * 
     */
    delete<T extends payment_attachmentDeleteArgs>(args: SelectSubset<T, payment_attachmentDeleteArgs<ExtArgs>>): Prisma__payment_attachmentClient<$Result.GetResult<Prisma.$payment_attachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment_attachment.
     * @param {payment_attachmentUpdateArgs} args - Arguments to update one Payment_attachment.
     * @example
     * // Update one Payment_attachment
     * const payment_attachment = await prisma.payment_attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_attachmentUpdateArgs>(args: SelectSubset<T, payment_attachmentUpdateArgs<ExtArgs>>): Prisma__payment_attachmentClient<$Result.GetResult<Prisma.$payment_attachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payment_attachments.
     * @param {payment_attachmentDeleteManyArgs} args - Arguments to filter Payment_attachments to delete.
     * @example
     * // Delete a few Payment_attachments
     * const { count } = await prisma.payment_attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_attachmentDeleteManyArgs>(args?: SelectSubset<T, payment_attachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_attachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_attachments
     * const payment_attachment = await prisma.payment_attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_attachmentUpdateManyArgs>(args: SelectSubset<T, payment_attachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_attachments and returns the data updated in the database.
     * @param {payment_attachmentUpdateManyAndReturnArgs} args - Arguments to update many Payment_attachments.
     * @example
     * // Update many Payment_attachments
     * const payment_attachment = await prisma.payment_attachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payment_attachments and only return the `id`
     * const payment_attachmentWithIdOnly = await prisma.payment_attachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends payment_attachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, payment_attachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_attachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment_attachment.
     * @param {payment_attachmentUpsertArgs} args - Arguments to update or create a Payment_attachment.
     * @example
     * // Update or create a Payment_attachment
     * const payment_attachment = await prisma.payment_attachment.upsert({
     *   create: {
     *     // ... data to create a Payment_attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_attachment we want to update
     *   }
     * })
     */
    upsert<T extends payment_attachmentUpsertArgs>(args: SelectSubset<T, payment_attachmentUpsertArgs<ExtArgs>>): Prisma__payment_attachmentClient<$Result.GetResult<Prisma.$payment_attachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payment_attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_attachmentCountArgs} args - Arguments to filter Payment_attachments to count.
     * @example
     * // Count the number of Payment_attachments
     * const count = await prisma.payment_attachment.count({
     *   where: {
     *     // ... the filter for the Payment_attachments we want to count
     *   }
     * })
    **/
    count<T extends payment_attachmentCountArgs>(
      args?: Subset<T, payment_attachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_attachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_attachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_attachmentAggregateArgs>(args: Subset<T, Payment_attachmentAggregateArgs>): Prisma.PrismaPromise<GetPayment_attachmentAggregateType<T>>

    /**
     * Group by Payment_attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_attachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_attachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_attachmentGroupByArgs['orderBy'] }
        : { orderBy?: payment_attachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_attachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_attachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_attachment model
   */
  readonly fields: payment_attachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_attachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends payment_attachment$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, payment_attachment$invoiceArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_attachment model
   */
  interface payment_attachmentFieldRefs {
    readonly id: FieldRef<"payment_attachment", 'String'>
    readonly invoice_id: FieldRef<"payment_attachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payment_attachment findUnique
   */
  export type payment_attachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_attachment
     */
    select?: payment_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_attachment
     */
    omit?: payment_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_attachmentInclude<ExtArgs> | null
    /**
     * Filter, which payment_attachment to fetch.
     */
    where: payment_attachmentWhereUniqueInput
  }

  /**
   * payment_attachment findUniqueOrThrow
   */
  export type payment_attachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_attachment
     */
    select?: payment_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_attachment
     */
    omit?: payment_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_attachmentInclude<ExtArgs> | null
    /**
     * Filter, which payment_attachment to fetch.
     */
    where: payment_attachmentWhereUniqueInput
  }

  /**
   * payment_attachment findFirst
   */
  export type payment_attachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_attachment
     */
    select?: payment_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_attachment
     */
    omit?: payment_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_attachmentInclude<ExtArgs> | null
    /**
     * Filter, which payment_attachment to fetch.
     */
    where?: payment_attachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_attachments to fetch.
     */
    orderBy?: payment_attachmentOrderByWithRelationInput | payment_attachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_attachments.
     */
    cursor?: payment_attachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_attachments.
     */
    distinct?: Payment_attachmentScalarFieldEnum | Payment_attachmentScalarFieldEnum[]
  }

  /**
   * payment_attachment findFirstOrThrow
   */
  export type payment_attachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_attachment
     */
    select?: payment_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_attachment
     */
    omit?: payment_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_attachmentInclude<ExtArgs> | null
    /**
     * Filter, which payment_attachment to fetch.
     */
    where?: payment_attachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_attachments to fetch.
     */
    orderBy?: payment_attachmentOrderByWithRelationInput | payment_attachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_attachments.
     */
    cursor?: payment_attachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_attachments.
     */
    distinct?: Payment_attachmentScalarFieldEnum | Payment_attachmentScalarFieldEnum[]
  }

  /**
   * payment_attachment findMany
   */
  export type payment_attachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_attachment
     */
    select?: payment_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_attachment
     */
    omit?: payment_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_attachmentInclude<ExtArgs> | null
    /**
     * Filter, which payment_attachments to fetch.
     */
    where?: payment_attachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_attachments to fetch.
     */
    orderBy?: payment_attachmentOrderByWithRelationInput | payment_attachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_attachments.
     */
    cursor?: payment_attachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_attachments.
     */
    skip?: number
    distinct?: Payment_attachmentScalarFieldEnum | Payment_attachmentScalarFieldEnum[]
  }

  /**
   * payment_attachment create
   */
  export type payment_attachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_attachment
     */
    select?: payment_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_attachment
     */
    omit?: payment_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_attachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_attachment.
     */
    data: XOR<payment_attachmentCreateInput, payment_attachmentUncheckedCreateInput>
  }

  /**
   * payment_attachment createMany
   */
  export type payment_attachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_attachments.
     */
    data: payment_attachmentCreateManyInput | payment_attachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_attachment createManyAndReturn
   */
  export type payment_attachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_attachment
     */
    select?: payment_attachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_attachment
     */
    omit?: payment_attachmentOmit<ExtArgs> | null
    /**
     * The data used to create many payment_attachments.
     */
    data: payment_attachmentCreateManyInput | payment_attachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_attachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_attachment update
   */
  export type payment_attachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_attachment
     */
    select?: payment_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_attachment
     */
    omit?: payment_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_attachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_attachment.
     */
    data: XOR<payment_attachmentUpdateInput, payment_attachmentUncheckedUpdateInput>
    /**
     * Choose, which payment_attachment to update.
     */
    where: payment_attachmentWhereUniqueInput
  }

  /**
   * payment_attachment updateMany
   */
  export type payment_attachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_attachments.
     */
    data: XOR<payment_attachmentUpdateManyMutationInput, payment_attachmentUncheckedUpdateManyInput>
    /**
     * Filter which payment_attachments to update
     */
    where?: payment_attachmentWhereInput
    /**
     * Limit how many payment_attachments to update.
     */
    limit?: number
  }

  /**
   * payment_attachment updateManyAndReturn
   */
  export type payment_attachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_attachment
     */
    select?: payment_attachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_attachment
     */
    omit?: payment_attachmentOmit<ExtArgs> | null
    /**
     * The data used to update payment_attachments.
     */
    data: XOR<payment_attachmentUpdateManyMutationInput, payment_attachmentUncheckedUpdateManyInput>
    /**
     * Filter which payment_attachments to update
     */
    where?: payment_attachmentWhereInput
    /**
     * Limit how many payment_attachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_attachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_attachment upsert
   */
  export type payment_attachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_attachment
     */
    select?: payment_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_attachment
     */
    omit?: payment_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_attachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_attachment to update in case it exists.
     */
    where: payment_attachmentWhereUniqueInput
    /**
     * In case the payment_attachment found by the `where` argument doesn't exist, create a new payment_attachment with this data.
     */
    create: XOR<payment_attachmentCreateInput, payment_attachmentUncheckedCreateInput>
    /**
     * In case the payment_attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_attachmentUpdateInput, payment_attachmentUncheckedUpdateInput>
  }

  /**
   * payment_attachment delete
   */
  export type payment_attachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_attachment
     */
    select?: payment_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_attachment
     */
    omit?: payment_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_attachmentInclude<ExtArgs> | null
    /**
     * Filter which payment_attachment to delete.
     */
    where: payment_attachmentWhereUniqueInput
  }

  /**
   * payment_attachment deleteMany
   */
  export type payment_attachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_attachments to delete
     */
    where?: payment_attachmentWhereInput
    /**
     * Limit how many payment_attachments to delete.
     */
    limit?: number
  }

  /**
   * payment_attachment.invoice
   */
  export type payment_attachment$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    where?: invoiceWhereInput
  }

  /**
   * payment_attachment without action
   */
  export type payment_attachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_attachment
     */
    select?: payment_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_attachment
     */
    omit?: payment_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_attachmentInclude<ExtArgs> | null
  }


  /**
   * Model payment_method
   */

  export type AggregatePayment_method = {
    _count: Payment_methodCountAggregateOutputType | null
    _min: Payment_methodMinAggregateOutputType | null
    _max: Payment_methodMaxAggregateOutputType | null
  }

  export type Payment_methodMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type Payment_methodMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type Payment_methodCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Payment_methodMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Payment_methodMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Payment_methodCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Payment_methodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_method to aggregate.
     */
    where?: payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodOrderByWithRelationInput | payment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_methods
    **/
    _count?: true | Payment_methodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_methodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_methodMaxAggregateInputType
  }

  export type GetPayment_methodAggregateType<T extends Payment_methodAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_method]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_method[P]>
      : GetScalarType<T[P], AggregatePayment_method[P]>
  }




  export type payment_methodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_methodWhereInput
    orderBy?: payment_methodOrderByWithAggregationInput | payment_methodOrderByWithAggregationInput[]
    by: Payment_methodScalarFieldEnum[] | Payment_methodScalarFieldEnum
    having?: payment_methodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_methodCountAggregateInputType | true
    _min?: Payment_methodMinAggregateInputType
    _max?: Payment_methodMaxAggregateInputType
  }

  export type Payment_methodGroupByOutputType = {
    id: string
    name: string | null
    _count: Payment_methodCountAggregateOutputType | null
    _min: Payment_methodMinAggregateOutputType | null
    _max: Payment_methodMaxAggregateOutputType | null
  }

  type GetPayment_methodGroupByPayload<T extends payment_methodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_methodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_methodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_methodGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_methodGroupByOutputType[P]>
        }
      >
    >


  export type payment_methodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    payment?: boolean | payment_method$paymentArgs<ExtArgs>
    _count?: boolean | Payment_methodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_method"]>

  export type payment_methodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["payment_method"]>

  export type payment_methodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["payment_method"]>

  export type payment_methodSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type payment_methodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["payment_method"]>
  export type payment_methodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | payment_method$paymentArgs<ExtArgs>
    _count?: boolean | Payment_methodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type payment_methodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type payment_methodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $payment_methodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_method"
    objects: {
      payment: Prisma.$paymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
    }, ExtArgs["result"]["payment_method"]>
    composites: {}
  }

  type payment_methodGetPayload<S extends boolean | null | undefined | payment_methodDefaultArgs> = $Result.GetResult<Prisma.$payment_methodPayload, S>

  type payment_methodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payment_methodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Payment_methodCountAggregateInputType | true
    }

  export interface payment_methodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_method'], meta: { name: 'payment_method' } }
    /**
     * Find zero or one Payment_method that matches the filter.
     * @param {payment_methodFindUniqueArgs} args - Arguments to find a Payment_method
     * @example
     * // Get one Payment_method
     * const payment_method = await prisma.payment_method.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_methodFindUniqueArgs>(args: SelectSubset<T, payment_methodFindUniqueArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment_method that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_methodFindUniqueOrThrowArgs} args - Arguments to find a Payment_method
     * @example
     * // Get one Payment_method
     * const payment_method = await prisma.payment_method.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_methodFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_methodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_method that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodFindFirstArgs} args - Arguments to find a Payment_method
     * @example
     * // Get one Payment_method
     * const payment_method = await prisma.payment_method.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_methodFindFirstArgs>(args?: SelectSubset<T, payment_methodFindFirstArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_method that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodFindFirstOrThrowArgs} args - Arguments to find a Payment_method
     * @example
     * // Get one Payment_method
     * const payment_method = await prisma.payment_method.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_methodFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_methodFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_methods
     * const payment_methods = await prisma.payment_method.findMany()
     * 
     * // Get first 10 Payment_methods
     * const payment_methods = await prisma.payment_method.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payment_methodWithIdOnly = await prisma.payment_method.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends payment_methodFindManyArgs>(args?: SelectSubset<T, payment_methodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment_method.
     * @param {payment_methodCreateArgs} args - Arguments to create a Payment_method.
     * @example
     * // Create one Payment_method
     * const Payment_method = await prisma.payment_method.create({
     *   data: {
     *     // ... data to create a Payment_method
     *   }
     * })
     * 
     */
    create<T extends payment_methodCreateArgs>(args: SelectSubset<T, payment_methodCreateArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payment_methods.
     * @param {payment_methodCreateManyArgs} args - Arguments to create many Payment_methods.
     * @example
     * // Create many Payment_methods
     * const payment_method = await prisma.payment_method.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_methodCreateManyArgs>(args?: SelectSubset<T, payment_methodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_methods and returns the data saved in the database.
     * @param {payment_methodCreateManyAndReturnArgs} args - Arguments to create many Payment_methods.
     * @example
     * // Create many Payment_methods
     * const payment_method = await prisma.payment_method.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_methods and only return the `id`
     * const payment_methodWithIdOnly = await prisma.payment_method.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_methodCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_methodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment_method.
     * @param {payment_methodDeleteArgs} args - Arguments to delete one Payment_method.
     * @example
     * // Delete one Payment_method
     * const Payment_method = await prisma.payment_method.delete({
     *   where: {
     *     // ... filter to delete one Payment_method
     *   }
     * })
     * 
     */
    delete<T extends payment_methodDeleteArgs>(args: SelectSubset<T, payment_methodDeleteArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment_method.
     * @param {payment_methodUpdateArgs} args - Arguments to update one Payment_method.
     * @example
     * // Update one Payment_method
     * const payment_method = await prisma.payment_method.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_methodUpdateArgs>(args: SelectSubset<T, payment_methodUpdateArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payment_methods.
     * @param {payment_methodDeleteManyArgs} args - Arguments to filter Payment_methods to delete.
     * @example
     * // Delete a few Payment_methods
     * const { count } = await prisma.payment_method.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_methodDeleteManyArgs>(args?: SelectSubset<T, payment_methodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_methods
     * const payment_method = await prisma.payment_method.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_methodUpdateManyArgs>(args: SelectSubset<T, payment_methodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_methods and returns the data updated in the database.
     * @param {payment_methodUpdateManyAndReturnArgs} args - Arguments to update many Payment_methods.
     * @example
     * // Update many Payment_methods
     * const payment_method = await prisma.payment_method.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payment_methods and only return the `id`
     * const payment_methodWithIdOnly = await prisma.payment_method.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends payment_methodUpdateManyAndReturnArgs>(args: SelectSubset<T, payment_methodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment_method.
     * @param {payment_methodUpsertArgs} args - Arguments to update or create a Payment_method.
     * @example
     * // Update or create a Payment_method
     * const payment_method = await prisma.payment_method.upsert({
     *   create: {
     *     // ... data to create a Payment_method
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_method we want to update
     *   }
     * })
     */
    upsert<T extends payment_methodUpsertArgs>(args: SelectSubset<T, payment_methodUpsertArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodCountArgs} args - Arguments to filter Payment_methods to count.
     * @example
     * // Count the number of Payment_methods
     * const count = await prisma.payment_method.count({
     *   where: {
     *     // ... the filter for the Payment_methods we want to count
     *   }
     * })
    **/
    count<T extends payment_methodCountArgs>(
      args?: Subset<T, payment_methodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_methodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_methodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_methodAggregateArgs>(args: Subset<T, Payment_methodAggregateArgs>): Prisma.PrismaPromise<GetPayment_methodAggregateType<T>>

    /**
     * Group by Payment_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_methodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_methodGroupByArgs['orderBy'] }
        : { orderBy?: payment_methodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_methodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_methodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_method model
   */
  readonly fields: payment_methodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_method.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_methodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends payment_method$paymentArgs<ExtArgs> = {}>(args?: Subset<T, payment_method$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_method model
   */
  interface payment_methodFieldRefs {
    readonly id: FieldRef<"payment_method", 'String'>
    readonly name: FieldRef<"payment_method", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payment_method findUnique
   */
  export type payment_methodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which payment_method to fetch.
     */
    where: payment_methodWhereUniqueInput
  }

  /**
   * payment_method findUniqueOrThrow
   */
  export type payment_methodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which payment_method to fetch.
     */
    where: payment_methodWhereUniqueInput
  }

  /**
   * payment_method findFirst
   */
  export type payment_methodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which payment_method to fetch.
     */
    where?: payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodOrderByWithRelationInput | payment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_methods.
     */
    cursor?: payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_methods.
     */
    distinct?: Payment_methodScalarFieldEnum | Payment_methodScalarFieldEnum[]
  }

  /**
   * payment_method findFirstOrThrow
   */
  export type payment_methodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which payment_method to fetch.
     */
    where?: payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodOrderByWithRelationInput | payment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_methods.
     */
    cursor?: payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_methods.
     */
    distinct?: Payment_methodScalarFieldEnum | Payment_methodScalarFieldEnum[]
  }

  /**
   * payment_method findMany
   */
  export type payment_methodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which payment_methods to fetch.
     */
    where?: payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodOrderByWithRelationInput | payment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_methods.
     */
    cursor?: payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    distinct?: Payment_methodScalarFieldEnum | Payment_methodScalarFieldEnum[]
  }

  /**
   * payment_method create
   */
  export type payment_methodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_method.
     */
    data: XOR<payment_methodCreateInput, payment_methodUncheckedCreateInput>
  }

  /**
   * payment_method createMany
   */
  export type payment_methodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_methods.
     */
    data: payment_methodCreateManyInput | payment_methodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_method createManyAndReturn
   */
  export type payment_methodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * The data used to create many payment_methods.
     */
    data: payment_methodCreateManyInput | payment_methodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_method update
   */
  export type payment_methodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_method.
     */
    data: XOR<payment_methodUpdateInput, payment_methodUncheckedUpdateInput>
    /**
     * Choose, which payment_method to update.
     */
    where: payment_methodWhereUniqueInput
  }

  /**
   * payment_method updateMany
   */
  export type payment_methodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_methods.
     */
    data: XOR<payment_methodUpdateManyMutationInput, payment_methodUncheckedUpdateManyInput>
    /**
     * Filter which payment_methods to update
     */
    where?: payment_methodWhereInput
    /**
     * Limit how many payment_methods to update.
     */
    limit?: number
  }

  /**
   * payment_method updateManyAndReturn
   */
  export type payment_methodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * The data used to update payment_methods.
     */
    data: XOR<payment_methodUpdateManyMutationInput, payment_methodUncheckedUpdateManyInput>
    /**
     * Filter which payment_methods to update
     */
    where?: payment_methodWhereInput
    /**
     * Limit how many payment_methods to update.
     */
    limit?: number
  }

  /**
   * payment_method upsert
   */
  export type payment_methodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_method to update in case it exists.
     */
    where: payment_methodWhereUniqueInput
    /**
     * In case the payment_method found by the `where` argument doesn't exist, create a new payment_method with this data.
     */
    create: XOR<payment_methodCreateInput, payment_methodUncheckedCreateInput>
    /**
     * In case the payment_method was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_methodUpdateInput, payment_methodUncheckedUpdateInput>
  }

  /**
   * payment_method delete
   */
  export type payment_methodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter which payment_method to delete.
     */
    where: payment_methodWhereUniqueInput
  }

  /**
   * payment_method deleteMany
   */
  export type payment_methodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_methods to delete
     */
    where?: payment_methodWhereInput
    /**
     * Limit how many payment_methods to delete.
     */
    limit?: number
  }

  /**
   * payment_method.payment
   */
  export type payment_method$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment_method without action
   */
  export type payment_methodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
  }


  /**
   * Model permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    section: string | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    section: string | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    section: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    section?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    section?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    section?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permission to aggregate.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type permissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissionWhereInput
    orderBy?: permissionOrderByWithAggregationInput | permissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: permissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    name: string | null
    section: string | null
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends permissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type permissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    section?: boolean
    role_permission?: boolean | permission$role_permissionArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type permissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    section?: boolean
  }, ExtArgs["result"]["permission"]>

  export type permissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    section?: boolean
  }, ExtArgs["result"]["permission"]>

  export type permissionSelectScalar = {
    id?: boolean
    name?: boolean
    section?: boolean
  }

  export type permissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "section", ExtArgs["result"]["permission"]>
  export type permissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role_permission?: boolean | permission$role_permissionArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type permissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type permissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $permissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permission"
    objects: {
      role_permission: Prisma.$role_permissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      section: string | null
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type permissionGetPayload<S extends boolean | null | undefined | permissionDefaultArgs> = $Result.GetResult<Prisma.$permissionPayload, S>

  type permissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<permissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface permissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permission'], meta: { name: 'permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {permissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permissionFindUniqueArgs>(args: SelectSubset<T, permissionFindUniqueArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {permissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permissionFindUniqueOrThrowArgs>(args: SelectSubset<T, permissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permissionFindFirstArgs>(args?: SelectSubset<T, permissionFindFirstArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permissionFindFirstOrThrowArgs>(args?: SelectSubset<T, permissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends permissionFindManyArgs>(args?: SelectSubset<T, permissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {permissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends permissionCreateArgs>(args: SelectSubset<T, permissionCreateArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {permissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends permissionCreateManyArgs>(args?: SelectSubset<T, permissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {permissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends permissionCreateManyAndReturnArgs>(args?: SelectSubset<T, permissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {permissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends permissionDeleteArgs>(args: SelectSubset<T, permissionDeleteArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {permissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends permissionUpdateArgs>(args: SelectSubset<T, permissionUpdateArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {permissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends permissionDeleteManyArgs>(args?: SelectSubset<T, permissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends permissionUpdateManyArgs>(args: SelectSubset<T, permissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {permissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends permissionUpdateManyAndReturnArgs>(args: SelectSubset<T, permissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {permissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends permissionUpsertArgs>(args: SelectSubset<T, permissionUpsertArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends permissionCountArgs>(
      args?: Subset<T, permissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissionGroupByArgs['orderBy'] }
        : { orderBy?: permissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permission model
   */
  readonly fields: permissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role_permission<T extends permission$role_permissionArgs<ExtArgs> = {}>(args?: Subset<T, permission$role_permissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_permissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the permission model
   */
  interface permissionFieldRefs {
    readonly id: FieldRef<"permission", 'String'>
    readonly name: FieldRef<"permission", 'String'>
    readonly section: FieldRef<"permission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * permission findUnique
   */
  export type permissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission findUniqueOrThrow
   */
  export type permissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission findFirst
   */
  export type permissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * permission findFirstOrThrow
   */
  export type permissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * permission findMany
   */
  export type permissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * permission create
   */
  export type permissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The data needed to create a permission.
     */
    data: XOR<permissionCreateInput, permissionUncheckedCreateInput>
  }

  /**
   * permission createMany
   */
  export type permissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissions.
     */
    data: permissionCreateManyInput | permissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permission createManyAndReturn
   */
  export type permissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * The data used to create many permissions.
     */
    data: permissionCreateManyInput | permissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permission update
   */
  export type permissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The data needed to update a permission.
     */
    data: XOR<permissionUpdateInput, permissionUncheckedUpdateInput>
    /**
     * Choose, which permission to update.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission updateMany
   */
  export type permissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionUpdateManyMutationInput, permissionUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionWhereInput
    /**
     * Limit how many permissions to update.
     */
    limit?: number
  }

  /**
   * permission updateManyAndReturn
   */
  export type permissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionUpdateManyMutationInput, permissionUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionWhereInput
    /**
     * Limit how many permissions to update.
     */
    limit?: number
  }

  /**
   * permission upsert
   */
  export type permissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The filter to search for the permission to update in case it exists.
     */
    where: permissionWhereUniqueInput
    /**
     * In case the permission found by the `where` argument doesn't exist, create a new permission with this data.
     */
    create: XOR<permissionCreateInput, permissionUncheckedCreateInput>
    /**
     * In case the permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissionUpdateInput, permissionUncheckedUpdateInput>
  }

  /**
   * permission delete
   */
  export type permissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter which permission to delete.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission deleteMany
   */
  export type permissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to delete
     */
    where?: permissionWhereInput
    /**
     * Limit how many permissions to delete.
     */
    limit?: number
  }

  /**
   * permission.role_permission
   */
  export type permission$role_permissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permission
     */
    select?: role_permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permission
     */
    omit?: role_permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionInclude<ExtArgs> | null
    where?: role_permissionWhereInput
    orderBy?: role_permissionOrderByWithRelationInput | role_permissionOrderByWithRelationInput[]
    cursor?: role_permissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Role_permissionScalarFieldEnum | Role_permissionScalarFieldEnum[]
  }

  /**
   * permission without action
   */
  export type permissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
  }


  /**
   * Model quote
   */

  export type AggregateQuote = {
    _count: QuoteCountAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  export type QuoteMinAggregateOutputType = {
    id: string | null
    client_id: string | null
    description: string | null
    value: string | null
    url: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
  }

  export type QuoteMaxAggregateOutputType = {
    id: string | null
    client_id: string | null
    description: string | null
    value: string | null
    url: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
  }

  export type QuoteCountAggregateOutputType = {
    id: number
    client_id: number
    description: number
    value: number
    url: number
    created: number
    updated: number
    status: number
    _all: number
  }


  export type QuoteMinAggregateInputType = {
    id?: true
    client_id?: true
    description?: true
    value?: true
    url?: true
    created?: true
    updated?: true
    status?: true
  }

  export type QuoteMaxAggregateInputType = {
    id?: true
    client_id?: true
    description?: true
    value?: true
    url?: true
    created?: true
    updated?: true
    status?: true
  }

  export type QuoteCountAggregateInputType = {
    id?: true
    client_id?: true
    description?: true
    value?: true
    url?: true
    created?: true
    updated?: true
    status?: true
    _all?: true
  }

  export type QuoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quote to aggregate.
     */
    where?: quoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quotes to fetch.
     */
    orderBy?: quoteOrderByWithRelationInput | quoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: quoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quotes
    **/
    _count?: true | QuoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteMaxAggregateInputType
  }

  export type GetQuoteAggregateType<T extends QuoteAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote[P]>
      : GetScalarType<T[P], AggregateQuote[P]>
  }




  export type quoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quoteWhereInput
    orderBy?: quoteOrderByWithAggregationInput | quoteOrderByWithAggregationInput[]
    by: QuoteScalarFieldEnum[] | QuoteScalarFieldEnum
    having?: quoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteCountAggregateInputType | true
    _min?: QuoteMinAggregateInputType
    _max?: QuoteMaxAggregateInputType
  }

  export type QuoteGroupByOutputType = {
    id: string
    client_id: string | null
    description: string | null
    value: string | null
    url: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
    _count: QuoteCountAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  type GetQuoteGroupByPayload<T extends quoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteGroupByOutputType[P]>
        }
      >
    >


  export type quoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    description?: boolean
    value?: boolean
    url?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    client?: boolean | quote$clientArgs<ExtArgs>
    quote_attachment?: boolean | quote$quote_attachmentArgs<ExtArgs>
    quote_detail?: boolean | quote$quote_detailArgs<ExtArgs>
    _count?: boolean | QuoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type quoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    description?: boolean
    value?: boolean
    url?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    client?: boolean | quote$clientArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type quoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    description?: boolean
    value?: boolean
    url?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    client?: boolean | quote$clientArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type quoteSelectScalar = {
    id?: boolean
    client_id?: boolean
    description?: boolean
    value?: boolean
    url?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
  }

  export type quoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "client_id" | "description" | "value" | "url" | "created" | "updated" | "status", ExtArgs["result"]["quote"]>
  export type quoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | quote$clientArgs<ExtArgs>
    quote_attachment?: boolean | quote$quote_attachmentArgs<ExtArgs>
    quote_detail?: boolean | quote$quote_detailArgs<ExtArgs>
    _count?: boolean | QuoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type quoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | quote$clientArgs<ExtArgs>
  }
  export type quoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | quote$clientArgs<ExtArgs>
  }

  export type $quotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "quote"
    objects: {
      client: Prisma.$clientPayload<ExtArgs> | null
      quote_attachment: Prisma.$quote_attachmentPayload<ExtArgs>[]
      quote_detail: Prisma.$quote_detailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      client_id: string | null
      description: string | null
      value: string | null
      url: string | null
      created: Date | null
      updated: Date | null
      status: boolean | null
    }, ExtArgs["result"]["quote"]>
    composites: {}
  }

  type quoteGetPayload<S extends boolean | null | undefined | quoteDefaultArgs> = $Result.GetResult<Prisma.$quotePayload, S>

  type quoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<quoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuoteCountAggregateInputType | true
    }

  export interface quoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['quote'], meta: { name: 'quote' } }
    /**
     * Find zero or one Quote that matches the filter.
     * @param {quoteFindUniqueArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends quoteFindUniqueArgs>(args: SelectSubset<T, quoteFindUniqueArgs<ExtArgs>>): Prisma__quoteClient<$Result.GetResult<Prisma.$quotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {quoteFindUniqueOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends quoteFindUniqueOrThrowArgs>(args: SelectSubset<T, quoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__quoteClient<$Result.GetResult<Prisma.$quotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quoteFindFirstArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends quoteFindFirstArgs>(args?: SelectSubset<T, quoteFindFirstArgs<ExtArgs>>): Prisma__quoteClient<$Result.GetResult<Prisma.$quotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quoteFindFirstOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends quoteFindFirstOrThrowArgs>(args?: SelectSubset<T, quoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__quoteClient<$Result.GetResult<Prisma.$quotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quote.findMany()
     * 
     * // Get first 10 Quotes
     * const quotes = await prisma.quote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteWithIdOnly = await prisma.quote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends quoteFindManyArgs>(args?: SelectSubset<T, quoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quote.
     * @param {quoteCreateArgs} args - Arguments to create a Quote.
     * @example
     * // Create one Quote
     * const Quote = await prisma.quote.create({
     *   data: {
     *     // ... data to create a Quote
     *   }
     * })
     * 
     */
    create<T extends quoteCreateArgs>(args: SelectSubset<T, quoteCreateArgs<ExtArgs>>): Prisma__quoteClient<$Result.GetResult<Prisma.$quotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quotes.
     * @param {quoteCreateManyArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends quoteCreateManyArgs>(args?: SelectSubset<T, quoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotes and returns the data saved in the database.
     * @param {quoteCreateManyAndReturnArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends quoteCreateManyAndReturnArgs>(args?: SelectSubset<T, quoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quote.
     * @param {quoteDeleteArgs} args - Arguments to delete one Quote.
     * @example
     * // Delete one Quote
     * const Quote = await prisma.quote.delete({
     *   where: {
     *     // ... filter to delete one Quote
     *   }
     * })
     * 
     */
    delete<T extends quoteDeleteArgs>(args: SelectSubset<T, quoteDeleteArgs<ExtArgs>>): Prisma__quoteClient<$Result.GetResult<Prisma.$quotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quote.
     * @param {quoteUpdateArgs} args - Arguments to update one Quote.
     * @example
     * // Update one Quote
     * const quote = await prisma.quote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends quoteUpdateArgs>(args: SelectSubset<T, quoteUpdateArgs<ExtArgs>>): Prisma__quoteClient<$Result.GetResult<Prisma.$quotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quotes.
     * @param {quoteDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends quoteDeleteManyArgs>(args?: SelectSubset<T, quoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends quoteUpdateManyArgs>(args: SelectSubset<T, quoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes and returns the data updated in the database.
     * @param {quoteUpdateManyAndReturnArgs} args - Arguments to update many Quotes.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends quoteUpdateManyAndReturnArgs>(args: SelectSubset<T, quoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quote.
     * @param {quoteUpsertArgs} args - Arguments to update or create a Quote.
     * @example
     * // Update or create a Quote
     * const quote = await prisma.quote.upsert({
     *   create: {
     *     // ... data to create a Quote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote we want to update
     *   }
     * })
     */
    upsert<T extends quoteUpsertArgs>(args: SelectSubset<T, quoteUpsertArgs<ExtArgs>>): Prisma__quoteClient<$Result.GetResult<Prisma.$quotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quoteCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quote.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
    **/
    count<T extends quoteCountArgs>(
      args?: Subset<T, quoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteAggregateArgs>(args: Subset<T, QuoteAggregateArgs>): Prisma.PrismaPromise<GetQuoteAggregateType<T>>

    /**
     * Group by Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends quoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: quoteGroupByArgs['orderBy'] }
        : { orderBy?: quoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, quoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the quote model
   */
  readonly fields: quoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for quote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__quoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends quote$clientArgs<ExtArgs> = {}>(args?: Subset<T, quote$clientArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quote_attachment<T extends quote$quote_attachmentArgs<ExtArgs> = {}>(args?: Subset<T, quote$quote_attachmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_attachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quote_detail<T extends quote$quote_detailArgs<ExtArgs> = {}>(args?: Subset<T, quote$quote_detailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_detailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the quote model
   */
  interface quoteFieldRefs {
    readonly id: FieldRef<"quote", 'String'>
    readonly client_id: FieldRef<"quote", 'String'>
    readonly description: FieldRef<"quote", 'String'>
    readonly value: FieldRef<"quote", 'String'>
    readonly url: FieldRef<"quote", 'String'>
    readonly created: FieldRef<"quote", 'DateTime'>
    readonly updated: FieldRef<"quote", 'DateTime'>
    readonly status: FieldRef<"quote", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * quote findUnique
   */
  export type quoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote
     */
    select?: quoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote
     */
    omit?: quoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quoteInclude<ExtArgs> | null
    /**
     * Filter, which quote to fetch.
     */
    where: quoteWhereUniqueInput
  }

  /**
   * quote findUniqueOrThrow
   */
  export type quoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote
     */
    select?: quoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote
     */
    omit?: quoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quoteInclude<ExtArgs> | null
    /**
     * Filter, which quote to fetch.
     */
    where: quoteWhereUniqueInput
  }

  /**
   * quote findFirst
   */
  export type quoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote
     */
    select?: quoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote
     */
    omit?: quoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quoteInclude<ExtArgs> | null
    /**
     * Filter, which quote to fetch.
     */
    where?: quoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quotes to fetch.
     */
    orderBy?: quoteOrderByWithRelationInput | quoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quotes.
     */
    cursor?: quoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * quote findFirstOrThrow
   */
  export type quoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote
     */
    select?: quoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote
     */
    omit?: quoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quoteInclude<ExtArgs> | null
    /**
     * Filter, which quote to fetch.
     */
    where?: quoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quotes to fetch.
     */
    orderBy?: quoteOrderByWithRelationInput | quoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quotes.
     */
    cursor?: quoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * quote findMany
   */
  export type quoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote
     */
    select?: quoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote
     */
    omit?: quoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quoteInclude<ExtArgs> | null
    /**
     * Filter, which quotes to fetch.
     */
    where?: quoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quotes to fetch.
     */
    orderBy?: quoteOrderByWithRelationInput | quoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quotes.
     */
    cursor?: quoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quotes.
     */
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * quote create
   */
  export type quoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote
     */
    select?: quoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote
     */
    omit?: quoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quoteInclude<ExtArgs> | null
    /**
     * The data needed to create a quote.
     */
    data: XOR<quoteCreateInput, quoteUncheckedCreateInput>
  }

  /**
   * quote createMany
   */
  export type quoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many quotes.
     */
    data: quoteCreateManyInput | quoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * quote createManyAndReturn
   */
  export type quoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote
     */
    select?: quoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the quote
     */
    omit?: quoteOmit<ExtArgs> | null
    /**
     * The data used to create many quotes.
     */
    data: quoteCreateManyInput | quoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * quote update
   */
  export type quoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote
     */
    select?: quoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote
     */
    omit?: quoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quoteInclude<ExtArgs> | null
    /**
     * The data needed to update a quote.
     */
    data: XOR<quoteUpdateInput, quoteUncheckedUpdateInput>
    /**
     * Choose, which quote to update.
     */
    where: quoteWhereUniqueInput
  }

  /**
   * quote updateMany
   */
  export type quoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update quotes.
     */
    data: XOR<quoteUpdateManyMutationInput, quoteUncheckedUpdateManyInput>
    /**
     * Filter which quotes to update
     */
    where?: quoteWhereInput
    /**
     * Limit how many quotes to update.
     */
    limit?: number
  }

  /**
   * quote updateManyAndReturn
   */
  export type quoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote
     */
    select?: quoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the quote
     */
    omit?: quoteOmit<ExtArgs> | null
    /**
     * The data used to update quotes.
     */
    data: XOR<quoteUpdateManyMutationInput, quoteUncheckedUpdateManyInput>
    /**
     * Filter which quotes to update
     */
    where?: quoteWhereInput
    /**
     * Limit how many quotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * quote upsert
   */
  export type quoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote
     */
    select?: quoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote
     */
    omit?: quoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quoteInclude<ExtArgs> | null
    /**
     * The filter to search for the quote to update in case it exists.
     */
    where: quoteWhereUniqueInput
    /**
     * In case the quote found by the `where` argument doesn't exist, create a new quote with this data.
     */
    create: XOR<quoteCreateInput, quoteUncheckedCreateInput>
    /**
     * In case the quote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<quoteUpdateInput, quoteUncheckedUpdateInput>
  }

  /**
   * quote delete
   */
  export type quoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote
     */
    select?: quoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote
     */
    omit?: quoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quoteInclude<ExtArgs> | null
    /**
     * Filter which quote to delete.
     */
    where: quoteWhereUniqueInput
  }

  /**
   * quote deleteMany
   */
  export type quoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quotes to delete
     */
    where?: quoteWhereInput
    /**
     * Limit how many quotes to delete.
     */
    limit?: number
  }

  /**
   * quote.client
   */
  export type quote$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    where?: clientWhereInput
  }

  /**
   * quote.quote_attachment
   */
  export type quote$quote_attachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_attachment
     */
    select?: quote_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_attachment
     */
    omit?: quote_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_attachmentInclude<ExtArgs> | null
    where?: quote_attachmentWhereInput
    orderBy?: quote_attachmentOrderByWithRelationInput | quote_attachmentOrderByWithRelationInput[]
    cursor?: quote_attachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Quote_attachmentScalarFieldEnum | Quote_attachmentScalarFieldEnum[]
  }

  /**
   * quote.quote_detail
   */
  export type quote$quote_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_detail
     */
    select?: quote_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_detail
     */
    omit?: quote_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_detailInclude<ExtArgs> | null
    where?: quote_detailWhereInput
    orderBy?: quote_detailOrderByWithRelationInput | quote_detailOrderByWithRelationInput[]
    cursor?: quote_detailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Quote_detailScalarFieldEnum | Quote_detailScalarFieldEnum[]
  }

  /**
   * quote without action
   */
  export type quoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote
     */
    select?: quoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote
     */
    omit?: quoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quoteInclude<ExtArgs> | null
  }


  /**
   * Model quote_attachment
   */

  export type AggregateQuote_attachment = {
    _count: Quote_attachmentCountAggregateOutputType | null
    _min: Quote_attachmentMinAggregateOutputType | null
    _max: Quote_attachmentMaxAggregateOutputType | null
  }

  export type Quote_attachmentMinAggregateOutputType = {
    id: string | null
    quote_id: string | null
    invoice_id: string | null
  }

  export type Quote_attachmentMaxAggregateOutputType = {
    id: string | null
    quote_id: string | null
    invoice_id: string | null
  }

  export type Quote_attachmentCountAggregateOutputType = {
    id: number
    quote_id: number
    invoice_id: number
    _all: number
  }


  export type Quote_attachmentMinAggregateInputType = {
    id?: true
    quote_id?: true
    invoice_id?: true
  }

  export type Quote_attachmentMaxAggregateInputType = {
    id?: true
    quote_id?: true
    invoice_id?: true
  }

  export type Quote_attachmentCountAggregateInputType = {
    id?: true
    quote_id?: true
    invoice_id?: true
    _all?: true
  }

  export type Quote_attachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quote_attachment to aggregate.
     */
    where?: quote_attachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_attachments to fetch.
     */
    orderBy?: quote_attachmentOrderByWithRelationInput | quote_attachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: quote_attachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quote_attachments
    **/
    _count?: true | Quote_attachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Quote_attachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Quote_attachmentMaxAggregateInputType
  }

  export type GetQuote_attachmentAggregateType<T extends Quote_attachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote_attachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote_attachment[P]>
      : GetScalarType<T[P], AggregateQuote_attachment[P]>
  }




  export type quote_attachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quote_attachmentWhereInput
    orderBy?: quote_attachmentOrderByWithAggregationInput | quote_attachmentOrderByWithAggregationInput[]
    by: Quote_attachmentScalarFieldEnum[] | Quote_attachmentScalarFieldEnum
    having?: quote_attachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Quote_attachmentCountAggregateInputType | true
    _min?: Quote_attachmentMinAggregateInputType
    _max?: Quote_attachmentMaxAggregateInputType
  }

  export type Quote_attachmentGroupByOutputType = {
    id: string
    quote_id: string | null
    invoice_id: string | null
    _count: Quote_attachmentCountAggregateOutputType | null
    _min: Quote_attachmentMinAggregateOutputType | null
    _max: Quote_attachmentMaxAggregateOutputType | null
  }

  type GetQuote_attachmentGroupByPayload<T extends quote_attachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Quote_attachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Quote_attachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Quote_attachmentGroupByOutputType[P]>
            : GetScalarType<T[P], Quote_attachmentGroupByOutputType[P]>
        }
      >
    >


  export type quote_attachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quote_id?: boolean
    invoice_id?: boolean
    invoice?: boolean | quote_attachment$invoiceArgs<ExtArgs>
    quote?: boolean | quote_attachment$quoteArgs<ExtArgs>
  }, ExtArgs["result"]["quote_attachment"]>

  export type quote_attachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quote_id?: boolean
    invoice_id?: boolean
    invoice?: boolean | quote_attachment$invoiceArgs<ExtArgs>
    quote?: boolean | quote_attachment$quoteArgs<ExtArgs>
  }, ExtArgs["result"]["quote_attachment"]>

  export type quote_attachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quote_id?: boolean
    invoice_id?: boolean
    invoice?: boolean | quote_attachment$invoiceArgs<ExtArgs>
    quote?: boolean | quote_attachment$quoteArgs<ExtArgs>
  }, ExtArgs["result"]["quote_attachment"]>

  export type quote_attachmentSelectScalar = {
    id?: boolean
    quote_id?: boolean
    invoice_id?: boolean
  }

  export type quote_attachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quote_id" | "invoice_id", ExtArgs["result"]["quote_attachment"]>
  export type quote_attachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | quote_attachment$invoiceArgs<ExtArgs>
    quote?: boolean | quote_attachment$quoteArgs<ExtArgs>
  }
  export type quote_attachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | quote_attachment$invoiceArgs<ExtArgs>
    quote?: boolean | quote_attachment$quoteArgs<ExtArgs>
  }
  export type quote_attachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | quote_attachment$invoiceArgs<ExtArgs>
    quote?: boolean | quote_attachment$quoteArgs<ExtArgs>
  }

  export type $quote_attachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "quote_attachment"
    objects: {
      invoice: Prisma.$invoicePayload<ExtArgs> | null
      quote: Prisma.$quotePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quote_id: string | null
      invoice_id: string | null
    }, ExtArgs["result"]["quote_attachment"]>
    composites: {}
  }

  type quote_attachmentGetPayload<S extends boolean | null | undefined | quote_attachmentDefaultArgs> = $Result.GetResult<Prisma.$quote_attachmentPayload, S>

  type quote_attachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<quote_attachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Quote_attachmentCountAggregateInputType | true
    }

  export interface quote_attachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['quote_attachment'], meta: { name: 'quote_attachment' } }
    /**
     * Find zero or one Quote_attachment that matches the filter.
     * @param {quote_attachmentFindUniqueArgs} args - Arguments to find a Quote_attachment
     * @example
     * // Get one Quote_attachment
     * const quote_attachment = await prisma.quote_attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends quote_attachmentFindUniqueArgs>(args: SelectSubset<T, quote_attachmentFindUniqueArgs<ExtArgs>>): Prisma__quote_attachmentClient<$Result.GetResult<Prisma.$quote_attachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quote_attachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {quote_attachmentFindUniqueOrThrowArgs} args - Arguments to find a Quote_attachment
     * @example
     * // Get one Quote_attachment
     * const quote_attachment = await prisma.quote_attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends quote_attachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, quote_attachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__quote_attachmentClient<$Result.GetResult<Prisma.$quote_attachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote_attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_attachmentFindFirstArgs} args - Arguments to find a Quote_attachment
     * @example
     * // Get one Quote_attachment
     * const quote_attachment = await prisma.quote_attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends quote_attachmentFindFirstArgs>(args?: SelectSubset<T, quote_attachmentFindFirstArgs<ExtArgs>>): Prisma__quote_attachmentClient<$Result.GetResult<Prisma.$quote_attachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote_attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_attachmentFindFirstOrThrowArgs} args - Arguments to find a Quote_attachment
     * @example
     * // Get one Quote_attachment
     * const quote_attachment = await prisma.quote_attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends quote_attachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, quote_attachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__quote_attachmentClient<$Result.GetResult<Prisma.$quote_attachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quote_attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_attachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quote_attachments
     * const quote_attachments = await prisma.quote_attachment.findMany()
     * 
     * // Get first 10 Quote_attachments
     * const quote_attachments = await prisma.quote_attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quote_attachmentWithIdOnly = await prisma.quote_attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends quote_attachmentFindManyArgs>(args?: SelectSubset<T, quote_attachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_attachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quote_attachment.
     * @param {quote_attachmentCreateArgs} args - Arguments to create a Quote_attachment.
     * @example
     * // Create one Quote_attachment
     * const Quote_attachment = await prisma.quote_attachment.create({
     *   data: {
     *     // ... data to create a Quote_attachment
     *   }
     * })
     * 
     */
    create<T extends quote_attachmentCreateArgs>(args: SelectSubset<T, quote_attachmentCreateArgs<ExtArgs>>): Prisma__quote_attachmentClient<$Result.GetResult<Prisma.$quote_attachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quote_attachments.
     * @param {quote_attachmentCreateManyArgs} args - Arguments to create many Quote_attachments.
     * @example
     * // Create many Quote_attachments
     * const quote_attachment = await prisma.quote_attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends quote_attachmentCreateManyArgs>(args?: SelectSubset<T, quote_attachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quote_attachments and returns the data saved in the database.
     * @param {quote_attachmentCreateManyAndReturnArgs} args - Arguments to create many Quote_attachments.
     * @example
     * // Create many Quote_attachments
     * const quote_attachment = await prisma.quote_attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quote_attachments and only return the `id`
     * const quote_attachmentWithIdOnly = await prisma.quote_attachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends quote_attachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, quote_attachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_attachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quote_attachment.
     * @param {quote_attachmentDeleteArgs} args - Arguments to delete one Quote_attachment.
     * @example
     * // Delete one Quote_attachment
     * const Quote_attachment = await prisma.quote_attachment.delete({
     *   where: {
     *     // ... filter to delete one Quote_attachment
     *   }
     * })
     * 
     */
    delete<T extends quote_attachmentDeleteArgs>(args: SelectSubset<T, quote_attachmentDeleteArgs<ExtArgs>>): Prisma__quote_attachmentClient<$Result.GetResult<Prisma.$quote_attachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quote_attachment.
     * @param {quote_attachmentUpdateArgs} args - Arguments to update one Quote_attachment.
     * @example
     * // Update one Quote_attachment
     * const quote_attachment = await prisma.quote_attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends quote_attachmentUpdateArgs>(args: SelectSubset<T, quote_attachmentUpdateArgs<ExtArgs>>): Prisma__quote_attachmentClient<$Result.GetResult<Prisma.$quote_attachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quote_attachments.
     * @param {quote_attachmentDeleteManyArgs} args - Arguments to filter Quote_attachments to delete.
     * @example
     * // Delete a few Quote_attachments
     * const { count } = await prisma.quote_attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends quote_attachmentDeleteManyArgs>(args?: SelectSubset<T, quote_attachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quote_attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_attachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quote_attachments
     * const quote_attachment = await prisma.quote_attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends quote_attachmentUpdateManyArgs>(args: SelectSubset<T, quote_attachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quote_attachments and returns the data updated in the database.
     * @param {quote_attachmentUpdateManyAndReturnArgs} args - Arguments to update many Quote_attachments.
     * @example
     * // Update many Quote_attachments
     * const quote_attachment = await prisma.quote_attachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quote_attachments and only return the `id`
     * const quote_attachmentWithIdOnly = await prisma.quote_attachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends quote_attachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, quote_attachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_attachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quote_attachment.
     * @param {quote_attachmentUpsertArgs} args - Arguments to update or create a Quote_attachment.
     * @example
     * // Update or create a Quote_attachment
     * const quote_attachment = await prisma.quote_attachment.upsert({
     *   create: {
     *     // ... data to create a Quote_attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote_attachment we want to update
     *   }
     * })
     */
    upsert<T extends quote_attachmentUpsertArgs>(args: SelectSubset<T, quote_attachmentUpsertArgs<ExtArgs>>): Prisma__quote_attachmentClient<$Result.GetResult<Prisma.$quote_attachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quote_attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_attachmentCountArgs} args - Arguments to filter Quote_attachments to count.
     * @example
     * // Count the number of Quote_attachments
     * const count = await prisma.quote_attachment.count({
     *   where: {
     *     // ... the filter for the Quote_attachments we want to count
     *   }
     * })
    **/
    count<T extends quote_attachmentCountArgs>(
      args?: Subset<T, quote_attachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Quote_attachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote_attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Quote_attachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Quote_attachmentAggregateArgs>(args: Subset<T, Quote_attachmentAggregateArgs>): Prisma.PrismaPromise<GetQuote_attachmentAggregateType<T>>

    /**
     * Group by Quote_attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_attachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends quote_attachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: quote_attachmentGroupByArgs['orderBy'] }
        : { orderBy?: quote_attachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, quote_attachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuote_attachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the quote_attachment model
   */
  readonly fields: quote_attachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for quote_attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__quote_attachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends quote_attachment$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, quote_attachment$invoiceArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quote<T extends quote_attachment$quoteArgs<ExtArgs> = {}>(args?: Subset<T, quote_attachment$quoteArgs<ExtArgs>>): Prisma__quoteClient<$Result.GetResult<Prisma.$quotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the quote_attachment model
   */
  interface quote_attachmentFieldRefs {
    readonly id: FieldRef<"quote_attachment", 'String'>
    readonly quote_id: FieldRef<"quote_attachment", 'String'>
    readonly invoice_id: FieldRef<"quote_attachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * quote_attachment findUnique
   */
  export type quote_attachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_attachment
     */
    select?: quote_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_attachment
     */
    omit?: quote_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_attachmentInclude<ExtArgs> | null
    /**
     * Filter, which quote_attachment to fetch.
     */
    where: quote_attachmentWhereUniqueInput
  }

  /**
   * quote_attachment findUniqueOrThrow
   */
  export type quote_attachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_attachment
     */
    select?: quote_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_attachment
     */
    omit?: quote_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_attachmentInclude<ExtArgs> | null
    /**
     * Filter, which quote_attachment to fetch.
     */
    where: quote_attachmentWhereUniqueInput
  }

  /**
   * quote_attachment findFirst
   */
  export type quote_attachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_attachment
     */
    select?: quote_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_attachment
     */
    omit?: quote_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_attachmentInclude<ExtArgs> | null
    /**
     * Filter, which quote_attachment to fetch.
     */
    where?: quote_attachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_attachments to fetch.
     */
    orderBy?: quote_attachmentOrderByWithRelationInput | quote_attachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quote_attachments.
     */
    cursor?: quote_attachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quote_attachments.
     */
    distinct?: Quote_attachmentScalarFieldEnum | Quote_attachmentScalarFieldEnum[]
  }

  /**
   * quote_attachment findFirstOrThrow
   */
  export type quote_attachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_attachment
     */
    select?: quote_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_attachment
     */
    omit?: quote_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_attachmentInclude<ExtArgs> | null
    /**
     * Filter, which quote_attachment to fetch.
     */
    where?: quote_attachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_attachments to fetch.
     */
    orderBy?: quote_attachmentOrderByWithRelationInput | quote_attachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quote_attachments.
     */
    cursor?: quote_attachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quote_attachments.
     */
    distinct?: Quote_attachmentScalarFieldEnum | Quote_attachmentScalarFieldEnum[]
  }

  /**
   * quote_attachment findMany
   */
  export type quote_attachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_attachment
     */
    select?: quote_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_attachment
     */
    omit?: quote_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_attachmentInclude<ExtArgs> | null
    /**
     * Filter, which quote_attachments to fetch.
     */
    where?: quote_attachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_attachments to fetch.
     */
    orderBy?: quote_attachmentOrderByWithRelationInput | quote_attachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quote_attachments.
     */
    cursor?: quote_attachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_attachments.
     */
    skip?: number
    distinct?: Quote_attachmentScalarFieldEnum | Quote_attachmentScalarFieldEnum[]
  }

  /**
   * quote_attachment create
   */
  export type quote_attachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_attachment
     */
    select?: quote_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_attachment
     */
    omit?: quote_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_attachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a quote_attachment.
     */
    data: XOR<quote_attachmentCreateInput, quote_attachmentUncheckedCreateInput>
  }

  /**
   * quote_attachment createMany
   */
  export type quote_attachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many quote_attachments.
     */
    data: quote_attachmentCreateManyInput | quote_attachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * quote_attachment createManyAndReturn
   */
  export type quote_attachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_attachment
     */
    select?: quote_attachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the quote_attachment
     */
    omit?: quote_attachmentOmit<ExtArgs> | null
    /**
     * The data used to create many quote_attachments.
     */
    data: quote_attachmentCreateManyInput | quote_attachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_attachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * quote_attachment update
   */
  export type quote_attachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_attachment
     */
    select?: quote_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_attachment
     */
    omit?: quote_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_attachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a quote_attachment.
     */
    data: XOR<quote_attachmentUpdateInput, quote_attachmentUncheckedUpdateInput>
    /**
     * Choose, which quote_attachment to update.
     */
    where: quote_attachmentWhereUniqueInput
  }

  /**
   * quote_attachment updateMany
   */
  export type quote_attachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update quote_attachments.
     */
    data: XOR<quote_attachmentUpdateManyMutationInput, quote_attachmentUncheckedUpdateManyInput>
    /**
     * Filter which quote_attachments to update
     */
    where?: quote_attachmentWhereInput
    /**
     * Limit how many quote_attachments to update.
     */
    limit?: number
  }

  /**
   * quote_attachment updateManyAndReturn
   */
  export type quote_attachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_attachment
     */
    select?: quote_attachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the quote_attachment
     */
    omit?: quote_attachmentOmit<ExtArgs> | null
    /**
     * The data used to update quote_attachments.
     */
    data: XOR<quote_attachmentUpdateManyMutationInput, quote_attachmentUncheckedUpdateManyInput>
    /**
     * Filter which quote_attachments to update
     */
    where?: quote_attachmentWhereInput
    /**
     * Limit how many quote_attachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_attachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * quote_attachment upsert
   */
  export type quote_attachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_attachment
     */
    select?: quote_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_attachment
     */
    omit?: quote_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_attachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the quote_attachment to update in case it exists.
     */
    where: quote_attachmentWhereUniqueInput
    /**
     * In case the quote_attachment found by the `where` argument doesn't exist, create a new quote_attachment with this data.
     */
    create: XOR<quote_attachmentCreateInput, quote_attachmentUncheckedCreateInput>
    /**
     * In case the quote_attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<quote_attachmentUpdateInput, quote_attachmentUncheckedUpdateInput>
  }

  /**
   * quote_attachment delete
   */
  export type quote_attachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_attachment
     */
    select?: quote_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_attachment
     */
    omit?: quote_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_attachmentInclude<ExtArgs> | null
    /**
     * Filter which quote_attachment to delete.
     */
    where: quote_attachmentWhereUniqueInput
  }

  /**
   * quote_attachment deleteMany
   */
  export type quote_attachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quote_attachments to delete
     */
    where?: quote_attachmentWhereInput
    /**
     * Limit how many quote_attachments to delete.
     */
    limit?: number
  }

  /**
   * quote_attachment.invoice
   */
  export type quote_attachment$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    where?: invoiceWhereInput
  }

  /**
   * quote_attachment.quote
   */
  export type quote_attachment$quoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote
     */
    select?: quoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote
     */
    omit?: quoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quoteInclude<ExtArgs> | null
    where?: quoteWhereInput
  }

  /**
   * quote_attachment without action
   */
  export type quote_attachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_attachment
     */
    select?: quote_attachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_attachment
     */
    omit?: quote_attachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_attachmentInclude<ExtArgs> | null
  }


  /**
   * Model quote_detail
   */

  export type AggregateQuote_detail = {
    _count: Quote_detailCountAggregateOutputType | null
    _avg: Quote_detailAvgAggregateOutputType | null
    _sum: Quote_detailSumAggregateOutputType | null
    _min: Quote_detailMinAggregateOutputType | null
    _max: Quote_detailMaxAggregateOutputType | null
  }

  export type Quote_detailAvgAggregateOutputType = {
    item: number | null
    quantity: number | null
    total_value: number | null
  }

  export type Quote_detailSumAggregateOutputType = {
    item: number | null
    quantity: number | null
    total_value: number | null
  }

  export type Quote_detailMinAggregateOutputType = {
    id: string | null
    quote_id: string | null
    service_id: string | null
    item: number | null
    quantity: number | null
    total_value: number | null
    created: Date | null
    updated: Date | null
    status: boolean | null
  }

  export type Quote_detailMaxAggregateOutputType = {
    id: string | null
    quote_id: string | null
    service_id: string | null
    item: number | null
    quantity: number | null
    total_value: number | null
    created: Date | null
    updated: Date | null
    status: boolean | null
  }

  export type Quote_detailCountAggregateOutputType = {
    id: number
    quote_id: number
    service_id: number
    item: number
    quantity: number
    total_value: number
    created: number
    updated: number
    status: number
    _all: number
  }


  export type Quote_detailAvgAggregateInputType = {
    item?: true
    quantity?: true
    total_value?: true
  }

  export type Quote_detailSumAggregateInputType = {
    item?: true
    quantity?: true
    total_value?: true
  }

  export type Quote_detailMinAggregateInputType = {
    id?: true
    quote_id?: true
    service_id?: true
    item?: true
    quantity?: true
    total_value?: true
    created?: true
    updated?: true
    status?: true
  }

  export type Quote_detailMaxAggregateInputType = {
    id?: true
    quote_id?: true
    service_id?: true
    item?: true
    quantity?: true
    total_value?: true
    created?: true
    updated?: true
    status?: true
  }

  export type Quote_detailCountAggregateInputType = {
    id?: true
    quote_id?: true
    service_id?: true
    item?: true
    quantity?: true
    total_value?: true
    created?: true
    updated?: true
    status?: true
    _all?: true
  }

  export type Quote_detailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quote_detail to aggregate.
     */
    where?: quote_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_details to fetch.
     */
    orderBy?: quote_detailOrderByWithRelationInput | quote_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: quote_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quote_details
    **/
    _count?: true | Quote_detailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Quote_detailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Quote_detailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Quote_detailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Quote_detailMaxAggregateInputType
  }

  export type GetQuote_detailAggregateType<T extends Quote_detailAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote_detail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote_detail[P]>
      : GetScalarType<T[P], AggregateQuote_detail[P]>
  }




  export type quote_detailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quote_detailWhereInput
    orderBy?: quote_detailOrderByWithAggregationInput | quote_detailOrderByWithAggregationInput[]
    by: Quote_detailScalarFieldEnum[] | Quote_detailScalarFieldEnum
    having?: quote_detailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Quote_detailCountAggregateInputType | true
    _avg?: Quote_detailAvgAggregateInputType
    _sum?: Quote_detailSumAggregateInputType
    _min?: Quote_detailMinAggregateInputType
    _max?: Quote_detailMaxAggregateInputType
  }

  export type Quote_detailGroupByOutputType = {
    id: string
    quote_id: string | null
    service_id: string | null
    item: number | null
    quantity: number | null
    total_value: number | null
    created: Date | null
    updated: Date | null
    status: boolean | null
    _count: Quote_detailCountAggregateOutputType | null
    _avg: Quote_detailAvgAggregateOutputType | null
    _sum: Quote_detailSumAggregateOutputType | null
    _min: Quote_detailMinAggregateOutputType | null
    _max: Quote_detailMaxAggregateOutputType | null
  }

  type GetQuote_detailGroupByPayload<T extends quote_detailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Quote_detailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Quote_detailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Quote_detailGroupByOutputType[P]>
            : GetScalarType<T[P], Quote_detailGroupByOutputType[P]>
        }
      >
    >


  export type quote_detailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quote_id?: boolean
    service_id?: boolean
    item?: boolean
    quantity?: boolean
    total_value?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    quote?: boolean | quote_detail$quoteArgs<ExtArgs>
    service?: boolean | quote_detail$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["quote_detail"]>

  export type quote_detailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quote_id?: boolean
    service_id?: boolean
    item?: boolean
    quantity?: boolean
    total_value?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    quote?: boolean | quote_detail$quoteArgs<ExtArgs>
    service?: boolean | quote_detail$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["quote_detail"]>

  export type quote_detailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quote_id?: boolean
    service_id?: boolean
    item?: boolean
    quantity?: boolean
    total_value?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    quote?: boolean | quote_detail$quoteArgs<ExtArgs>
    service?: boolean | quote_detail$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["quote_detail"]>

  export type quote_detailSelectScalar = {
    id?: boolean
    quote_id?: boolean
    service_id?: boolean
    item?: boolean
    quantity?: boolean
    total_value?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
  }

  export type quote_detailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quote_id" | "service_id" | "item" | "quantity" | "total_value" | "created" | "updated" | "status", ExtArgs["result"]["quote_detail"]>
  export type quote_detailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | quote_detail$quoteArgs<ExtArgs>
    service?: boolean | quote_detail$serviceArgs<ExtArgs>
  }
  export type quote_detailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | quote_detail$quoteArgs<ExtArgs>
    service?: boolean | quote_detail$serviceArgs<ExtArgs>
  }
  export type quote_detailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | quote_detail$quoteArgs<ExtArgs>
    service?: boolean | quote_detail$serviceArgs<ExtArgs>
  }

  export type $quote_detailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "quote_detail"
    objects: {
      quote: Prisma.$quotePayload<ExtArgs> | null
      service: Prisma.$servicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quote_id: string | null
      service_id: string | null
      item: number | null
      quantity: number | null
      total_value: number | null
      created: Date | null
      updated: Date | null
      status: boolean | null
    }, ExtArgs["result"]["quote_detail"]>
    composites: {}
  }

  type quote_detailGetPayload<S extends boolean | null | undefined | quote_detailDefaultArgs> = $Result.GetResult<Prisma.$quote_detailPayload, S>

  type quote_detailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<quote_detailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Quote_detailCountAggregateInputType | true
    }

  export interface quote_detailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['quote_detail'], meta: { name: 'quote_detail' } }
    /**
     * Find zero or one Quote_detail that matches the filter.
     * @param {quote_detailFindUniqueArgs} args - Arguments to find a Quote_detail
     * @example
     * // Get one Quote_detail
     * const quote_detail = await prisma.quote_detail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends quote_detailFindUniqueArgs>(args: SelectSubset<T, quote_detailFindUniqueArgs<ExtArgs>>): Prisma__quote_detailClient<$Result.GetResult<Prisma.$quote_detailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quote_detail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {quote_detailFindUniqueOrThrowArgs} args - Arguments to find a Quote_detail
     * @example
     * // Get one Quote_detail
     * const quote_detail = await prisma.quote_detail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends quote_detailFindUniqueOrThrowArgs>(args: SelectSubset<T, quote_detailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__quote_detailClient<$Result.GetResult<Prisma.$quote_detailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote_detail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_detailFindFirstArgs} args - Arguments to find a Quote_detail
     * @example
     * // Get one Quote_detail
     * const quote_detail = await prisma.quote_detail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends quote_detailFindFirstArgs>(args?: SelectSubset<T, quote_detailFindFirstArgs<ExtArgs>>): Prisma__quote_detailClient<$Result.GetResult<Prisma.$quote_detailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote_detail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_detailFindFirstOrThrowArgs} args - Arguments to find a Quote_detail
     * @example
     * // Get one Quote_detail
     * const quote_detail = await prisma.quote_detail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends quote_detailFindFirstOrThrowArgs>(args?: SelectSubset<T, quote_detailFindFirstOrThrowArgs<ExtArgs>>): Prisma__quote_detailClient<$Result.GetResult<Prisma.$quote_detailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quote_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_detailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quote_details
     * const quote_details = await prisma.quote_detail.findMany()
     * 
     * // Get first 10 Quote_details
     * const quote_details = await prisma.quote_detail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quote_detailWithIdOnly = await prisma.quote_detail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends quote_detailFindManyArgs>(args?: SelectSubset<T, quote_detailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_detailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quote_detail.
     * @param {quote_detailCreateArgs} args - Arguments to create a Quote_detail.
     * @example
     * // Create one Quote_detail
     * const Quote_detail = await prisma.quote_detail.create({
     *   data: {
     *     // ... data to create a Quote_detail
     *   }
     * })
     * 
     */
    create<T extends quote_detailCreateArgs>(args: SelectSubset<T, quote_detailCreateArgs<ExtArgs>>): Prisma__quote_detailClient<$Result.GetResult<Prisma.$quote_detailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quote_details.
     * @param {quote_detailCreateManyArgs} args - Arguments to create many Quote_details.
     * @example
     * // Create many Quote_details
     * const quote_detail = await prisma.quote_detail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends quote_detailCreateManyArgs>(args?: SelectSubset<T, quote_detailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quote_details and returns the data saved in the database.
     * @param {quote_detailCreateManyAndReturnArgs} args - Arguments to create many Quote_details.
     * @example
     * // Create many Quote_details
     * const quote_detail = await prisma.quote_detail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quote_details and only return the `id`
     * const quote_detailWithIdOnly = await prisma.quote_detail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends quote_detailCreateManyAndReturnArgs>(args?: SelectSubset<T, quote_detailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_detailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quote_detail.
     * @param {quote_detailDeleteArgs} args - Arguments to delete one Quote_detail.
     * @example
     * // Delete one Quote_detail
     * const Quote_detail = await prisma.quote_detail.delete({
     *   where: {
     *     // ... filter to delete one Quote_detail
     *   }
     * })
     * 
     */
    delete<T extends quote_detailDeleteArgs>(args: SelectSubset<T, quote_detailDeleteArgs<ExtArgs>>): Prisma__quote_detailClient<$Result.GetResult<Prisma.$quote_detailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quote_detail.
     * @param {quote_detailUpdateArgs} args - Arguments to update one Quote_detail.
     * @example
     * // Update one Quote_detail
     * const quote_detail = await prisma.quote_detail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends quote_detailUpdateArgs>(args: SelectSubset<T, quote_detailUpdateArgs<ExtArgs>>): Prisma__quote_detailClient<$Result.GetResult<Prisma.$quote_detailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quote_details.
     * @param {quote_detailDeleteManyArgs} args - Arguments to filter Quote_details to delete.
     * @example
     * // Delete a few Quote_details
     * const { count } = await prisma.quote_detail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends quote_detailDeleteManyArgs>(args?: SelectSubset<T, quote_detailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quote_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_detailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quote_details
     * const quote_detail = await prisma.quote_detail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends quote_detailUpdateManyArgs>(args: SelectSubset<T, quote_detailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quote_details and returns the data updated in the database.
     * @param {quote_detailUpdateManyAndReturnArgs} args - Arguments to update many Quote_details.
     * @example
     * // Update many Quote_details
     * const quote_detail = await prisma.quote_detail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quote_details and only return the `id`
     * const quote_detailWithIdOnly = await prisma.quote_detail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends quote_detailUpdateManyAndReturnArgs>(args: SelectSubset<T, quote_detailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_detailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quote_detail.
     * @param {quote_detailUpsertArgs} args - Arguments to update or create a Quote_detail.
     * @example
     * // Update or create a Quote_detail
     * const quote_detail = await prisma.quote_detail.upsert({
     *   create: {
     *     // ... data to create a Quote_detail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote_detail we want to update
     *   }
     * })
     */
    upsert<T extends quote_detailUpsertArgs>(args: SelectSubset<T, quote_detailUpsertArgs<ExtArgs>>): Prisma__quote_detailClient<$Result.GetResult<Prisma.$quote_detailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quote_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_detailCountArgs} args - Arguments to filter Quote_details to count.
     * @example
     * // Count the number of Quote_details
     * const count = await prisma.quote_detail.count({
     *   where: {
     *     // ... the filter for the Quote_details we want to count
     *   }
     * })
    **/
    count<T extends quote_detailCountArgs>(
      args?: Subset<T, quote_detailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Quote_detailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote_detail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Quote_detailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Quote_detailAggregateArgs>(args: Subset<T, Quote_detailAggregateArgs>): Prisma.PrismaPromise<GetQuote_detailAggregateType<T>>

    /**
     * Group by Quote_detail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_detailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends quote_detailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: quote_detailGroupByArgs['orderBy'] }
        : { orderBy?: quote_detailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, quote_detailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuote_detailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the quote_detail model
   */
  readonly fields: quote_detailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for quote_detail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__quote_detailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quote<T extends quote_detail$quoteArgs<ExtArgs> = {}>(args?: Subset<T, quote_detail$quoteArgs<ExtArgs>>): Prisma__quoteClient<$Result.GetResult<Prisma.$quotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    service<T extends quote_detail$serviceArgs<ExtArgs> = {}>(args?: Subset<T, quote_detail$serviceArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the quote_detail model
   */
  interface quote_detailFieldRefs {
    readonly id: FieldRef<"quote_detail", 'String'>
    readonly quote_id: FieldRef<"quote_detail", 'String'>
    readonly service_id: FieldRef<"quote_detail", 'String'>
    readonly item: FieldRef<"quote_detail", 'Int'>
    readonly quantity: FieldRef<"quote_detail", 'Int'>
    readonly total_value: FieldRef<"quote_detail", 'Float'>
    readonly created: FieldRef<"quote_detail", 'DateTime'>
    readonly updated: FieldRef<"quote_detail", 'DateTime'>
    readonly status: FieldRef<"quote_detail", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * quote_detail findUnique
   */
  export type quote_detailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_detail
     */
    select?: quote_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_detail
     */
    omit?: quote_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_detailInclude<ExtArgs> | null
    /**
     * Filter, which quote_detail to fetch.
     */
    where: quote_detailWhereUniqueInput
  }

  /**
   * quote_detail findUniqueOrThrow
   */
  export type quote_detailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_detail
     */
    select?: quote_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_detail
     */
    omit?: quote_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_detailInclude<ExtArgs> | null
    /**
     * Filter, which quote_detail to fetch.
     */
    where: quote_detailWhereUniqueInput
  }

  /**
   * quote_detail findFirst
   */
  export type quote_detailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_detail
     */
    select?: quote_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_detail
     */
    omit?: quote_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_detailInclude<ExtArgs> | null
    /**
     * Filter, which quote_detail to fetch.
     */
    where?: quote_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_details to fetch.
     */
    orderBy?: quote_detailOrderByWithRelationInput | quote_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quote_details.
     */
    cursor?: quote_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quote_details.
     */
    distinct?: Quote_detailScalarFieldEnum | Quote_detailScalarFieldEnum[]
  }

  /**
   * quote_detail findFirstOrThrow
   */
  export type quote_detailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_detail
     */
    select?: quote_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_detail
     */
    omit?: quote_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_detailInclude<ExtArgs> | null
    /**
     * Filter, which quote_detail to fetch.
     */
    where?: quote_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_details to fetch.
     */
    orderBy?: quote_detailOrderByWithRelationInput | quote_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quote_details.
     */
    cursor?: quote_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quote_details.
     */
    distinct?: Quote_detailScalarFieldEnum | Quote_detailScalarFieldEnum[]
  }

  /**
   * quote_detail findMany
   */
  export type quote_detailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_detail
     */
    select?: quote_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_detail
     */
    omit?: quote_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_detailInclude<ExtArgs> | null
    /**
     * Filter, which quote_details to fetch.
     */
    where?: quote_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_details to fetch.
     */
    orderBy?: quote_detailOrderByWithRelationInput | quote_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quote_details.
     */
    cursor?: quote_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_details.
     */
    skip?: number
    distinct?: Quote_detailScalarFieldEnum | Quote_detailScalarFieldEnum[]
  }

  /**
   * quote_detail create
   */
  export type quote_detailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_detail
     */
    select?: quote_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_detail
     */
    omit?: quote_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_detailInclude<ExtArgs> | null
    /**
     * The data needed to create a quote_detail.
     */
    data: XOR<quote_detailCreateInput, quote_detailUncheckedCreateInput>
  }

  /**
   * quote_detail createMany
   */
  export type quote_detailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many quote_details.
     */
    data: quote_detailCreateManyInput | quote_detailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * quote_detail createManyAndReturn
   */
  export type quote_detailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_detail
     */
    select?: quote_detailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the quote_detail
     */
    omit?: quote_detailOmit<ExtArgs> | null
    /**
     * The data used to create many quote_details.
     */
    data: quote_detailCreateManyInput | quote_detailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_detailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * quote_detail update
   */
  export type quote_detailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_detail
     */
    select?: quote_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_detail
     */
    omit?: quote_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_detailInclude<ExtArgs> | null
    /**
     * The data needed to update a quote_detail.
     */
    data: XOR<quote_detailUpdateInput, quote_detailUncheckedUpdateInput>
    /**
     * Choose, which quote_detail to update.
     */
    where: quote_detailWhereUniqueInput
  }

  /**
   * quote_detail updateMany
   */
  export type quote_detailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update quote_details.
     */
    data: XOR<quote_detailUpdateManyMutationInput, quote_detailUncheckedUpdateManyInput>
    /**
     * Filter which quote_details to update
     */
    where?: quote_detailWhereInput
    /**
     * Limit how many quote_details to update.
     */
    limit?: number
  }

  /**
   * quote_detail updateManyAndReturn
   */
  export type quote_detailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_detail
     */
    select?: quote_detailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the quote_detail
     */
    omit?: quote_detailOmit<ExtArgs> | null
    /**
     * The data used to update quote_details.
     */
    data: XOR<quote_detailUpdateManyMutationInput, quote_detailUncheckedUpdateManyInput>
    /**
     * Filter which quote_details to update
     */
    where?: quote_detailWhereInput
    /**
     * Limit how many quote_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_detailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * quote_detail upsert
   */
  export type quote_detailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_detail
     */
    select?: quote_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_detail
     */
    omit?: quote_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_detailInclude<ExtArgs> | null
    /**
     * The filter to search for the quote_detail to update in case it exists.
     */
    where: quote_detailWhereUniqueInput
    /**
     * In case the quote_detail found by the `where` argument doesn't exist, create a new quote_detail with this data.
     */
    create: XOR<quote_detailCreateInput, quote_detailUncheckedCreateInput>
    /**
     * In case the quote_detail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<quote_detailUpdateInput, quote_detailUncheckedUpdateInput>
  }

  /**
   * quote_detail delete
   */
  export type quote_detailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_detail
     */
    select?: quote_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_detail
     */
    omit?: quote_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_detailInclude<ExtArgs> | null
    /**
     * Filter which quote_detail to delete.
     */
    where: quote_detailWhereUniqueInput
  }

  /**
   * quote_detail deleteMany
   */
  export type quote_detailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quote_details to delete
     */
    where?: quote_detailWhereInput
    /**
     * Limit how many quote_details to delete.
     */
    limit?: number
  }

  /**
   * quote_detail.quote
   */
  export type quote_detail$quoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote
     */
    select?: quoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote
     */
    omit?: quoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quoteInclude<ExtArgs> | null
    where?: quoteWhereInput
  }

  /**
   * quote_detail.service
   */
  export type quote_detail$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    where?: serviceWhereInput
  }

  /**
   * quote_detail without action
   */
  export type quote_detailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_detail
     */
    select?: quote_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_detail
     */
    omit?: quote_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_detailInclude<ExtArgs> | null
  }


  /**
   * Model role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    role_category: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
    description: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role_category: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
    description: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    role_category: number
    created: number
    updated: number
    status: number
    description: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    role_category?: true
    created?: true
    updated?: true
    status?: true
    description?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    role_category?: true
    created?: true
    updated?: true
    status?: true
    description?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    role_category?: true
    created?: true
    updated?: true
    status?: true
    description?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role to aggregate.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleWhereInput
    orderBy?: roleOrderByWithAggregationInput | roleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string | null
    role_category: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
    description: string | null
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role_category?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    description?: boolean
    log?: boolean | role$logArgs<ExtArgs>
    role_permission?: boolean | role$role_permissionArgs<ExtArgs>
    user?: boolean | role$userArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type roleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role_category?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    description?: boolean
  }, ExtArgs["result"]["role"]>

  export type roleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role_category?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    description?: boolean
  }, ExtArgs["result"]["role"]>

  export type roleSelectScalar = {
    id?: boolean
    name?: boolean
    role_category?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    description?: boolean
  }

  export type roleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "role_category" | "created" | "updated" | "status" | "description", ExtArgs["result"]["role"]>
  export type roleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    log?: boolean | role$logArgs<ExtArgs>
    role_permission?: boolean | role$role_permissionArgs<ExtArgs>
    user?: boolean | role$userArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type roleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type roleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role"
    objects: {
      log: Prisma.$logPayload<ExtArgs>[]
      role_permission: Prisma.$role_permissionPayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      role_category: string | null
      created: Date | null
      updated: Date | null
      status: boolean | null
      description: string | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type roleGetPayload<S extends boolean | null | undefined | roleDefaultArgs> = $Result.GetResult<Prisma.$rolePayload, S>

  type roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<roleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role'], meta: { name: 'role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {roleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roleFindUniqueArgs>(args: SelectSubset<T, roleFindUniqueArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {roleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roleFindUniqueOrThrowArgs>(args: SelectSubset<T, roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roleFindFirstArgs>(args?: SelectSubset<T, roleFindFirstArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roleFindFirstOrThrowArgs>(args?: SelectSubset<T, roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends roleFindManyArgs>(args?: SelectSubset<T, roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {roleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends roleCreateArgs>(args: SelectSubset<T, roleCreateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {roleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends roleCreateManyArgs>(args?: SelectSubset<T, roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {roleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends roleCreateManyAndReturnArgs>(args?: SelectSubset<T, roleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {roleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends roleDeleteArgs>(args: SelectSubset<T, roleDeleteArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {roleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends roleUpdateArgs>(args: SelectSubset<T, roleUpdateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {roleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends roleDeleteManyArgs>(args?: SelectSubset<T, roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends roleUpdateManyArgs>(args: SelectSubset<T, roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {roleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends roleUpdateManyAndReturnArgs>(args: SelectSubset<T, roleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {roleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends roleUpsertArgs>(args: SelectSubset<T, roleUpsertArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends roleCountArgs>(
      args?: Subset<T, roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roleGroupByArgs['orderBy'] }
        : { orderBy?: roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role model
   */
  readonly fields: roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    log<T extends role$logArgs<ExtArgs> = {}>(args?: Subset<T, role$logArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    role_permission<T extends role$role_permissionArgs<ExtArgs> = {}>(args?: Subset<T, role$role_permissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_permissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends role$userArgs<ExtArgs> = {}>(args?: Subset<T, role$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role model
   */
  interface roleFieldRefs {
    readonly id: FieldRef<"role", 'String'>
    readonly name: FieldRef<"role", 'String'>
    readonly role_category: FieldRef<"role", 'String'>
    readonly created: FieldRef<"role", 'DateTime'>
    readonly updated: FieldRef<"role", 'DateTime'>
    readonly status: FieldRef<"role", 'Boolean'>
    readonly description: FieldRef<"role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * role findUnique
   */
  export type roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findUniqueOrThrow
   */
  export type roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findFirst
   */
  export type roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findFirstOrThrow
   */
  export type roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findMany
   */
  export type roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role create
   */
  export type roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to create a role.
     */
    data: XOR<roleCreateInput, roleUncheckedCreateInput>
  }

  /**
   * role createMany
   */
  export type roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role createManyAndReturn
   */
  export type roleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role update
   */
  export type roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to update a role.
     */
    data: XOR<roleUpdateInput, roleUncheckedUpdateInput>
    /**
     * Choose, which role to update.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role updateMany
   */
  export type roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * role updateManyAndReturn
   */
  export type roleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * role upsert
   */
  export type roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The filter to search for the role to update in case it exists.
     */
    where: roleWhereUniqueInput
    /**
     * In case the role found by the `where` argument doesn't exist, create a new role with this data.
     */
    create: XOR<roleCreateInput, roleUncheckedCreateInput>
    /**
     * In case the role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roleUpdateInput, roleUncheckedUpdateInput>
  }

  /**
   * role delete
   */
  export type roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter which role to delete.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role deleteMany
   */
  export type roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to delete.
     */
    limit?: number
  }

  /**
   * role.log
   */
  export type role$logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the log
     */
    omit?: logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logInclude<ExtArgs> | null
    where?: logWhereInput
    orderBy?: logOrderByWithRelationInput | logOrderByWithRelationInput[]
    cursor?: logWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * role.role_permission
   */
  export type role$role_permissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permission
     */
    select?: role_permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permission
     */
    omit?: role_permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionInclude<ExtArgs> | null
    where?: role_permissionWhereInput
    orderBy?: role_permissionOrderByWithRelationInput | role_permissionOrderByWithRelationInput[]
    cursor?: role_permissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Role_permissionScalarFieldEnum | Role_permissionScalarFieldEnum[]
  }

  /**
   * role.user
   */
  export type role$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * role without action
   */
  export type roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
  }


  /**
   * Model role_permission
   */

  export type AggregateRole_permission = {
    _count: Role_permissionCountAggregateOutputType | null
    _min: Role_permissionMinAggregateOutputType | null
    _max: Role_permissionMaxAggregateOutputType | null
  }

  export type Role_permissionMinAggregateOutputType = {
    id: string | null
    role_id: string | null
    permission_id: string | null
  }

  export type Role_permissionMaxAggregateOutputType = {
    id: string | null
    role_id: string | null
    permission_id: string | null
  }

  export type Role_permissionCountAggregateOutputType = {
    id: number
    role_id: number
    permission_id: number
    _all: number
  }


  export type Role_permissionMinAggregateInputType = {
    id?: true
    role_id?: true
    permission_id?: true
  }

  export type Role_permissionMaxAggregateInputType = {
    id?: true
    role_id?: true
    permission_id?: true
  }

  export type Role_permissionCountAggregateInputType = {
    id?: true
    role_id?: true
    permission_id?: true
    _all?: true
  }

  export type Role_permissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role_permission to aggregate.
     */
    where?: role_permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_permissions to fetch.
     */
    orderBy?: role_permissionOrderByWithRelationInput | role_permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: role_permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned role_permissions
    **/
    _count?: true | Role_permissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Role_permissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Role_permissionMaxAggregateInputType
  }

  export type GetRole_permissionAggregateType<T extends Role_permissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRole_permission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole_permission[P]>
      : GetScalarType<T[P], AggregateRole_permission[P]>
  }




  export type role_permissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_permissionWhereInput
    orderBy?: role_permissionOrderByWithAggregationInput | role_permissionOrderByWithAggregationInput[]
    by: Role_permissionScalarFieldEnum[] | Role_permissionScalarFieldEnum
    having?: role_permissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Role_permissionCountAggregateInputType | true
    _min?: Role_permissionMinAggregateInputType
    _max?: Role_permissionMaxAggregateInputType
  }

  export type Role_permissionGroupByOutputType = {
    id: string
    role_id: string | null
    permission_id: string | null
    _count: Role_permissionCountAggregateOutputType | null
    _min: Role_permissionMinAggregateOutputType | null
    _max: Role_permissionMaxAggregateOutputType | null
  }

  type GetRole_permissionGroupByPayload<T extends role_permissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Role_permissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Role_permissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Role_permissionGroupByOutputType[P]>
            : GetScalarType<T[P], Role_permissionGroupByOutputType[P]>
        }
      >
    >


  export type role_permissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_id?: boolean
    permission_id?: boolean
    permission?: boolean | role_permission$permissionArgs<ExtArgs>
    role?: boolean | role_permission$roleArgs<ExtArgs>
  }, ExtArgs["result"]["role_permission"]>

  export type role_permissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_id?: boolean
    permission_id?: boolean
    permission?: boolean | role_permission$permissionArgs<ExtArgs>
    role?: boolean | role_permission$roleArgs<ExtArgs>
  }, ExtArgs["result"]["role_permission"]>

  export type role_permissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_id?: boolean
    permission_id?: boolean
    permission?: boolean | role_permission$permissionArgs<ExtArgs>
    role?: boolean | role_permission$roleArgs<ExtArgs>
  }, ExtArgs["result"]["role_permission"]>

  export type role_permissionSelectScalar = {
    id?: boolean
    role_id?: boolean
    permission_id?: boolean
  }

  export type role_permissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role_id" | "permission_id", ExtArgs["result"]["role_permission"]>
  export type role_permissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | role_permission$permissionArgs<ExtArgs>
    role?: boolean | role_permission$roleArgs<ExtArgs>
  }
  export type role_permissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | role_permission$permissionArgs<ExtArgs>
    role?: boolean | role_permission$roleArgs<ExtArgs>
  }
  export type role_permissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | role_permission$permissionArgs<ExtArgs>
    role?: boolean | role_permission$roleArgs<ExtArgs>
  }

  export type $role_permissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role_permission"
    objects: {
      permission: Prisma.$permissionPayload<ExtArgs> | null
      role: Prisma.$rolePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role_id: string | null
      permission_id: string | null
    }, ExtArgs["result"]["role_permission"]>
    composites: {}
  }

  type role_permissionGetPayload<S extends boolean | null | undefined | role_permissionDefaultArgs> = $Result.GetResult<Prisma.$role_permissionPayload, S>

  type role_permissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<role_permissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Role_permissionCountAggregateInputType | true
    }

  export interface role_permissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role_permission'], meta: { name: 'role_permission' } }
    /**
     * Find zero or one Role_permission that matches the filter.
     * @param {role_permissionFindUniqueArgs} args - Arguments to find a Role_permission
     * @example
     * // Get one Role_permission
     * const role_permission = await prisma.role_permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends role_permissionFindUniqueArgs>(args: SelectSubset<T, role_permissionFindUniqueArgs<ExtArgs>>): Prisma__role_permissionClient<$Result.GetResult<Prisma.$role_permissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role_permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {role_permissionFindUniqueOrThrowArgs} args - Arguments to find a Role_permission
     * @example
     * // Get one Role_permission
     * const role_permission = await prisma.role_permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends role_permissionFindUniqueOrThrowArgs>(args: SelectSubset<T, role_permissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__role_permissionClient<$Result.GetResult<Prisma.$role_permissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role_permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionFindFirstArgs} args - Arguments to find a Role_permission
     * @example
     * // Get one Role_permission
     * const role_permission = await prisma.role_permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends role_permissionFindFirstArgs>(args?: SelectSubset<T, role_permissionFindFirstArgs<ExtArgs>>): Prisma__role_permissionClient<$Result.GetResult<Prisma.$role_permissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role_permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionFindFirstOrThrowArgs} args - Arguments to find a Role_permission
     * @example
     * // Get one Role_permission
     * const role_permission = await prisma.role_permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends role_permissionFindFirstOrThrowArgs>(args?: SelectSubset<T, role_permissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__role_permissionClient<$Result.GetResult<Prisma.$role_permissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Role_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Role_permissions
     * const role_permissions = await prisma.role_permission.findMany()
     * 
     * // Get first 10 Role_permissions
     * const role_permissions = await prisma.role_permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const role_permissionWithIdOnly = await prisma.role_permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends role_permissionFindManyArgs>(args?: SelectSubset<T, role_permissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_permissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role_permission.
     * @param {role_permissionCreateArgs} args - Arguments to create a Role_permission.
     * @example
     * // Create one Role_permission
     * const Role_permission = await prisma.role_permission.create({
     *   data: {
     *     // ... data to create a Role_permission
     *   }
     * })
     * 
     */
    create<T extends role_permissionCreateArgs>(args: SelectSubset<T, role_permissionCreateArgs<ExtArgs>>): Prisma__role_permissionClient<$Result.GetResult<Prisma.$role_permissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Role_permissions.
     * @param {role_permissionCreateManyArgs} args - Arguments to create many Role_permissions.
     * @example
     * // Create many Role_permissions
     * const role_permission = await prisma.role_permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends role_permissionCreateManyArgs>(args?: SelectSubset<T, role_permissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Role_permissions and returns the data saved in the database.
     * @param {role_permissionCreateManyAndReturnArgs} args - Arguments to create many Role_permissions.
     * @example
     * // Create many Role_permissions
     * const role_permission = await prisma.role_permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Role_permissions and only return the `id`
     * const role_permissionWithIdOnly = await prisma.role_permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends role_permissionCreateManyAndReturnArgs>(args?: SelectSubset<T, role_permissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_permissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role_permission.
     * @param {role_permissionDeleteArgs} args - Arguments to delete one Role_permission.
     * @example
     * // Delete one Role_permission
     * const Role_permission = await prisma.role_permission.delete({
     *   where: {
     *     // ... filter to delete one Role_permission
     *   }
     * })
     * 
     */
    delete<T extends role_permissionDeleteArgs>(args: SelectSubset<T, role_permissionDeleteArgs<ExtArgs>>): Prisma__role_permissionClient<$Result.GetResult<Prisma.$role_permissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role_permission.
     * @param {role_permissionUpdateArgs} args - Arguments to update one Role_permission.
     * @example
     * // Update one Role_permission
     * const role_permission = await prisma.role_permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends role_permissionUpdateArgs>(args: SelectSubset<T, role_permissionUpdateArgs<ExtArgs>>): Prisma__role_permissionClient<$Result.GetResult<Prisma.$role_permissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Role_permissions.
     * @param {role_permissionDeleteManyArgs} args - Arguments to filter Role_permissions to delete.
     * @example
     * // Delete a few Role_permissions
     * const { count } = await prisma.role_permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends role_permissionDeleteManyArgs>(args?: SelectSubset<T, role_permissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Role_permissions
     * const role_permission = await prisma.role_permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends role_permissionUpdateManyArgs>(args: SelectSubset<T, role_permissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Role_permissions and returns the data updated in the database.
     * @param {role_permissionUpdateManyAndReturnArgs} args - Arguments to update many Role_permissions.
     * @example
     * // Update many Role_permissions
     * const role_permission = await prisma.role_permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Role_permissions and only return the `id`
     * const role_permissionWithIdOnly = await prisma.role_permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends role_permissionUpdateManyAndReturnArgs>(args: SelectSubset<T, role_permissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_permissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role_permission.
     * @param {role_permissionUpsertArgs} args - Arguments to update or create a Role_permission.
     * @example
     * // Update or create a Role_permission
     * const role_permission = await prisma.role_permission.upsert({
     *   create: {
     *     // ... data to create a Role_permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role_permission we want to update
     *   }
     * })
     */
    upsert<T extends role_permissionUpsertArgs>(args: SelectSubset<T, role_permissionUpsertArgs<ExtArgs>>): Prisma__role_permissionClient<$Result.GetResult<Prisma.$role_permissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionCountArgs} args - Arguments to filter Role_permissions to count.
     * @example
     * // Count the number of Role_permissions
     * const count = await prisma.role_permission.count({
     *   where: {
     *     // ... the filter for the Role_permissions we want to count
     *   }
     * })
    **/
    count<T extends role_permissionCountArgs>(
      args?: Subset<T, role_permissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Role_permissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role_permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Role_permissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Role_permissionAggregateArgs>(args: Subset<T, Role_permissionAggregateArgs>): Prisma.PrismaPromise<GetRole_permissionAggregateType<T>>

    /**
     * Group by Role_permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends role_permissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: role_permissionGroupByArgs['orderBy'] }
        : { orderBy?: role_permissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, role_permissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRole_permissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role_permission model
   */
  readonly fields: role_permissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role_permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__role_permissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permission<T extends role_permission$permissionArgs<ExtArgs> = {}>(args?: Subset<T, role_permission$permissionArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    role<T extends role_permission$roleArgs<ExtArgs> = {}>(args?: Subset<T, role_permission$roleArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role_permission model
   */
  interface role_permissionFieldRefs {
    readonly id: FieldRef<"role_permission", 'String'>
    readonly role_id: FieldRef<"role_permission", 'String'>
    readonly permission_id: FieldRef<"role_permission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * role_permission findUnique
   */
  export type role_permissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permission
     */
    select?: role_permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permission
     */
    omit?: role_permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionInclude<ExtArgs> | null
    /**
     * Filter, which role_permission to fetch.
     */
    where: role_permissionWhereUniqueInput
  }

  /**
   * role_permission findUniqueOrThrow
   */
  export type role_permissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permission
     */
    select?: role_permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permission
     */
    omit?: role_permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionInclude<ExtArgs> | null
    /**
     * Filter, which role_permission to fetch.
     */
    where: role_permissionWhereUniqueInput
  }

  /**
   * role_permission findFirst
   */
  export type role_permissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permission
     */
    select?: role_permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permission
     */
    omit?: role_permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionInclude<ExtArgs> | null
    /**
     * Filter, which role_permission to fetch.
     */
    where?: role_permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_permissions to fetch.
     */
    orderBy?: role_permissionOrderByWithRelationInput | role_permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for role_permissions.
     */
    cursor?: role_permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of role_permissions.
     */
    distinct?: Role_permissionScalarFieldEnum | Role_permissionScalarFieldEnum[]
  }

  /**
   * role_permission findFirstOrThrow
   */
  export type role_permissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permission
     */
    select?: role_permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permission
     */
    omit?: role_permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionInclude<ExtArgs> | null
    /**
     * Filter, which role_permission to fetch.
     */
    where?: role_permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_permissions to fetch.
     */
    orderBy?: role_permissionOrderByWithRelationInput | role_permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for role_permissions.
     */
    cursor?: role_permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of role_permissions.
     */
    distinct?: Role_permissionScalarFieldEnum | Role_permissionScalarFieldEnum[]
  }

  /**
   * role_permission findMany
   */
  export type role_permissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permission
     */
    select?: role_permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permission
     */
    omit?: role_permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionInclude<ExtArgs> | null
    /**
     * Filter, which role_permissions to fetch.
     */
    where?: role_permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_permissions to fetch.
     */
    orderBy?: role_permissionOrderByWithRelationInput | role_permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing role_permissions.
     */
    cursor?: role_permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_permissions.
     */
    skip?: number
    distinct?: Role_permissionScalarFieldEnum | Role_permissionScalarFieldEnum[]
  }

  /**
   * role_permission create
   */
  export type role_permissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permission
     */
    select?: role_permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permission
     */
    omit?: role_permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionInclude<ExtArgs> | null
    /**
     * The data needed to create a role_permission.
     */
    data: XOR<role_permissionCreateInput, role_permissionUncheckedCreateInput>
  }

  /**
   * role_permission createMany
   */
  export type role_permissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many role_permissions.
     */
    data: role_permissionCreateManyInput | role_permissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role_permission createManyAndReturn
   */
  export type role_permissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permission
     */
    select?: role_permissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role_permission
     */
    omit?: role_permissionOmit<ExtArgs> | null
    /**
     * The data used to create many role_permissions.
     */
    data: role_permissionCreateManyInput | role_permissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * role_permission update
   */
  export type role_permissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permission
     */
    select?: role_permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permission
     */
    omit?: role_permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionInclude<ExtArgs> | null
    /**
     * The data needed to update a role_permission.
     */
    data: XOR<role_permissionUpdateInput, role_permissionUncheckedUpdateInput>
    /**
     * Choose, which role_permission to update.
     */
    where: role_permissionWhereUniqueInput
  }

  /**
   * role_permission updateMany
   */
  export type role_permissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update role_permissions.
     */
    data: XOR<role_permissionUpdateManyMutationInput, role_permissionUncheckedUpdateManyInput>
    /**
     * Filter which role_permissions to update
     */
    where?: role_permissionWhereInput
    /**
     * Limit how many role_permissions to update.
     */
    limit?: number
  }

  /**
   * role_permission updateManyAndReturn
   */
  export type role_permissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permission
     */
    select?: role_permissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role_permission
     */
    omit?: role_permissionOmit<ExtArgs> | null
    /**
     * The data used to update role_permissions.
     */
    data: XOR<role_permissionUpdateManyMutationInput, role_permissionUncheckedUpdateManyInput>
    /**
     * Filter which role_permissions to update
     */
    where?: role_permissionWhereInput
    /**
     * Limit how many role_permissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * role_permission upsert
   */
  export type role_permissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permission
     */
    select?: role_permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permission
     */
    omit?: role_permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionInclude<ExtArgs> | null
    /**
     * The filter to search for the role_permission to update in case it exists.
     */
    where: role_permissionWhereUniqueInput
    /**
     * In case the role_permission found by the `where` argument doesn't exist, create a new role_permission with this data.
     */
    create: XOR<role_permissionCreateInput, role_permissionUncheckedCreateInput>
    /**
     * In case the role_permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<role_permissionUpdateInput, role_permissionUncheckedUpdateInput>
  }

  /**
   * role_permission delete
   */
  export type role_permissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permission
     */
    select?: role_permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permission
     */
    omit?: role_permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionInclude<ExtArgs> | null
    /**
     * Filter which role_permission to delete.
     */
    where: role_permissionWhereUniqueInput
  }

  /**
   * role_permission deleteMany
   */
  export type role_permissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role_permissions to delete
     */
    where?: role_permissionWhereInput
    /**
     * Limit how many role_permissions to delete.
     */
    limit?: number
  }

  /**
   * role_permission.permission
   */
  export type role_permission$permissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    where?: permissionWhereInput
  }

  /**
   * role_permission.role
   */
  export type role_permission$roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    where?: roleWhereInput
  }

  /**
   * role_permission without action
   */
  export type role_permissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permission
     */
    select?: role_permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permission
     */
    omit?: role_permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionInclude<ExtArgs> | null
  }


  /**
   * Model service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    service_category_id: string | null
    name: string | null
    unit: string | null
    description: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    service_category_id: string | null
    name: string | null
    unit: string | null
    description: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    service_category_id: number
    name: number
    unit: number
    description: number
    created: number
    updated: number
    status: number
    _all: number
  }


  export type ServiceMinAggregateInputType = {
    id?: true
    service_category_id?: true
    name?: true
    unit?: true
    description?: true
    created?: true
    updated?: true
    status?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    service_category_id?: true
    name?: true
    unit?: true
    description?: true
    created?: true
    updated?: true
    status?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    service_category_id?: true
    name?: true
    unit?: true
    description?: true
    created?: true
    updated?: true
    status?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service to aggregate.
     */
    where?: serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: serviceOrderByWithRelationInput | serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type serviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceWhereInput
    orderBy?: serviceOrderByWithAggregationInput | serviceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: serviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    service_category_id: string | null
    name: string | null
    unit: string | null
    description: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends serviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type serviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_category_id?: boolean
    name?: boolean
    unit?: boolean
    description?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    client_service?: boolean | service$client_serviceArgs<ExtArgs>
    invoice_detail?: boolean | service$invoice_detailArgs<ExtArgs>
    quote_detail?: boolean | service$quote_detailArgs<ExtArgs>
    service_category?: boolean | service$service_categoryArgs<ExtArgs>
    service_usage?: boolean | service$service_usageArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type serviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_category_id?: boolean
    name?: boolean
    unit?: boolean
    description?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    service_category?: boolean | service$service_categoryArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type serviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_category_id?: boolean
    name?: boolean
    unit?: boolean
    description?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    service_category?: boolean | service$service_categoryArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type serviceSelectScalar = {
    id?: boolean
    service_category_id?: boolean
    name?: boolean
    unit?: boolean
    description?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
  }

  export type serviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service_category_id" | "name" | "unit" | "description" | "created" | "updated" | "status", ExtArgs["result"]["service"]>
  export type serviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_service?: boolean | service$client_serviceArgs<ExtArgs>
    invoice_detail?: boolean | service$invoice_detailArgs<ExtArgs>
    quote_detail?: boolean | service$quote_detailArgs<ExtArgs>
    service_category?: boolean | service$service_categoryArgs<ExtArgs>
    service_usage?: boolean | service$service_usageArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type serviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service_category?: boolean | service$service_categoryArgs<ExtArgs>
  }
  export type serviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service_category?: boolean | service$service_categoryArgs<ExtArgs>
  }

  export type $servicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "service"
    objects: {
      client_service: Prisma.$client_servicePayload<ExtArgs>[]
      invoice_detail: Prisma.$invoice_detailPayload<ExtArgs>[]
      quote_detail: Prisma.$quote_detailPayload<ExtArgs>[]
      service_category: Prisma.$service_categoryPayload<ExtArgs> | null
      service_usage: Prisma.$service_usagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      service_category_id: string | null
      name: string | null
      unit: string | null
      description: string | null
      created: Date | null
      updated: Date | null
      status: boolean | null
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type serviceGetPayload<S extends boolean | null | undefined | serviceDefaultArgs> = $Result.GetResult<Prisma.$servicePayload, S>

  type serviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<serviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface serviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['service'], meta: { name: 'service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {serviceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends serviceFindUniqueArgs>(args: SelectSubset<T, serviceFindUniqueArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {serviceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends serviceFindUniqueOrThrowArgs>(args: SelectSubset<T, serviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends serviceFindFirstArgs>(args?: SelectSubset<T, serviceFindFirstArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends serviceFindFirstOrThrowArgs>(args?: SelectSubset<T, serviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends serviceFindManyArgs>(args?: SelectSubset<T, serviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {serviceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends serviceCreateArgs>(args: SelectSubset<T, serviceCreateArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {serviceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends serviceCreateManyArgs>(args?: SelectSubset<T, serviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {serviceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends serviceCreateManyAndReturnArgs>(args?: SelectSubset<T, serviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {serviceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends serviceDeleteArgs>(args: SelectSubset<T, serviceDeleteArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {serviceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends serviceUpdateArgs>(args: SelectSubset<T, serviceUpdateArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {serviceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends serviceDeleteManyArgs>(args?: SelectSubset<T, serviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends serviceUpdateManyArgs>(args: SelectSubset<T, serviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {serviceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends serviceUpdateManyAndReturnArgs>(args: SelectSubset<T, serviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {serviceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends serviceUpsertArgs>(args: SelectSubset<T, serviceUpsertArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends serviceCountArgs>(
      args?: Subset<T, serviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serviceGroupByArgs['orderBy'] }
        : { orderBy?: serviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the service model
   */
  readonly fields: serviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client_service<T extends service$client_serviceArgs<ExtArgs> = {}>(args?: Subset<T, service$client_serviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_servicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoice_detail<T extends service$invoice_detailArgs<ExtArgs> = {}>(args?: Subset<T, service$invoice_detailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_detailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quote_detail<T extends service$quote_detailArgs<ExtArgs> = {}>(args?: Subset<T, service$quote_detailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_detailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    service_category<T extends service$service_categoryArgs<ExtArgs> = {}>(args?: Subset<T, service$service_categoryArgs<ExtArgs>>): Prisma__service_categoryClient<$Result.GetResult<Prisma.$service_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    service_usage<T extends service$service_usageArgs<ExtArgs> = {}>(args?: Subset<T, service$service_usageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_usagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the service model
   */
  interface serviceFieldRefs {
    readonly id: FieldRef<"service", 'String'>
    readonly service_category_id: FieldRef<"service", 'String'>
    readonly name: FieldRef<"service", 'String'>
    readonly unit: FieldRef<"service", 'String'>
    readonly description: FieldRef<"service", 'String'>
    readonly created: FieldRef<"service", 'DateTime'>
    readonly updated: FieldRef<"service", 'DateTime'>
    readonly status: FieldRef<"service", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * service findUnique
   */
  export type serviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter, which service to fetch.
     */
    where: serviceWhereUniqueInput
  }

  /**
   * service findUniqueOrThrow
   */
  export type serviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter, which service to fetch.
     */
    where: serviceWhereUniqueInput
  }

  /**
   * service findFirst
   */
  export type serviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter, which service to fetch.
     */
    where?: serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: serviceOrderByWithRelationInput | serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     */
    cursor?: serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * service findFirstOrThrow
   */
  export type serviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter, which service to fetch.
     */
    where?: serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: serviceOrderByWithRelationInput | serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     */
    cursor?: serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * service findMany
   */
  export type serviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where?: serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: serviceOrderByWithRelationInput | serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing services.
     */
    cursor?: serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * service create
   */
  export type serviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * The data needed to create a service.
     */
    data: XOR<serviceCreateInput, serviceUncheckedCreateInput>
  }

  /**
   * service createMany
   */
  export type serviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many services.
     */
    data: serviceCreateManyInput | serviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * service createManyAndReturn
   */
  export type serviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * The data used to create many services.
     */
    data: serviceCreateManyInput | serviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * service update
   */
  export type serviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * The data needed to update a service.
     */
    data: XOR<serviceUpdateInput, serviceUncheckedUpdateInput>
    /**
     * Choose, which service to update.
     */
    where: serviceWhereUniqueInput
  }

  /**
   * service updateMany
   */
  export type serviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update services.
     */
    data: XOR<serviceUpdateManyMutationInput, serviceUncheckedUpdateManyInput>
    /**
     * Filter which services to update
     */
    where?: serviceWhereInput
    /**
     * Limit how many services to update.
     */
    limit?: number
  }

  /**
   * service updateManyAndReturn
   */
  export type serviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * The data used to update services.
     */
    data: XOR<serviceUpdateManyMutationInput, serviceUncheckedUpdateManyInput>
    /**
     * Filter which services to update
     */
    where?: serviceWhereInput
    /**
     * Limit how many services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * service upsert
   */
  export type serviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * The filter to search for the service to update in case it exists.
     */
    where: serviceWhereUniqueInput
    /**
     * In case the service found by the `where` argument doesn't exist, create a new service with this data.
     */
    create: XOR<serviceCreateInput, serviceUncheckedCreateInput>
    /**
     * In case the service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serviceUpdateInput, serviceUncheckedUpdateInput>
  }

  /**
   * service delete
   */
  export type serviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter which service to delete.
     */
    where: serviceWhereUniqueInput
  }

  /**
   * service deleteMany
   */
  export type serviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which services to delete
     */
    where?: serviceWhereInput
    /**
     * Limit how many services to delete.
     */
    limit?: number
  }

  /**
   * service.client_service
   */
  export type service$client_serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_service
     */
    select?: client_serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_service
     */
    omit?: client_serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_serviceInclude<ExtArgs> | null
    where?: client_serviceWhereInput
    orderBy?: client_serviceOrderByWithRelationInput | client_serviceOrderByWithRelationInput[]
    cursor?: client_serviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Client_serviceScalarFieldEnum | Client_serviceScalarFieldEnum[]
  }

  /**
   * service.invoice_detail
   */
  export type service$invoice_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_detail
     */
    select?: invoice_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_detail
     */
    omit?: invoice_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_detailInclude<ExtArgs> | null
    where?: invoice_detailWhereInput
    orderBy?: invoice_detailOrderByWithRelationInput | invoice_detailOrderByWithRelationInput[]
    cursor?: invoice_detailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Invoice_detailScalarFieldEnum | Invoice_detailScalarFieldEnum[]
  }

  /**
   * service.quote_detail
   */
  export type service$quote_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_detail
     */
    select?: quote_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_detail
     */
    omit?: quote_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_detailInclude<ExtArgs> | null
    where?: quote_detailWhereInput
    orderBy?: quote_detailOrderByWithRelationInput | quote_detailOrderByWithRelationInput[]
    cursor?: quote_detailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Quote_detailScalarFieldEnum | Quote_detailScalarFieldEnum[]
  }

  /**
   * service.service_category
   */
  export type service$service_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_category
     */
    select?: service_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_category
     */
    omit?: service_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoryInclude<ExtArgs> | null
    where?: service_categoryWhereInput
  }

  /**
   * service.service_usage
   */
  export type service$service_usageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage
     */
    select?: service_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_usage
     */
    omit?: service_usageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usageInclude<ExtArgs> | null
    where?: service_usageWhereInput
    orderBy?: service_usageOrderByWithRelationInput | service_usageOrderByWithRelationInput[]
    cursor?: service_usageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Service_usageScalarFieldEnum | Service_usageScalarFieldEnum[]
  }

  /**
   * service without action
   */
  export type serviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
  }


  /**
   * Model service_category
   */

  export type AggregateService_category = {
    _count: Service_categoryCountAggregateOutputType | null
    _min: Service_categoryMinAggregateOutputType | null
    _max: Service_categoryMaxAggregateOutputType | null
  }

  export type Service_categoryMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type Service_categoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type Service_categoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Service_categoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Service_categoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Service_categoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Service_categoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_category to aggregate.
     */
    where?: service_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_categories to fetch.
     */
    orderBy?: service_categoryOrderByWithRelationInput | service_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: service_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned service_categories
    **/
    _count?: true | Service_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Service_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Service_categoryMaxAggregateInputType
  }

  export type GetService_categoryAggregateType<T extends Service_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateService_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService_category[P]>
      : GetScalarType<T[P], AggregateService_category[P]>
  }




  export type service_categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: service_categoryWhereInput
    orderBy?: service_categoryOrderByWithAggregationInput | service_categoryOrderByWithAggregationInput[]
    by: Service_categoryScalarFieldEnum[] | Service_categoryScalarFieldEnum
    having?: service_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Service_categoryCountAggregateInputType | true
    _min?: Service_categoryMinAggregateInputType
    _max?: Service_categoryMaxAggregateInputType
  }

  export type Service_categoryGroupByOutputType = {
    id: string
    name: string | null
    _count: Service_categoryCountAggregateOutputType | null
    _min: Service_categoryMinAggregateOutputType | null
    _max: Service_categoryMaxAggregateOutputType | null
  }

  type GetService_categoryGroupByPayload<T extends service_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Service_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Service_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Service_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Service_categoryGroupByOutputType[P]>
        }
      >
    >


  export type service_categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    service?: boolean | service_category$serviceArgs<ExtArgs>
    _count?: boolean | Service_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service_category"]>

  export type service_categorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["service_category"]>

  export type service_categorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["service_category"]>

  export type service_categorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type service_categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["service_category"]>
  export type service_categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | service_category$serviceArgs<ExtArgs>
    _count?: boolean | Service_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type service_categoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type service_categoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $service_categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "service_category"
    objects: {
      service: Prisma.$servicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
    }, ExtArgs["result"]["service_category"]>
    composites: {}
  }

  type service_categoryGetPayload<S extends boolean | null | undefined | service_categoryDefaultArgs> = $Result.GetResult<Prisma.$service_categoryPayload, S>

  type service_categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<service_categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Service_categoryCountAggregateInputType | true
    }

  export interface service_categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['service_category'], meta: { name: 'service_category' } }
    /**
     * Find zero or one Service_category that matches the filter.
     * @param {service_categoryFindUniqueArgs} args - Arguments to find a Service_category
     * @example
     * // Get one Service_category
     * const service_category = await prisma.service_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends service_categoryFindUniqueArgs>(args: SelectSubset<T, service_categoryFindUniqueArgs<ExtArgs>>): Prisma__service_categoryClient<$Result.GetResult<Prisma.$service_categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service_category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {service_categoryFindUniqueOrThrowArgs} args - Arguments to find a Service_category
     * @example
     * // Get one Service_category
     * const service_category = await prisma.service_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends service_categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, service_categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__service_categoryClient<$Result.GetResult<Prisma.$service_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_categoryFindFirstArgs} args - Arguments to find a Service_category
     * @example
     * // Get one Service_category
     * const service_category = await prisma.service_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends service_categoryFindFirstArgs>(args?: SelectSubset<T, service_categoryFindFirstArgs<ExtArgs>>): Prisma__service_categoryClient<$Result.GetResult<Prisma.$service_categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service_category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_categoryFindFirstOrThrowArgs} args - Arguments to find a Service_category
     * @example
     * // Get one Service_category
     * const service_category = await prisma.service_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends service_categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, service_categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__service_categoryClient<$Result.GetResult<Prisma.$service_categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Service_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Service_categories
     * const service_categories = await prisma.service_category.findMany()
     * 
     * // Get first 10 Service_categories
     * const service_categories = await prisma.service_category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const service_categoryWithIdOnly = await prisma.service_category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends service_categoryFindManyArgs>(args?: SelectSubset<T, service_categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service_category.
     * @param {service_categoryCreateArgs} args - Arguments to create a Service_category.
     * @example
     * // Create one Service_category
     * const Service_category = await prisma.service_category.create({
     *   data: {
     *     // ... data to create a Service_category
     *   }
     * })
     * 
     */
    create<T extends service_categoryCreateArgs>(args: SelectSubset<T, service_categoryCreateArgs<ExtArgs>>): Prisma__service_categoryClient<$Result.GetResult<Prisma.$service_categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Service_categories.
     * @param {service_categoryCreateManyArgs} args - Arguments to create many Service_categories.
     * @example
     * // Create many Service_categories
     * const service_category = await prisma.service_category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends service_categoryCreateManyArgs>(args?: SelectSubset<T, service_categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Service_categories and returns the data saved in the database.
     * @param {service_categoryCreateManyAndReturnArgs} args - Arguments to create many Service_categories.
     * @example
     * // Create many Service_categories
     * const service_category = await prisma.service_category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Service_categories and only return the `id`
     * const service_categoryWithIdOnly = await prisma.service_category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends service_categoryCreateManyAndReturnArgs>(args?: SelectSubset<T, service_categoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_categoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service_category.
     * @param {service_categoryDeleteArgs} args - Arguments to delete one Service_category.
     * @example
     * // Delete one Service_category
     * const Service_category = await prisma.service_category.delete({
     *   where: {
     *     // ... filter to delete one Service_category
     *   }
     * })
     * 
     */
    delete<T extends service_categoryDeleteArgs>(args: SelectSubset<T, service_categoryDeleteArgs<ExtArgs>>): Prisma__service_categoryClient<$Result.GetResult<Prisma.$service_categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service_category.
     * @param {service_categoryUpdateArgs} args - Arguments to update one Service_category.
     * @example
     * // Update one Service_category
     * const service_category = await prisma.service_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends service_categoryUpdateArgs>(args: SelectSubset<T, service_categoryUpdateArgs<ExtArgs>>): Prisma__service_categoryClient<$Result.GetResult<Prisma.$service_categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Service_categories.
     * @param {service_categoryDeleteManyArgs} args - Arguments to filter Service_categories to delete.
     * @example
     * // Delete a few Service_categories
     * const { count } = await prisma.service_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends service_categoryDeleteManyArgs>(args?: SelectSubset<T, service_categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Service_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Service_categories
     * const service_category = await prisma.service_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends service_categoryUpdateManyArgs>(args: SelectSubset<T, service_categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Service_categories and returns the data updated in the database.
     * @param {service_categoryUpdateManyAndReturnArgs} args - Arguments to update many Service_categories.
     * @example
     * // Update many Service_categories
     * const service_category = await prisma.service_category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Service_categories and only return the `id`
     * const service_categoryWithIdOnly = await prisma.service_category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends service_categoryUpdateManyAndReturnArgs>(args: SelectSubset<T, service_categoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_categoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service_category.
     * @param {service_categoryUpsertArgs} args - Arguments to update or create a Service_category.
     * @example
     * // Update or create a Service_category
     * const service_category = await prisma.service_category.upsert({
     *   create: {
     *     // ... data to create a Service_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service_category we want to update
     *   }
     * })
     */
    upsert<T extends service_categoryUpsertArgs>(args: SelectSubset<T, service_categoryUpsertArgs<ExtArgs>>): Prisma__service_categoryClient<$Result.GetResult<Prisma.$service_categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Service_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_categoryCountArgs} args - Arguments to filter Service_categories to count.
     * @example
     * // Count the number of Service_categories
     * const count = await prisma.service_category.count({
     *   where: {
     *     // ... the filter for the Service_categories we want to count
     *   }
     * })
    **/
    count<T extends service_categoryCountArgs>(
      args?: Subset<T, service_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Service_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Service_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Service_categoryAggregateArgs>(args: Subset<T, Service_categoryAggregateArgs>): Prisma.PrismaPromise<GetService_categoryAggregateType<T>>

    /**
     * Group by Service_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends service_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: service_categoryGroupByArgs['orderBy'] }
        : { orderBy?: service_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, service_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetService_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the service_category model
   */
  readonly fields: service_categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for service_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__service_categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends service_category$serviceArgs<ExtArgs> = {}>(args?: Subset<T, service_category$serviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the service_category model
   */
  interface service_categoryFieldRefs {
    readonly id: FieldRef<"service_category", 'String'>
    readonly name: FieldRef<"service_category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * service_category findUnique
   */
  export type service_categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_category
     */
    select?: service_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_category
     */
    omit?: service_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoryInclude<ExtArgs> | null
    /**
     * Filter, which service_category to fetch.
     */
    where: service_categoryWhereUniqueInput
  }

  /**
   * service_category findUniqueOrThrow
   */
  export type service_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_category
     */
    select?: service_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_category
     */
    omit?: service_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoryInclude<ExtArgs> | null
    /**
     * Filter, which service_category to fetch.
     */
    where: service_categoryWhereUniqueInput
  }

  /**
   * service_category findFirst
   */
  export type service_categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_category
     */
    select?: service_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_category
     */
    omit?: service_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoryInclude<ExtArgs> | null
    /**
     * Filter, which service_category to fetch.
     */
    where?: service_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_categories to fetch.
     */
    orderBy?: service_categoryOrderByWithRelationInput | service_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_categories.
     */
    cursor?: service_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_categories.
     */
    distinct?: Service_categoryScalarFieldEnum | Service_categoryScalarFieldEnum[]
  }

  /**
   * service_category findFirstOrThrow
   */
  export type service_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_category
     */
    select?: service_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_category
     */
    omit?: service_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoryInclude<ExtArgs> | null
    /**
     * Filter, which service_category to fetch.
     */
    where?: service_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_categories to fetch.
     */
    orderBy?: service_categoryOrderByWithRelationInput | service_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_categories.
     */
    cursor?: service_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_categories.
     */
    distinct?: Service_categoryScalarFieldEnum | Service_categoryScalarFieldEnum[]
  }

  /**
   * service_category findMany
   */
  export type service_categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_category
     */
    select?: service_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_category
     */
    omit?: service_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoryInclude<ExtArgs> | null
    /**
     * Filter, which service_categories to fetch.
     */
    where?: service_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_categories to fetch.
     */
    orderBy?: service_categoryOrderByWithRelationInput | service_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing service_categories.
     */
    cursor?: service_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_categories.
     */
    skip?: number
    distinct?: Service_categoryScalarFieldEnum | Service_categoryScalarFieldEnum[]
  }

  /**
   * service_category create
   */
  export type service_categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_category
     */
    select?: service_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_category
     */
    omit?: service_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a service_category.
     */
    data: XOR<service_categoryCreateInput, service_categoryUncheckedCreateInput>
  }

  /**
   * service_category createMany
   */
  export type service_categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many service_categories.
     */
    data: service_categoryCreateManyInput | service_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * service_category createManyAndReturn
   */
  export type service_categoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_category
     */
    select?: service_categorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the service_category
     */
    omit?: service_categoryOmit<ExtArgs> | null
    /**
     * The data used to create many service_categories.
     */
    data: service_categoryCreateManyInput | service_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * service_category update
   */
  export type service_categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_category
     */
    select?: service_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_category
     */
    omit?: service_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a service_category.
     */
    data: XOR<service_categoryUpdateInput, service_categoryUncheckedUpdateInput>
    /**
     * Choose, which service_category to update.
     */
    where: service_categoryWhereUniqueInput
  }

  /**
   * service_category updateMany
   */
  export type service_categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update service_categories.
     */
    data: XOR<service_categoryUpdateManyMutationInput, service_categoryUncheckedUpdateManyInput>
    /**
     * Filter which service_categories to update
     */
    where?: service_categoryWhereInput
    /**
     * Limit how many service_categories to update.
     */
    limit?: number
  }

  /**
   * service_category updateManyAndReturn
   */
  export type service_categoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_category
     */
    select?: service_categorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the service_category
     */
    omit?: service_categoryOmit<ExtArgs> | null
    /**
     * The data used to update service_categories.
     */
    data: XOR<service_categoryUpdateManyMutationInput, service_categoryUncheckedUpdateManyInput>
    /**
     * Filter which service_categories to update
     */
    where?: service_categoryWhereInput
    /**
     * Limit how many service_categories to update.
     */
    limit?: number
  }

  /**
   * service_category upsert
   */
  export type service_categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_category
     */
    select?: service_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_category
     */
    omit?: service_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the service_category to update in case it exists.
     */
    where: service_categoryWhereUniqueInput
    /**
     * In case the service_category found by the `where` argument doesn't exist, create a new service_category with this data.
     */
    create: XOR<service_categoryCreateInput, service_categoryUncheckedCreateInput>
    /**
     * In case the service_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<service_categoryUpdateInput, service_categoryUncheckedUpdateInput>
  }

  /**
   * service_category delete
   */
  export type service_categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_category
     */
    select?: service_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_category
     */
    omit?: service_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoryInclude<ExtArgs> | null
    /**
     * Filter which service_category to delete.
     */
    where: service_categoryWhereUniqueInput
  }

  /**
   * service_category deleteMany
   */
  export type service_categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_categories to delete
     */
    where?: service_categoryWhereInput
    /**
     * Limit how many service_categories to delete.
     */
    limit?: number
  }

  /**
   * service_category.service
   */
  export type service_category$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    where?: serviceWhereInput
    orderBy?: serviceOrderByWithRelationInput | serviceOrderByWithRelationInput[]
    cursor?: serviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * service_category without action
   */
  export type service_categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_category
     */
    select?: service_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_category
     */
    omit?: service_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoryInclude<ExtArgs> | null
  }


  /**
   * Model service_usage
   */

  export type AggregateService_usage = {
    _count: Service_usageCountAggregateOutputType | null
    _min: Service_usageMinAggregateOutputType | null
    _max: Service_usageMaxAggregateOutputType | null
  }

  export type Service_usageMinAggregateOutputType = {
    id: string | null
    client_id: string | null
    service_id: string | null
    start_date: Date | null
    end_date: Date | null
    usage: string | null
    created: Date | null
    status: string | null
  }

  export type Service_usageMaxAggregateOutputType = {
    id: string | null
    client_id: string | null
    service_id: string | null
    start_date: Date | null
    end_date: Date | null
    usage: string | null
    created: Date | null
    status: string | null
  }

  export type Service_usageCountAggregateOutputType = {
    id: number
    client_id: number
    service_id: number
    start_date: number
    end_date: number
    usage: number
    created: number
    status: number
    _all: number
  }


  export type Service_usageMinAggregateInputType = {
    id?: true
    client_id?: true
    service_id?: true
    start_date?: true
    end_date?: true
    usage?: true
    created?: true
    status?: true
  }

  export type Service_usageMaxAggregateInputType = {
    id?: true
    client_id?: true
    service_id?: true
    start_date?: true
    end_date?: true
    usage?: true
    created?: true
    status?: true
  }

  export type Service_usageCountAggregateInputType = {
    id?: true
    client_id?: true
    service_id?: true
    start_date?: true
    end_date?: true
    usage?: true
    created?: true
    status?: true
    _all?: true
  }

  export type Service_usageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_usage to aggregate.
     */
    where?: service_usageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_usages to fetch.
     */
    orderBy?: service_usageOrderByWithRelationInput | service_usageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: service_usageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_usages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_usages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned service_usages
    **/
    _count?: true | Service_usageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Service_usageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Service_usageMaxAggregateInputType
  }

  export type GetService_usageAggregateType<T extends Service_usageAggregateArgs> = {
        [P in keyof T & keyof AggregateService_usage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService_usage[P]>
      : GetScalarType<T[P], AggregateService_usage[P]>
  }




  export type service_usageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: service_usageWhereInput
    orderBy?: service_usageOrderByWithAggregationInput | service_usageOrderByWithAggregationInput[]
    by: Service_usageScalarFieldEnum[] | Service_usageScalarFieldEnum
    having?: service_usageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Service_usageCountAggregateInputType | true
    _min?: Service_usageMinAggregateInputType
    _max?: Service_usageMaxAggregateInputType
  }

  export type Service_usageGroupByOutputType = {
    id: string
    client_id: string | null
    service_id: string | null
    start_date: Date | null
    end_date: Date | null
    usage: string | null
    created: Date | null
    status: string | null
    _count: Service_usageCountAggregateOutputType | null
    _min: Service_usageMinAggregateOutputType | null
    _max: Service_usageMaxAggregateOutputType | null
  }

  type GetService_usageGroupByPayload<T extends service_usageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Service_usageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Service_usageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Service_usageGroupByOutputType[P]>
            : GetScalarType<T[P], Service_usageGroupByOutputType[P]>
        }
      >
    >


  export type service_usageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    service_id?: boolean
    start_date?: boolean
    end_date?: boolean
    usage?: boolean
    created?: boolean
    status?: boolean
    client?: boolean | service_usage$clientArgs<ExtArgs>
    service?: boolean | service_usage$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["service_usage"]>

  export type service_usageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    service_id?: boolean
    start_date?: boolean
    end_date?: boolean
    usage?: boolean
    created?: boolean
    status?: boolean
    client?: boolean | service_usage$clientArgs<ExtArgs>
    service?: boolean | service_usage$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["service_usage"]>

  export type service_usageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    service_id?: boolean
    start_date?: boolean
    end_date?: boolean
    usage?: boolean
    created?: boolean
    status?: boolean
    client?: boolean | service_usage$clientArgs<ExtArgs>
    service?: boolean | service_usage$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["service_usage"]>

  export type service_usageSelectScalar = {
    id?: boolean
    client_id?: boolean
    service_id?: boolean
    start_date?: boolean
    end_date?: boolean
    usage?: boolean
    created?: boolean
    status?: boolean
  }

  export type service_usageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "client_id" | "service_id" | "start_date" | "end_date" | "usage" | "created" | "status", ExtArgs["result"]["service_usage"]>
  export type service_usageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | service_usage$clientArgs<ExtArgs>
    service?: boolean | service_usage$serviceArgs<ExtArgs>
  }
  export type service_usageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | service_usage$clientArgs<ExtArgs>
    service?: boolean | service_usage$serviceArgs<ExtArgs>
  }
  export type service_usageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | service_usage$clientArgs<ExtArgs>
    service?: boolean | service_usage$serviceArgs<ExtArgs>
  }

  export type $service_usagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "service_usage"
    objects: {
      client: Prisma.$clientPayload<ExtArgs> | null
      service: Prisma.$servicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      client_id: string | null
      service_id: string | null
      start_date: Date | null
      end_date: Date | null
      usage: string | null
      created: Date | null
      status: string | null
    }, ExtArgs["result"]["service_usage"]>
    composites: {}
  }

  type service_usageGetPayload<S extends boolean | null | undefined | service_usageDefaultArgs> = $Result.GetResult<Prisma.$service_usagePayload, S>

  type service_usageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<service_usageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Service_usageCountAggregateInputType | true
    }

  export interface service_usageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['service_usage'], meta: { name: 'service_usage' } }
    /**
     * Find zero or one Service_usage that matches the filter.
     * @param {service_usageFindUniqueArgs} args - Arguments to find a Service_usage
     * @example
     * // Get one Service_usage
     * const service_usage = await prisma.service_usage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends service_usageFindUniqueArgs>(args: SelectSubset<T, service_usageFindUniqueArgs<ExtArgs>>): Prisma__service_usageClient<$Result.GetResult<Prisma.$service_usagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service_usage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {service_usageFindUniqueOrThrowArgs} args - Arguments to find a Service_usage
     * @example
     * // Get one Service_usage
     * const service_usage = await prisma.service_usage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends service_usageFindUniqueOrThrowArgs>(args: SelectSubset<T, service_usageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__service_usageClient<$Result.GetResult<Prisma.$service_usagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service_usage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_usageFindFirstArgs} args - Arguments to find a Service_usage
     * @example
     * // Get one Service_usage
     * const service_usage = await prisma.service_usage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends service_usageFindFirstArgs>(args?: SelectSubset<T, service_usageFindFirstArgs<ExtArgs>>): Prisma__service_usageClient<$Result.GetResult<Prisma.$service_usagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service_usage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_usageFindFirstOrThrowArgs} args - Arguments to find a Service_usage
     * @example
     * // Get one Service_usage
     * const service_usage = await prisma.service_usage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends service_usageFindFirstOrThrowArgs>(args?: SelectSubset<T, service_usageFindFirstOrThrowArgs<ExtArgs>>): Prisma__service_usageClient<$Result.GetResult<Prisma.$service_usagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Service_usages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_usageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Service_usages
     * const service_usages = await prisma.service_usage.findMany()
     * 
     * // Get first 10 Service_usages
     * const service_usages = await prisma.service_usage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const service_usageWithIdOnly = await prisma.service_usage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends service_usageFindManyArgs>(args?: SelectSubset<T, service_usageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_usagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service_usage.
     * @param {service_usageCreateArgs} args - Arguments to create a Service_usage.
     * @example
     * // Create one Service_usage
     * const Service_usage = await prisma.service_usage.create({
     *   data: {
     *     // ... data to create a Service_usage
     *   }
     * })
     * 
     */
    create<T extends service_usageCreateArgs>(args: SelectSubset<T, service_usageCreateArgs<ExtArgs>>): Prisma__service_usageClient<$Result.GetResult<Prisma.$service_usagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Service_usages.
     * @param {service_usageCreateManyArgs} args - Arguments to create many Service_usages.
     * @example
     * // Create many Service_usages
     * const service_usage = await prisma.service_usage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends service_usageCreateManyArgs>(args?: SelectSubset<T, service_usageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Service_usages and returns the data saved in the database.
     * @param {service_usageCreateManyAndReturnArgs} args - Arguments to create many Service_usages.
     * @example
     * // Create many Service_usages
     * const service_usage = await prisma.service_usage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Service_usages and only return the `id`
     * const service_usageWithIdOnly = await prisma.service_usage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends service_usageCreateManyAndReturnArgs>(args?: SelectSubset<T, service_usageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_usagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service_usage.
     * @param {service_usageDeleteArgs} args - Arguments to delete one Service_usage.
     * @example
     * // Delete one Service_usage
     * const Service_usage = await prisma.service_usage.delete({
     *   where: {
     *     // ... filter to delete one Service_usage
     *   }
     * })
     * 
     */
    delete<T extends service_usageDeleteArgs>(args: SelectSubset<T, service_usageDeleteArgs<ExtArgs>>): Prisma__service_usageClient<$Result.GetResult<Prisma.$service_usagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service_usage.
     * @param {service_usageUpdateArgs} args - Arguments to update one Service_usage.
     * @example
     * // Update one Service_usage
     * const service_usage = await prisma.service_usage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends service_usageUpdateArgs>(args: SelectSubset<T, service_usageUpdateArgs<ExtArgs>>): Prisma__service_usageClient<$Result.GetResult<Prisma.$service_usagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Service_usages.
     * @param {service_usageDeleteManyArgs} args - Arguments to filter Service_usages to delete.
     * @example
     * // Delete a few Service_usages
     * const { count } = await prisma.service_usage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends service_usageDeleteManyArgs>(args?: SelectSubset<T, service_usageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Service_usages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_usageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Service_usages
     * const service_usage = await prisma.service_usage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends service_usageUpdateManyArgs>(args: SelectSubset<T, service_usageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Service_usages and returns the data updated in the database.
     * @param {service_usageUpdateManyAndReturnArgs} args - Arguments to update many Service_usages.
     * @example
     * // Update many Service_usages
     * const service_usage = await prisma.service_usage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Service_usages and only return the `id`
     * const service_usageWithIdOnly = await prisma.service_usage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends service_usageUpdateManyAndReturnArgs>(args: SelectSubset<T, service_usageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_usagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service_usage.
     * @param {service_usageUpsertArgs} args - Arguments to update or create a Service_usage.
     * @example
     * // Update or create a Service_usage
     * const service_usage = await prisma.service_usage.upsert({
     *   create: {
     *     // ... data to create a Service_usage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service_usage we want to update
     *   }
     * })
     */
    upsert<T extends service_usageUpsertArgs>(args: SelectSubset<T, service_usageUpsertArgs<ExtArgs>>): Prisma__service_usageClient<$Result.GetResult<Prisma.$service_usagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Service_usages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_usageCountArgs} args - Arguments to filter Service_usages to count.
     * @example
     * // Count the number of Service_usages
     * const count = await prisma.service_usage.count({
     *   where: {
     *     // ... the filter for the Service_usages we want to count
     *   }
     * })
    **/
    count<T extends service_usageCountArgs>(
      args?: Subset<T, service_usageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Service_usageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service_usage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Service_usageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Service_usageAggregateArgs>(args: Subset<T, Service_usageAggregateArgs>): Prisma.PrismaPromise<GetService_usageAggregateType<T>>

    /**
     * Group by Service_usage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_usageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends service_usageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: service_usageGroupByArgs['orderBy'] }
        : { orderBy?: service_usageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, service_usageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetService_usageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the service_usage model
   */
  readonly fields: service_usageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for service_usage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__service_usageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends service_usage$clientArgs<ExtArgs> = {}>(args?: Subset<T, service_usage$clientArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    service<T extends service_usage$serviceArgs<ExtArgs> = {}>(args?: Subset<T, service_usage$serviceArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the service_usage model
   */
  interface service_usageFieldRefs {
    readonly id: FieldRef<"service_usage", 'String'>
    readonly client_id: FieldRef<"service_usage", 'String'>
    readonly service_id: FieldRef<"service_usage", 'String'>
    readonly start_date: FieldRef<"service_usage", 'DateTime'>
    readonly end_date: FieldRef<"service_usage", 'DateTime'>
    readonly usage: FieldRef<"service_usage", 'String'>
    readonly created: FieldRef<"service_usage", 'DateTime'>
    readonly status: FieldRef<"service_usage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * service_usage findUnique
   */
  export type service_usageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage
     */
    select?: service_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_usage
     */
    omit?: service_usageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usageInclude<ExtArgs> | null
    /**
     * Filter, which service_usage to fetch.
     */
    where: service_usageWhereUniqueInput
  }

  /**
   * service_usage findUniqueOrThrow
   */
  export type service_usageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage
     */
    select?: service_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_usage
     */
    omit?: service_usageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usageInclude<ExtArgs> | null
    /**
     * Filter, which service_usage to fetch.
     */
    where: service_usageWhereUniqueInput
  }

  /**
   * service_usage findFirst
   */
  export type service_usageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage
     */
    select?: service_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_usage
     */
    omit?: service_usageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usageInclude<ExtArgs> | null
    /**
     * Filter, which service_usage to fetch.
     */
    where?: service_usageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_usages to fetch.
     */
    orderBy?: service_usageOrderByWithRelationInput | service_usageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_usages.
     */
    cursor?: service_usageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_usages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_usages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_usages.
     */
    distinct?: Service_usageScalarFieldEnum | Service_usageScalarFieldEnum[]
  }

  /**
   * service_usage findFirstOrThrow
   */
  export type service_usageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage
     */
    select?: service_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_usage
     */
    omit?: service_usageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usageInclude<ExtArgs> | null
    /**
     * Filter, which service_usage to fetch.
     */
    where?: service_usageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_usages to fetch.
     */
    orderBy?: service_usageOrderByWithRelationInput | service_usageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_usages.
     */
    cursor?: service_usageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_usages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_usages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_usages.
     */
    distinct?: Service_usageScalarFieldEnum | Service_usageScalarFieldEnum[]
  }

  /**
   * service_usage findMany
   */
  export type service_usageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage
     */
    select?: service_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_usage
     */
    omit?: service_usageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usageInclude<ExtArgs> | null
    /**
     * Filter, which service_usages to fetch.
     */
    where?: service_usageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_usages to fetch.
     */
    orderBy?: service_usageOrderByWithRelationInput | service_usageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing service_usages.
     */
    cursor?: service_usageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_usages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_usages.
     */
    skip?: number
    distinct?: Service_usageScalarFieldEnum | Service_usageScalarFieldEnum[]
  }

  /**
   * service_usage create
   */
  export type service_usageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage
     */
    select?: service_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_usage
     */
    omit?: service_usageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usageInclude<ExtArgs> | null
    /**
     * The data needed to create a service_usage.
     */
    data: XOR<service_usageCreateInput, service_usageUncheckedCreateInput>
  }

  /**
   * service_usage createMany
   */
  export type service_usageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many service_usages.
     */
    data: service_usageCreateManyInput | service_usageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * service_usage createManyAndReturn
   */
  export type service_usageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage
     */
    select?: service_usageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the service_usage
     */
    omit?: service_usageOmit<ExtArgs> | null
    /**
     * The data used to create many service_usages.
     */
    data: service_usageCreateManyInput | service_usageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * service_usage update
   */
  export type service_usageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage
     */
    select?: service_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_usage
     */
    omit?: service_usageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usageInclude<ExtArgs> | null
    /**
     * The data needed to update a service_usage.
     */
    data: XOR<service_usageUpdateInput, service_usageUncheckedUpdateInput>
    /**
     * Choose, which service_usage to update.
     */
    where: service_usageWhereUniqueInput
  }

  /**
   * service_usage updateMany
   */
  export type service_usageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update service_usages.
     */
    data: XOR<service_usageUpdateManyMutationInput, service_usageUncheckedUpdateManyInput>
    /**
     * Filter which service_usages to update
     */
    where?: service_usageWhereInput
    /**
     * Limit how many service_usages to update.
     */
    limit?: number
  }

  /**
   * service_usage updateManyAndReturn
   */
  export type service_usageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage
     */
    select?: service_usageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the service_usage
     */
    omit?: service_usageOmit<ExtArgs> | null
    /**
     * The data used to update service_usages.
     */
    data: XOR<service_usageUpdateManyMutationInput, service_usageUncheckedUpdateManyInput>
    /**
     * Filter which service_usages to update
     */
    where?: service_usageWhereInput
    /**
     * Limit how many service_usages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * service_usage upsert
   */
  export type service_usageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage
     */
    select?: service_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_usage
     */
    omit?: service_usageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usageInclude<ExtArgs> | null
    /**
     * The filter to search for the service_usage to update in case it exists.
     */
    where: service_usageWhereUniqueInput
    /**
     * In case the service_usage found by the `where` argument doesn't exist, create a new service_usage with this data.
     */
    create: XOR<service_usageCreateInput, service_usageUncheckedCreateInput>
    /**
     * In case the service_usage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<service_usageUpdateInput, service_usageUncheckedUpdateInput>
  }

  /**
   * service_usage delete
   */
  export type service_usageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage
     */
    select?: service_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_usage
     */
    omit?: service_usageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usageInclude<ExtArgs> | null
    /**
     * Filter which service_usage to delete.
     */
    where: service_usageWhereUniqueInput
  }

  /**
   * service_usage deleteMany
   */
  export type service_usageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_usages to delete
     */
    where?: service_usageWhereInput
    /**
     * Limit how many service_usages to delete.
     */
    limit?: number
  }

  /**
   * service_usage.client
   */
  export type service_usage$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    where?: clientWhereInput
  }

  /**
   * service_usage.service
   */
  export type service_usage$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    where?: serviceWhereInput
  }

  /**
   * service_usage without action
   */
  export type service_usageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage
     */
    select?: service_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_usage
     */
    omit?: service_usageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usageInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    role_id: string | null
    client_id: string | null
    user: string | null
    pass: string | null
    name: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    role_id: string | null
    client_id: string | null
    user: string | null
    pass: string | null
    name: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    role_id: number
    client_id: number
    user: number
    pass: number
    name: number
    created: number
    updated: number
    status: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    role_id?: true
    client_id?: true
    user?: true
    pass?: true
    name?: true
    created?: true
    updated?: true
    status?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    role_id?: true
    client_id?: true
    user?: true
    pass?: true
    name?: true
    created?: true
    updated?: true
    status?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    role_id?: true
    client_id?: true
    user?: true
    pass?: true
    name?: true
    created?: true
    updated?: true
    status?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    role_id: string | null
    client_id: string | null
    user: string | null
    pass: string | null
    name: string | null
    created: Date | null
    updated: Date | null
    status: boolean | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_id?: boolean
    client_id?: boolean
    user?: boolean
    pass?: boolean
    name?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    log?: boolean | user$logArgs<ExtArgs>
    client?: boolean | user$clientArgs<ExtArgs>
    role?: boolean | user$roleArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_id?: boolean
    client_id?: boolean
    user?: boolean
    pass?: boolean
    name?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    client?: boolean | user$clientArgs<ExtArgs>
    role?: boolean | user$roleArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_id?: boolean
    client_id?: boolean
    user?: boolean
    pass?: boolean
    name?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
    client?: boolean | user$clientArgs<ExtArgs>
    role?: boolean | user$roleArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    role_id?: boolean
    client_id?: boolean
    user?: boolean
    pass?: boolean
    name?: boolean
    created?: boolean
    updated?: boolean
    status?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role_id" | "client_id" | "user" | "pass" | "name" | "created" | "updated" | "status", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    log?: boolean | user$logArgs<ExtArgs>
    client?: boolean | user$clientArgs<ExtArgs>
    role?: boolean | user$roleArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | user$clientArgs<ExtArgs>
    role?: boolean | user$roleArgs<ExtArgs>
  }
  export type userIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | user$clientArgs<ExtArgs>
    role?: boolean | user$roleArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      log: Prisma.$logPayload<ExtArgs>[]
      client: Prisma.$clientPayload<ExtArgs> | null
      role: Prisma.$rolePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role_id: string | null
      client_id: string | null
      user: string | null
      pass: string | null
      name: string | null
      created: Date | null
      updated: Date | null
      status: boolean | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {userCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userCreateManyAndReturnArgs>(args?: SelectSubset<T, userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {userUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userUpdateManyAndReturnArgs>(args: SelectSubset<T, userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    log<T extends user$logArgs<ExtArgs> = {}>(args?: Subset<T, user$logArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    client<T extends user$clientArgs<ExtArgs> = {}>(args?: Subset<T, user$clientArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    role<T extends user$roleArgs<ExtArgs> = {}>(args?: Subset<T, user$roleArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'String'>
    readonly role_id: FieldRef<"user", 'String'>
    readonly client_id: FieldRef<"user", 'String'>
    readonly user: FieldRef<"user", 'String'>
    readonly pass: FieldRef<"user", 'String'>
    readonly name: FieldRef<"user", 'String'>
    readonly created: FieldRef<"user", 'DateTime'>
    readonly updated: FieldRef<"user", 'DateTime'>
    readonly status: FieldRef<"user", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user createManyAndReturn
   */
  export type userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user updateManyAndReturn
   */
  export type userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.log
   */
  export type user$logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the log
     */
    omit?: logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logInclude<ExtArgs> | null
    where?: logWhereInput
    orderBy?: logOrderByWithRelationInput | logOrderByWithRelationInput[]
    cursor?: logWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * user.client
   */
  export type user$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    where?: clientWhereInput
  }

  /**
   * user.role
   */
  export type user$roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    where?: roleWhereInput
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created: 'created',
    updated: 'updated',
    status: 'status'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const Client_detailsScalarFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    c_parameter_id: 'c_parameter_id',
    value: 'value'
  };

  export type Client_detailsScalarFieldEnum = (typeof Client_detailsScalarFieldEnum)[keyof typeof Client_detailsScalarFieldEnum]


  export const Client_parameterScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Client_parameterScalarFieldEnum = (typeof Client_parameterScalarFieldEnum)[keyof typeof Client_parameterScalarFieldEnum]


  export const Client_serviceScalarFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    service_id: 'service_id',
    created: 'created',
    updated: 'updated',
    started: 'started',
    delivery: 'delivery',
    expiry: 'expiry',
    frequency: 'frequency',
    unit: 'unit',
    url_api: 'url_api',
    token_api: 'token_api'
  };

  export type Client_serviceScalarFieldEnum = (typeof Client_serviceScalarFieldEnum)[keyof typeof Client_serviceScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    description: 'description',
    value: 'value',
    url: 'url',
    created: 'created',
    updated: 'updated',
    status: 'status'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const Invoice_detailScalarFieldEnum: {
    id: 'id',
    invoice_id: 'invoice_id',
    service_id: 'service_id',
    item: 'item',
    quantity: 'quantity',
    total_value: 'total_value',
    created: 'created',
    updated: 'updated',
    status: 'status'
  };

  export type Invoice_detailScalarFieldEnum = (typeof Invoice_detailScalarFieldEnum)[keyof typeof Invoice_detailScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    role_id: 'role_id',
    client_id: 'client_id',
    user_name: 'user_name',
    ip: 'ip',
    type: 'type',
    detail: 'detail',
    created: 'created'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    code: 'code',
    value: 'value',
    status_pay: 'status_pay',
    method: 'method',
    payment_method_id: 'payment_method_id',
    type: 'type',
    url: 'url',
    created: 'created',
    updated: 'updated',
    status: 'status'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const Payment_attachmentScalarFieldEnum: {
    id: 'id',
    invoice_id: 'invoice_id'
  };

  export type Payment_attachmentScalarFieldEnum = (typeof Payment_attachmentScalarFieldEnum)[keyof typeof Payment_attachmentScalarFieldEnum]


  export const Payment_methodScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Payment_methodScalarFieldEnum = (typeof Payment_methodScalarFieldEnum)[keyof typeof Payment_methodScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    section: 'section'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const QuoteScalarFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    description: 'description',
    value: 'value',
    url: 'url',
    created: 'created',
    updated: 'updated',
    status: 'status'
  };

  export type QuoteScalarFieldEnum = (typeof QuoteScalarFieldEnum)[keyof typeof QuoteScalarFieldEnum]


  export const Quote_attachmentScalarFieldEnum: {
    id: 'id',
    quote_id: 'quote_id',
    invoice_id: 'invoice_id'
  };

  export type Quote_attachmentScalarFieldEnum = (typeof Quote_attachmentScalarFieldEnum)[keyof typeof Quote_attachmentScalarFieldEnum]


  export const Quote_detailScalarFieldEnum: {
    id: 'id',
    quote_id: 'quote_id',
    service_id: 'service_id',
    item: 'item',
    quantity: 'quantity',
    total_value: 'total_value',
    created: 'created',
    updated: 'updated',
    status: 'status'
  };

  export type Quote_detailScalarFieldEnum = (typeof Quote_detailScalarFieldEnum)[keyof typeof Quote_detailScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role_category: 'role_category',
    created: 'created',
    updated: 'updated',
    status: 'status',
    description: 'description'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const Role_permissionScalarFieldEnum: {
    id: 'id',
    role_id: 'role_id',
    permission_id: 'permission_id'
  };

  export type Role_permissionScalarFieldEnum = (typeof Role_permissionScalarFieldEnum)[keyof typeof Role_permissionScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    service_category_id: 'service_category_id',
    name: 'name',
    unit: 'unit',
    description: 'description',
    created: 'created',
    updated: 'updated',
    status: 'status'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const Service_categoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Service_categoryScalarFieldEnum = (typeof Service_categoryScalarFieldEnum)[keyof typeof Service_categoryScalarFieldEnum]


  export const Service_usageScalarFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    service_id: 'service_id',
    start_date: 'start_date',
    end_date: 'end_date',
    usage: 'usage',
    created: 'created',
    status: 'status'
  };

  export type Service_usageScalarFieldEnum = (typeof Service_usageScalarFieldEnum)[keyof typeof Service_usageScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    role_id: 'role_id',
    client_id: 'client_id',
    user: 'user',
    pass: 'pass',
    name: 'name',
    created: 'created',
    updated: 'updated',
    status: 'status'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type clientWhereInput = {
    AND?: clientWhereInput | clientWhereInput[]
    OR?: clientWhereInput[]
    NOT?: clientWhereInput | clientWhereInput[]
    id?: UuidFilter<"client"> | string
    name?: StringNullableFilter<"client"> | string | null
    created?: DateTimeNullableFilter<"client"> | Date | string | null
    updated?: DateTimeNullableFilter<"client"> | Date | string | null
    status?: BoolNullableFilter<"client"> | boolean | null
    client_details?: Client_detailsListRelationFilter
    client_service?: Client_serviceListRelationFilter
    invoice?: InvoiceListRelationFilter
    log?: LogListRelationFilter
    payment?: PaymentListRelationFilter
    quote?: QuoteListRelationFilter
    service_usage?: Service_usageListRelationFilter
    user?: UserListRelationFilter
  }

  export type clientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    client_details?: client_detailsOrderByRelationAggregateInput
    client_service?: client_serviceOrderByRelationAggregateInput
    invoice?: invoiceOrderByRelationAggregateInput
    log?: logOrderByRelationAggregateInput
    payment?: paymentOrderByRelationAggregateInput
    quote?: quoteOrderByRelationAggregateInput
    service_usage?: service_usageOrderByRelationAggregateInput
    user?: userOrderByRelationAggregateInput
  }

  export type clientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: clientWhereInput | clientWhereInput[]
    OR?: clientWhereInput[]
    NOT?: clientWhereInput | clientWhereInput[]
    name?: StringNullableFilter<"client"> | string | null
    created?: DateTimeNullableFilter<"client"> | Date | string | null
    updated?: DateTimeNullableFilter<"client"> | Date | string | null
    status?: BoolNullableFilter<"client"> | boolean | null
    client_details?: Client_detailsListRelationFilter
    client_service?: Client_serviceListRelationFilter
    invoice?: InvoiceListRelationFilter
    log?: LogListRelationFilter
    payment?: PaymentListRelationFilter
    quote?: QuoteListRelationFilter
    service_usage?: Service_usageListRelationFilter
    user?: UserListRelationFilter
  }, "id">

  export type clientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: clientCountOrderByAggregateInput
    _max?: clientMaxOrderByAggregateInput
    _min?: clientMinOrderByAggregateInput
  }

  export type clientScalarWhereWithAggregatesInput = {
    AND?: clientScalarWhereWithAggregatesInput | clientScalarWhereWithAggregatesInput[]
    OR?: clientScalarWhereWithAggregatesInput[]
    NOT?: clientScalarWhereWithAggregatesInput | clientScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"client"> | string
    name?: StringNullableWithAggregatesFilter<"client"> | string | null
    created?: DateTimeNullableWithAggregatesFilter<"client"> | Date | string | null
    updated?: DateTimeNullableWithAggregatesFilter<"client"> | Date | string | null
    status?: BoolNullableWithAggregatesFilter<"client"> | boolean | null
  }

  export type client_detailsWhereInput = {
    AND?: client_detailsWhereInput | client_detailsWhereInput[]
    OR?: client_detailsWhereInput[]
    NOT?: client_detailsWhereInput | client_detailsWhereInput[]
    id?: UuidFilter<"client_details"> | string
    client_id?: UuidNullableFilter<"client_details"> | string | null
    c_parameter_id?: UuidNullableFilter<"client_details"> | string | null
    value?: StringNullableFilter<"client_details"> | string | null
    client_parameter?: XOR<Client_parameterNullableScalarRelationFilter, client_parameterWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, clientWhereInput> | null
  }

  export type client_detailsOrderByWithRelationInput = {
    id?: SortOrder
    client_id?: SortOrderInput | SortOrder
    c_parameter_id?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    client_parameter?: client_parameterOrderByWithRelationInput
    client?: clientOrderByWithRelationInput
  }

  export type client_detailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: client_detailsWhereInput | client_detailsWhereInput[]
    OR?: client_detailsWhereInput[]
    NOT?: client_detailsWhereInput | client_detailsWhereInput[]
    client_id?: UuidNullableFilter<"client_details"> | string | null
    c_parameter_id?: UuidNullableFilter<"client_details"> | string | null
    value?: StringNullableFilter<"client_details"> | string | null
    client_parameter?: XOR<Client_parameterNullableScalarRelationFilter, client_parameterWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, clientWhereInput> | null
  }, "id">

  export type client_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    client_id?: SortOrderInput | SortOrder
    c_parameter_id?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    _count?: client_detailsCountOrderByAggregateInput
    _max?: client_detailsMaxOrderByAggregateInput
    _min?: client_detailsMinOrderByAggregateInput
  }

  export type client_detailsScalarWhereWithAggregatesInput = {
    AND?: client_detailsScalarWhereWithAggregatesInput | client_detailsScalarWhereWithAggregatesInput[]
    OR?: client_detailsScalarWhereWithAggregatesInput[]
    NOT?: client_detailsScalarWhereWithAggregatesInput | client_detailsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"client_details"> | string
    client_id?: UuidNullableWithAggregatesFilter<"client_details"> | string | null
    c_parameter_id?: UuidNullableWithAggregatesFilter<"client_details"> | string | null
    value?: StringNullableWithAggregatesFilter<"client_details"> | string | null
  }

  export type client_parameterWhereInput = {
    AND?: client_parameterWhereInput | client_parameterWhereInput[]
    OR?: client_parameterWhereInput[]
    NOT?: client_parameterWhereInput | client_parameterWhereInput[]
    id?: UuidFilter<"client_parameter"> | string
    name?: StringNullableFilter<"client_parameter"> | string | null
    client_details?: Client_detailsListRelationFilter
  }

  export type client_parameterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    client_details?: client_detailsOrderByRelationAggregateInput
  }

  export type client_parameterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: client_parameterWhereInput | client_parameterWhereInput[]
    OR?: client_parameterWhereInput[]
    NOT?: client_parameterWhereInput | client_parameterWhereInput[]
    name?: StringNullableFilter<"client_parameter"> | string | null
    client_details?: Client_detailsListRelationFilter
  }, "id">

  export type client_parameterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    _count?: client_parameterCountOrderByAggregateInput
    _max?: client_parameterMaxOrderByAggregateInput
    _min?: client_parameterMinOrderByAggregateInput
  }

  export type client_parameterScalarWhereWithAggregatesInput = {
    AND?: client_parameterScalarWhereWithAggregatesInput | client_parameterScalarWhereWithAggregatesInput[]
    OR?: client_parameterScalarWhereWithAggregatesInput[]
    NOT?: client_parameterScalarWhereWithAggregatesInput | client_parameterScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"client_parameter"> | string
    name?: StringNullableWithAggregatesFilter<"client_parameter"> | string | null
  }

  export type client_serviceWhereInput = {
    AND?: client_serviceWhereInput | client_serviceWhereInput[]
    OR?: client_serviceWhereInput[]
    NOT?: client_serviceWhereInput | client_serviceWhereInput[]
    id?: UuidFilter<"client_service"> | string
    client_id?: UuidNullableFilter<"client_service"> | string | null
    service_id?: UuidNullableFilter<"client_service"> | string | null
    created?: DateTimeNullableFilter<"client_service"> | Date | string | null
    updated?: DateTimeNullableFilter<"client_service"> | Date | string | null
    started?: DateTimeNullableFilter<"client_service"> | Date | string | null
    delivery?: DateTimeNullableFilter<"client_service"> | Date | string | null
    expiry?: DateTimeNullableFilter<"client_service"> | Date | string | null
    frequency?: StringNullableFilter<"client_service"> | string | null
    unit?: StringNullableFilter<"client_service"> | string | null
    url_api?: StringNullableFilter<"client_service"> | string | null
    token_api?: StringNullableFilter<"client_service"> | string | null
    client?: XOR<ClientNullableScalarRelationFilter, clientWhereInput> | null
    service?: XOR<ServiceNullableScalarRelationFilter, serviceWhereInput> | null
  }

  export type client_serviceOrderByWithRelationInput = {
    id?: SortOrder
    client_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    started?: SortOrderInput | SortOrder
    delivery?: SortOrderInput | SortOrder
    expiry?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    url_api?: SortOrderInput | SortOrder
    token_api?: SortOrderInput | SortOrder
    client?: clientOrderByWithRelationInput
    service?: serviceOrderByWithRelationInput
  }

  export type client_serviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: client_serviceWhereInput | client_serviceWhereInput[]
    OR?: client_serviceWhereInput[]
    NOT?: client_serviceWhereInput | client_serviceWhereInput[]
    client_id?: UuidNullableFilter<"client_service"> | string | null
    service_id?: UuidNullableFilter<"client_service"> | string | null
    created?: DateTimeNullableFilter<"client_service"> | Date | string | null
    updated?: DateTimeNullableFilter<"client_service"> | Date | string | null
    started?: DateTimeNullableFilter<"client_service"> | Date | string | null
    delivery?: DateTimeNullableFilter<"client_service"> | Date | string | null
    expiry?: DateTimeNullableFilter<"client_service"> | Date | string | null
    frequency?: StringNullableFilter<"client_service"> | string | null
    unit?: StringNullableFilter<"client_service"> | string | null
    url_api?: StringNullableFilter<"client_service"> | string | null
    token_api?: StringNullableFilter<"client_service"> | string | null
    client?: XOR<ClientNullableScalarRelationFilter, clientWhereInput> | null
    service?: XOR<ServiceNullableScalarRelationFilter, serviceWhereInput> | null
  }, "id">

  export type client_serviceOrderByWithAggregationInput = {
    id?: SortOrder
    client_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    started?: SortOrderInput | SortOrder
    delivery?: SortOrderInput | SortOrder
    expiry?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    url_api?: SortOrderInput | SortOrder
    token_api?: SortOrderInput | SortOrder
    _count?: client_serviceCountOrderByAggregateInput
    _max?: client_serviceMaxOrderByAggregateInput
    _min?: client_serviceMinOrderByAggregateInput
  }

  export type client_serviceScalarWhereWithAggregatesInput = {
    AND?: client_serviceScalarWhereWithAggregatesInput | client_serviceScalarWhereWithAggregatesInput[]
    OR?: client_serviceScalarWhereWithAggregatesInput[]
    NOT?: client_serviceScalarWhereWithAggregatesInput | client_serviceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"client_service"> | string
    client_id?: UuidNullableWithAggregatesFilter<"client_service"> | string | null
    service_id?: UuidNullableWithAggregatesFilter<"client_service"> | string | null
    created?: DateTimeNullableWithAggregatesFilter<"client_service"> | Date | string | null
    updated?: DateTimeNullableWithAggregatesFilter<"client_service"> | Date | string | null
    started?: DateTimeNullableWithAggregatesFilter<"client_service"> | Date | string | null
    delivery?: DateTimeNullableWithAggregatesFilter<"client_service"> | Date | string | null
    expiry?: DateTimeNullableWithAggregatesFilter<"client_service"> | Date | string | null
    frequency?: StringNullableWithAggregatesFilter<"client_service"> | string | null
    unit?: StringNullableWithAggregatesFilter<"client_service"> | string | null
    url_api?: StringNullableWithAggregatesFilter<"client_service"> | string | null
    token_api?: StringNullableWithAggregatesFilter<"client_service"> | string | null
  }

  export type invoiceWhereInput = {
    AND?: invoiceWhereInput | invoiceWhereInput[]
    OR?: invoiceWhereInput[]
    NOT?: invoiceWhereInput | invoiceWhereInput[]
    id?: UuidFilter<"invoice"> | string
    client_id?: UuidNullableFilter<"invoice"> | string | null
    description?: StringNullableFilter<"invoice"> | string | null
    value?: StringNullableFilter<"invoice"> | string | null
    url?: StringNullableFilter<"invoice"> | string | null
    created?: DateTimeNullableFilter<"invoice"> | Date | string | null
    updated?: DateTimeNullableFilter<"invoice"> | Date | string | null
    status?: BoolNullableFilter<"invoice"> | boolean | null
    client?: XOR<ClientNullableScalarRelationFilter, clientWhereInput> | null
    invoice_detail?: Invoice_detailListRelationFilter
    payment_attachment?: Payment_attachmentListRelationFilter
    quote_attachment?: Quote_attachmentListRelationFilter
  }

  export type invoiceOrderByWithRelationInput = {
    id?: SortOrder
    client_id?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    client?: clientOrderByWithRelationInput
    invoice_detail?: invoice_detailOrderByRelationAggregateInput
    payment_attachment?: payment_attachmentOrderByRelationAggregateInput
    quote_attachment?: quote_attachmentOrderByRelationAggregateInput
  }

  export type invoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: invoiceWhereInput | invoiceWhereInput[]
    OR?: invoiceWhereInput[]
    NOT?: invoiceWhereInput | invoiceWhereInput[]
    client_id?: UuidNullableFilter<"invoice"> | string | null
    description?: StringNullableFilter<"invoice"> | string | null
    value?: StringNullableFilter<"invoice"> | string | null
    url?: StringNullableFilter<"invoice"> | string | null
    created?: DateTimeNullableFilter<"invoice"> | Date | string | null
    updated?: DateTimeNullableFilter<"invoice"> | Date | string | null
    status?: BoolNullableFilter<"invoice"> | boolean | null
    client?: XOR<ClientNullableScalarRelationFilter, clientWhereInput> | null
    invoice_detail?: Invoice_detailListRelationFilter
    payment_attachment?: Payment_attachmentListRelationFilter
    quote_attachment?: Quote_attachmentListRelationFilter
  }, "id">

  export type invoiceOrderByWithAggregationInput = {
    id?: SortOrder
    client_id?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: invoiceCountOrderByAggregateInput
    _max?: invoiceMaxOrderByAggregateInput
    _min?: invoiceMinOrderByAggregateInput
  }

  export type invoiceScalarWhereWithAggregatesInput = {
    AND?: invoiceScalarWhereWithAggregatesInput | invoiceScalarWhereWithAggregatesInput[]
    OR?: invoiceScalarWhereWithAggregatesInput[]
    NOT?: invoiceScalarWhereWithAggregatesInput | invoiceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"invoice"> | string
    client_id?: UuidNullableWithAggregatesFilter<"invoice"> | string | null
    description?: StringNullableWithAggregatesFilter<"invoice"> | string | null
    value?: StringNullableWithAggregatesFilter<"invoice"> | string | null
    url?: StringNullableWithAggregatesFilter<"invoice"> | string | null
    created?: DateTimeNullableWithAggregatesFilter<"invoice"> | Date | string | null
    updated?: DateTimeNullableWithAggregatesFilter<"invoice"> | Date | string | null
    status?: BoolNullableWithAggregatesFilter<"invoice"> | boolean | null
  }

  export type invoice_detailWhereInput = {
    AND?: invoice_detailWhereInput | invoice_detailWhereInput[]
    OR?: invoice_detailWhereInput[]
    NOT?: invoice_detailWhereInput | invoice_detailWhereInput[]
    id?: UuidFilter<"invoice_detail"> | string
    invoice_id?: UuidNullableFilter<"invoice_detail"> | string | null
    service_id?: UuidNullableFilter<"invoice_detail"> | string | null
    item?: IntNullableFilter<"invoice_detail"> | number | null
    quantity?: IntNullableFilter<"invoice_detail"> | number | null
    total_value?: FloatNullableFilter<"invoice_detail"> | number | null
    created?: DateTimeNullableFilter<"invoice_detail"> | Date | string | null
    updated?: DateTimeNullableFilter<"invoice_detail"> | Date | string | null
    status?: BoolNullableFilter<"invoice_detail"> | boolean | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, invoiceWhereInput> | null
    service?: XOR<ServiceNullableScalarRelationFilter, serviceWhereInput> | null
  }

  export type invoice_detailOrderByWithRelationInput = {
    id?: SortOrder
    invoice_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    item?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    total_value?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    invoice?: invoiceOrderByWithRelationInput
    service?: serviceOrderByWithRelationInput
  }

  export type invoice_detailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: invoice_detailWhereInput | invoice_detailWhereInput[]
    OR?: invoice_detailWhereInput[]
    NOT?: invoice_detailWhereInput | invoice_detailWhereInput[]
    invoice_id?: UuidNullableFilter<"invoice_detail"> | string | null
    service_id?: UuidNullableFilter<"invoice_detail"> | string | null
    item?: IntNullableFilter<"invoice_detail"> | number | null
    quantity?: IntNullableFilter<"invoice_detail"> | number | null
    total_value?: FloatNullableFilter<"invoice_detail"> | number | null
    created?: DateTimeNullableFilter<"invoice_detail"> | Date | string | null
    updated?: DateTimeNullableFilter<"invoice_detail"> | Date | string | null
    status?: BoolNullableFilter<"invoice_detail"> | boolean | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, invoiceWhereInput> | null
    service?: XOR<ServiceNullableScalarRelationFilter, serviceWhereInput> | null
  }, "id">

  export type invoice_detailOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    item?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    total_value?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: invoice_detailCountOrderByAggregateInput
    _avg?: invoice_detailAvgOrderByAggregateInput
    _max?: invoice_detailMaxOrderByAggregateInput
    _min?: invoice_detailMinOrderByAggregateInput
    _sum?: invoice_detailSumOrderByAggregateInput
  }

  export type invoice_detailScalarWhereWithAggregatesInput = {
    AND?: invoice_detailScalarWhereWithAggregatesInput | invoice_detailScalarWhereWithAggregatesInput[]
    OR?: invoice_detailScalarWhereWithAggregatesInput[]
    NOT?: invoice_detailScalarWhereWithAggregatesInput | invoice_detailScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"invoice_detail"> | string
    invoice_id?: UuidNullableWithAggregatesFilter<"invoice_detail"> | string | null
    service_id?: UuidNullableWithAggregatesFilter<"invoice_detail"> | string | null
    item?: IntNullableWithAggregatesFilter<"invoice_detail"> | number | null
    quantity?: IntNullableWithAggregatesFilter<"invoice_detail"> | number | null
    total_value?: FloatNullableWithAggregatesFilter<"invoice_detail"> | number | null
    created?: DateTimeNullableWithAggregatesFilter<"invoice_detail"> | Date | string | null
    updated?: DateTimeNullableWithAggregatesFilter<"invoice_detail"> | Date | string | null
    status?: BoolNullableWithAggregatesFilter<"invoice_detail"> | boolean | null
  }

  export type logWhereInput = {
    AND?: logWhereInput | logWhereInput[]
    OR?: logWhereInput[]
    NOT?: logWhereInput | logWhereInput[]
    id?: UuidFilter<"log"> | string
    user_id?: UuidNullableFilter<"log"> | string | null
    role_id?: UuidNullableFilter<"log"> | string | null
    client_id?: UuidNullableFilter<"log"> | string | null
    user_name?: StringNullableFilter<"log"> | string | null
    ip?: StringNullableFilter<"log"> | string | null
    type?: StringNullableFilter<"log"> | string | null
    detail?: StringNullableFilter<"log"> | string | null
    created?: DateTimeNullableFilter<"log"> | Date | string | null
    client?: XOR<ClientNullableScalarRelationFilter, clientWhereInput> | null
    role?: XOR<RoleNullableScalarRelationFilter, roleWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type logOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    role_id?: SortOrderInput | SortOrder
    client_id?: SortOrderInput | SortOrder
    user_name?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    detail?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    client?: clientOrderByWithRelationInput
    role?: roleOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type logWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: logWhereInput | logWhereInput[]
    OR?: logWhereInput[]
    NOT?: logWhereInput | logWhereInput[]
    user_id?: UuidNullableFilter<"log"> | string | null
    role_id?: UuidNullableFilter<"log"> | string | null
    client_id?: UuidNullableFilter<"log"> | string | null
    user_name?: StringNullableFilter<"log"> | string | null
    ip?: StringNullableFilter<"log"> | string | null
    type?: StringNullableFilter<"log"> | string | null
    detail?: StringNullableFilter<"log"> | string | null
    created?: DateTimeNullableFilter<"log"> | Date | string | null
    client?: XOR<ClientNullableScalarRelationFilter, clientWhereInput> | null
    role?: XOR<RoleNullableScalarRelationFilter, roleWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type logOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    role_id?: SortOrderInput | SortOrder
    client_id?: SortOrderInput | SortOrder
    user_name?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    detail?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    _count?: logCountOrderByAggregateInput
    _max?: logMaxOrderByAggregateInput
    _min?: logMinOrderByAggregateInput
  }

  export type logScalarWhereWithAggregatesInput = {
    AND?: logScalarWhereWithAggregatesInput | logScalarWhereWithAggregatesInput[]
    OR?: logScalarWhereWithAggregatesInput[]
    NOT?: logScalarWhereWithAggregatesInput | logScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"log"> | string
    user_id?: UuidNullableWithAggregatesFilter<"log"> | string | null
    role_id?: UuidNullableWithAggregatesFilter<"log"> | string | null
    client_id?: UuidNullableWithAggregatesFilter<"log"> | string | null
    user_name?: StringNullableWithAggregatesFilter<"log"> | string | null
    ip?: StringNullableWithAggregatesFilter<"log"> | string | null
    type?: StringNullableWithAggregatesFilter<"log"> | string | null
    detail?: StringNullableWithAggregatesFilter<"log"> | string | null
    created?: DateTimeNullableWithAggregatesFilter<"log"> | Date | string | null
  }

  export type paymentWhereInput = {
    AND?: paymentWhereInput | paymentWhereInput[]
    OR?: paymentWhereInput[]
    NOT?: paymentWhereInput | paymentWhereInput[]
    id?: UuidFilter<"payment"> | string
    client_id?: UuidNullableFilter<"payment"> | string | null
    code?: StringNullableFilter<"payment"> | string | null
    value?: StringNullableFilter<"payment"> | string | null
    status_pay?: StringNullableFilter<"payment"> | string | null
    method?: StringNullableFilter<"payment"> | string | null
    payment_method_id?: UuidNullableFilter<"payment"> | string | null
    type?: StringNullableFilter<"payment"> | string | null
    url?: StringNullableFilter<"payment"> | string | null
    created?: DateTimeNullableFilter<"payment"> | Date | string | null
    updated?: DateTimeNullableFilter<"payment"> | Date | string | null
    status?: BoolNullableFilter<"payment"> | boolean | null
    client?: XOR<ClientNullableScalarRelationFilter, clientWhereInput> | null
    payment_method?: XOR<Payment_methodNullableScalarRelationFilter, payment_methodWhereInput> | null
  }

  export type paymentOrderByWithRelationInput = {
    id?: SortOrder
    client_id?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    status_pay?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    payment_method_id?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    client?: clientOrderByWithRelationInput
    payment_method?: payment_methodOrderByWithRelationInput
  }

  export type paymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: paymentWhereInput | paymentWhereInput[]
    OR?: paymentWhereInput[]
    NOT?: paymentWhereInput | paymentWhereInput[]
    client_id?: UuidNullableFilter<"payment"> | string | null
    code?: StringNullableFilter<"payment"> | string | null
    value?: StringNullableFilter<"payment"> | string | null
    status_pay?: StringNullableFilter<"payment"> | string | null
    method?: StringNullableFilter<"payment"> | string | null
    payment_method_id?: UuidNullableFilter<"payment"> | string | null
    type?: StringNullableFilter<"payment"> | string | null
    url?: StringNullableFilter<"payment"> | string | null
    created?: DateTimeNullableFilter<"payment"> | Date | string | null
    updated?: DateTimeNullableFilter<"payment"> | Date | string | null
    status?: BoolNullableFilter<"payment"> | boolean | null
    client?: XOR<ClientNullableScalarRelationFilter, clientWhereInput> | null
    payment_method?: XOR<Payment_methodNullableScalarRelationFilter, payment_methodWhereInput> | null
  }, "id">

  export type paymentOrderByWithAggregationInput = {
    id?: SortOrder
    client_id?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    status_pay?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    payment_method_id?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: paymentCountOrderByAggregateInput
    _max?: paymentMaxOrderByAggregateInput
    _min?: paymentMinOrderByAggregateInput
  }

  export type paymentScalarWhereWithAggregatesInput = {
    AND?: paymentScalarWhereWithAggregatesInput | paymentScalarWhereWithAggregatesInput[]
    OR?: paymentScalarWhereWithAggregatesInput[]
    NOT?: paymentScalarWhereWithAggregatesInput | paymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"payment"> | string
    client_id?: UuidNullableWithAggregatesFilter<"payment"> | string | null
    code?: StringNullableWithAggregatesFilter<"payment"> | string | null
    value?: StringNullableWithAggregatesFilter<"payment"> | string | null
    status_pay?: StringNullableWithAggregatesFilter<"payment"> | string | null
    method?: StringNullableWithAggregatesFilter<"payment"> | string | null
    payment_method_id?: UuidNullableWithAggregatesFilter<"payment"> | string | null
    type?: StringNullableWithAggregatesFilter<"payment"> | string | null
    url?: StringNullableWithAggregatesFilter<"payment"> | string | null
    created?: DateTimeNullableWithAggregatesFilter<"payment"> | Date | string | null
    updated?: DateTimeNullableWithAggregatesFilter<"payment"> | Date | string | null
    status?: BoolNullableWithAggregatesFilter<"payment"> | boolean | null
  }

  export type payment_attachmentWhereInput = {
    AND?: payment_attachmentWhereInput | payment_attachmentWhereInput[]
    OR?: payment_attachmentWhereInput[]
    NOT?: payment_attachmentWhereInput | payment_attachmentWhereInput[]
    id?: UuidFilter<"payment_attachment"> | string
    invoice_id?: UuidNullableFilter<"payment_attachment"> | string | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, invoiceWhereInput> | null
  }

  export type payment_attachmentOrderByWithRelationInput = {
    id?: SortOrder
    invoice_id?: SortOrderInput | SortOrder
    invoice?: invoiceOrderByWithRelationInput
  }

  export type payment_attachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: payment_attachmentWhereInput | payment_attachmentWhereInput[]
    OR?: payment_attachmentWhereInput[]
    NOT?: payment_attachmentWhereInput | payment_attachmentWhereInput[]
    invoice_id?: UuidNullableFilter<"payment_attachment"> | string | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, invoiceWhereInput> | null
  }, "id">

  export type payment_attachmentOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_id?: SortOrderInput | SortOrder
    _count?: payment_attachmentCountOrderByAggregateInput
    _max?: payment_attachmentMaxOrderByAggregateInput
    _min?: payment_attachmentMinOrderByAggregateInput
  }

  export type payment_attachmentScalarWhereWithAggregatesInput = {
    AND?: payment_attachmentScalarWhereWithAggregatesInput | payment_attachmentScalarWhereWithAggregatesInput[]
    OR?: payment_attachmentScalarWhereWithAggregatesInput[]
    NOT?: payment_attachmentScalarWhereWithAggregatesInput | payment_attachmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"payment_attachment"> | string
    invoice_id?: UuidNullableWithAggregatesFilter<"payment_attachment"> | string | null
  }

  export type payment_methodWhereInput = {
    AND?: payment_methodWhereInput | payment_methodWhereInput[]
    OR?: payment_methodWhereInput[]
    NOT?: payment_methodWhereInput | payment_methodWhereInput[]
    id?: UuidFilter<"payment_method"> | string
    name?: StringNullableFilter<"payment_method"> | string | null
    payment?: PaymentListRelationFilter
  }

  export type payment_methodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    payment?: paymentOrderByRelationAggregateInput
  }

  export type payment_methodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: payment_methodWhereInput | payment_methodWhereInput[]
    OR?: payment_methodWhereInput[]
    NOT?: payment_methodWhereInput | payment_methodWhereInput[]
    payment?: PaymentListRelationFilter
  }, "id" | "name">

  export type payment_methodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    _count?: payment_methodCountOrderByAggregateInput
    _max?: payment_methodMaxOrderByAggregateInput
    _min?: payment_methodMinOrderByAggregateInput
  }

  export type payment_methodScalarWhereWithAggregatesInput = {
    AND?: payment_methodScalarWhereWithAggregatesInput | payment_methodScalarWhereWithAggregatesInput[]
    OR?: payment_methodScalarWhereWithAggregatesInput[]
    NOT?: payment_methodScalarWhereWithAggregatesInput | payment_methodScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"payment_method"> | string
    name?: StringNullableWithAggregatesFilter<"payment_method"> | string | null
  }

  export type permissionWhereInput = {
    AND?: permissionWhereInput | permissionWhereInput[]
    OR?: permissionWhereInput[]
    NOT?: permissionWhereInput | permissionWhereInput[]
    id?: UuidFilter<"permission"> | string
    name?: StringNullableFilter<"permission"> | string | null
    section?: StringNullableFilter<"permission"> | string | null
    role_permission?: Role_permissionListRelationFilter
  }

  export type permissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    section?: SortOrderInput | SortOrder
    role_permission?: role_permissionOrderByRelationAggregateInput
  }

  export type permissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: permissionWhereInput | permissionWhereInput[]
    OR?: permissionWhereInput[]
    NOT?: permissionWhereInput | permissionWhereInput[]
    name?: StringNullableFilter<"permission"> | string | null
    section?: StringNullableFilter<"permission"> | string | null
    role_permission?: Role_permissionListRelationFilter
  }, "id">

  export type permissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    section?: SortOrderInput | SortOrder
    _count?: permissionCountOrderByAggregateInput
    _max?: permissionMaxOrderByAggregateInput
    _min?: permissionMinOrderByAggregateInput
  }

  export type permissionScalarWhereWithAggregatesInput = {
    AND?: permissionScalarWhereWithAggregatesInput | permissionScalarWhereWithAggregatesInput[]
    OR?: permissionScalarWhereWithAggregatesInput[]
    NOT?: permissionScalarWhereWithAggregatesInput | permissionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"permission"> | string
    name?: StringNullableWithAggregatesFilter<"permission"> | string | null
    section?: StringNullableWithAggregatesFilter<"permission"> | string | null
  }

  export type quoteWhereInput = {
    AND?: quoteWhereInput | quoteWhereInput[]
    OR?: quoteWhereInput[]
    NOT?: quoteWhereInput | quoteWhereInput[]
    id?: UuidFilter<"quote"> | string
    client_id?: UuidNullableFilter<"quote"> | string | null
    description?: StringNullableFilter<"quote"> | string | null
    value?: StringNullableFilter<"quote"> | string | null
    url?: StringNullableFilter<"quote"> | string | null
    created?: DateTimeNullableFilter<"quote"> | Date | string | null
    updated?: DateTimeNullableFilter<"quote"> | Date | string | null
    status?: BoolNullableFilter<"quote"> | boolean | null
    client?: XOR<ClientNullableScalarRelationFilter, clientWhereInput> | null
    quote_attachment?: Quote_attachmentListRelationFilter
    quote_detail?: Quote_detailListRelationFilter
  }

  export type quoteOrderByWithRelationInput = {
    id?: SortOrder
    client_id?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    client?: clientOrderByWithRelationInput
    quote_attachment?: quote_attachmentOrderByRelationAggregateInput
    quote_detail?: quote_detailOrderByRelationAggregateInput
  }

  export type quoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: quoteWhereInput | quoteWhereInput[]
    OR?: quoteWhereInput[]
    NOT?: quoteWhereInput | quoteWhereInput[]
    client_id?: UuidNullableFilter<"quote"> | string | null
    description?: StringNullableFilter<"quote"> | string | null
    value?: StringNullableFilter<"quote"> | string | null
    url?: StringNullableFilter<"quote"> | string | null
    created?: DateTimeNullableFilter<"quote"> | Date | string | null
    updated?: DateTimeNullableFilter<"quote"> | Date | string | null
    status?: BoolNullableFilter<"quote"> | boolean | null
    client?: XOR<ClientNullableScalarRelationFilter, clientWhereInput> | null
    quote_attachment?: Quote_attachmentListRelationFilter
    quote_detail?: Quote_detailListRelationFilter
  }, "id">

  export type quoteOrderByWithAggregationInput = {
    id?: SortOrder
    client_id?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: quoteCountOrderByAggregateInput
    _max?: quoteMaxOrderByAggregateInput
    _min?: quoteMinOrderByAggregateInput
  }

  export type quoteScalarWhereWithAggregatesInput = {
    AND?: quoteScalarWhereWithAggregatesInput | quoteScalarWhereWithAggregatesInput[]
    OR?: quoteScalarWhereWithAggregatesInput[]
    NOT?: quoteScalarWhereWithAggregatesInput | quoteScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"quote"> | string
    client_id?: UuidNullableWithAggregatesFilter<"quote"> | string | null
    description?: StringNullableWithAggregatesFilter<"quote"> | string | null
    value?: StringNullableWithAggregatesFilter<"quote"> | string | null
    url?: StringNullableWithAggregatesFilter<"quote"> | string | null
    created?: DateTimeNullableWithAggregatesFilter<"quote"> | Date | string | null
    updated?: DateTimeNullableWithAggregatesFilter<"quote"> | Date | string | null
    status?: BoolNullableWithAggregatesFilter<"quote"> | boolean | null
  }

  export type quote_attachmentWhereInput = {
    AND?: quote_attachmentWhereInput | quote_attachmentWhereInput[]
    OR?: quote_attachmentWhereInput[]
    NOT?: quote_attachmentWhereInput | quote_attachmentWhereInput[]
    id?: UuidFilter<"quote_attachment"> | string
    quote_id?: UuidNullableFilter<"quote_attachment"> | string | null
    invoice_id?: UuidNullableFilter<"quote_attachment"> | string | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, invoiceWhereInput> | null
    quote?: XOR<QuoteNullableScalarRelationFilter, quoteWhereInput> | null
  }

  export type quote_attachmentOrderByWithRelationInput = {
    id?: SortOrder
    quote_id?: SortOrderInput | SortOrder
    invoice_id?: SortOrderInput | SortOrder
    invoice?: invoiceOrderByWithRelationInput
    quote?: quoteOrderByWithRelationInput
  }

  export type quote_attachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: quote_attachmentWhereInput | quote_attachmentWhereInput[]
    OR?: quote_attachmentWhereInput[]
    NOT?: quote_attachmentWhereInput | quote_attachmentWhereInput[]
    quote_id?: UuidNullableFilter<"quote_attachment"> | string | null
    invoice_id?: UuidNullableFilter<"quote_attachment"> | string | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, invoiceWhereInput> | null
    quote?: XOR<QuoteNullableScalarRelationFilter, quoteWhereInput> | null
  }, "id">

  export type quote_attachmentOrderByWithAggregationInput = {
    id?: SortOrder
    quote_id?: SortOrderInput | SortOrder
    invoice_id?: SortOrderInput | SortOrder
    _count?: quote_attachmentCountOrderByAggregateInput
    _max?: quote_attachmentMaxOrderByAggregateInput
    _min?: quote_attachmentMinOrderByAggregateInput
  }

  export type quote_attachmentScalarWhereWithAggregatesInput = {
    AND?: quote_attachmentScalarWhereWithAggregatesInput | quote_attachmentScalarWhereWithAggregatesInput[]
    OR?: quote_attachmentScalarWhereWithAggregatesInput[]
    NOT?: quote_attachmentScalarWhereWithAggregatesInput | quote_attachmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"quote_attachment"> | string
    quote_id?: UuidNullableWithAggregatesFilter<"quote_attachment"> | string | null
    invoice_id?: UuidNullableWithAggregatesFilter<"quote_attachment"> | string | null
  }

  export type quote_detailWhereInput = {
    AND?: quote_detailWhereInput | quote_detailWhereInput[]
    OR?: quote_detailWhereInput[]
    NOT?: quote_detailWhereInput | quote_detailWhereInput[]
    id?: UuidFilter<"quote_detail"> | string
    quote_id?: UuidNullableFilter<"quote_detail"> | string | null
    service_id?: UuidNullableFilter<"quote_detail"> | string | null
    item?: IntNullableFilter<"quote_detail"> | number | null
    quantity?: IntNullableFilter<"quote_detail"> | number | null
    total_value?: FloatNullableFilter<"quote_detail"> | number | null
    created?: DateTimeNullableFilter<"quote_detail"> | Date | string | null
    updated?: DateTimeNullableFilter<"quote_detail"> | Date | string | null
    status?: BoolNullableFilter<"quote_detail"> | boolean | null
    quote?: XOR<QuoteNullableScalarRelationFilter, quoteWhereInput> | null
    service?: XOR<ServiceNullableScalarRelationFilter, serviceWhereInput> | null
  }

  export type quote_detailOrderByWithRelationInput = {
    id?: SortOrder
    quote_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    item?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    total_value?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    quote?: quoteOrderByWithRelationInput
    service?: serviceOrderByWithRelationInput
  }

  export type quote_detailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: quote_detailWhereInput | quote_detailWhereInput[]
    OR?: quote_detailWhereInput[]
    NOT?: quote_detailWhereInput | quote_detailWhereInput[]
    quote_id?: UuidNullableFilter<"quote_detail"> | string | null
    service_id?: UuidNullableFilter<"quote_detail"> | string | null
    item?: IntNullableFilter<"quote_detail"> | number | null
    quantity?: IntNullableFilter<"quote_detail"> | number | null
    total_value?: FloatNullableFilter<"quote_detail"> | number | null
    created?: DateTimeNullableFilter<"quote_detail"> | Date | string | null
    updated?: DateTimeNullableFilter<"quote_detail"> | Date | string | null
    status?: BoolNullableFilter<"quote_detail"> | boolean | null
    quote?: XOR<QuoteNullableScalarRelationFilter, quoteWhereInput> | null
    service?: XOR<ServiceNullableScalarRelationFilter, serviceWhereInput> | null
  }, "id">

  export type quote_detailOrderByWithAggregationInput = {
    id?: SortOrder
    quote_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    item?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    total_value?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: quote_detailCountOrderByAggregateInput
    _avg?: quote_detailAvgOrderByAggregateInput
    _max?: quote_detailMaxOrderByAggregateInput
    _min?: quote_detailMinOrderByAggregateInput
    _sum?: quote_detailSumOrderByAggregateInput
  }

  export type quote_detailScalarWhereWithAggregatesInput = {
    AND?: quote_detailScalarWhereWithAggregatesInput | quote_detailScalarWhereWithAggregatesInput[]
    OR?: quote_detailScalarWhereWithAggregatesInput[]
    NOT?: quote_detailScalarWhereWithAggregatesInput | quote_detailScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"quote_detail"> | string
    quote_id?: UuidNullableWithAggregatesFilter<"quote_detail"> | string | null
    service_id?: UuidNullableWithAggregatesFilter<"quote_detail"> | string | null
    item?: IntNullableWithAggregatesFilter<"quote_detail"> | number | null
    quantity?: IntNullableWithAggregatesFilter<"quote_detail"> | number | null
    total_value?: FloatNullableWithAggregatesFilter<"quote_detail"> | number | null
    created?: DateTimeNullableWithAggregatesFilter<"quote_detail"> | Date | string | null
    updated?: DateTimeNullableWithAggregatesFilter<"quote_detail"> | Date | string | null
    status?: BoolNullableWithAggregatesFilter<"quote_detail"> | boolean | null
  }

  export type roleWhereInput = {
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    id?: UuidFilter<"role"> | string
    name?: StringNullableFilter<"role"> | string | null
    role_category?: StringNullableFilter<"role"> | string | null
    created?: DateTimeNullableFilter<"role"> | Date | string | null
    updated?: DateTimeNullableFilter<"role"> | Date | string | null
    status?: BoolNullableFilter<"role"> | boolean | null
    description?: StringNullableFilter<"role"> | string | null
    log?: LogListRelationFilter
    role_permission?: Role_permissionListRelationFilter
    user?: UserListRelationFilter
  }

  export type roleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    role_category?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    log?: logOrderByRelationAggregateInput
    role_permission?: role_permissionOrderByRelationAggregateInput
    user?: userOrderByRelationAggregateInput
  }

  export type roleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    name?: StringNullableFilter<"role"> | string | null
    role_category?: StringNullableFilter<"role"> | string | null
    created?: DateTimeNullableFilter<"role"> | Date | string | null
    updated?: DateTimeNullableFilter<"role"> | Date | string | null
    status?: BoolNullableFilter<"role"> | boolean | null
    description?: StringNullableFilter<"role"> | string | null
    log?: LogListRelationFilter
    role_permission?: Role_permissionListRelationFilter
    user?: UserListRelationFilter
  }, "id">

  export type roleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    role_category?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: roleCountOrderByAggregateInput
    _max?: roleMaxOrderByAggregateInput
    _min?: roleMinOrderByAggregateInput
  }

  export type roleScalarWhereWithAggregatesInput = {
    AND?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    OR?: roleScalarWhereWithAggregatesInput[]
    NOT?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"role"> | string
    name?: StringNullableWithAggregatesFilter<"role"> | string | null
    role_category?: StringNullableWithAggregatesFilter<"role"> | string | null
    created?: DateTimeNullableWithAggregatesFilter<"role"> | Date | string | null
    updated?: DateTimeNullableWithAggregatesFilter<"role"> | Date | string | null
    status?: BoolNullableWithAggregatesFilter<"role"> | boolean | null
    description?: StringNullableWithAggregatesFilter<"role"> | string | null
  }

  export type role_permissionWhereInput = {
    AND?: role_permissionWhereInput | role_permissionWhereInput[]
    OR?: role_permissionWhereInput[]
    NOT?: role_permissionWhereInput | role_permissionWhereInput[]
    id?: UuidFilter<"role_permission"> | string
    role_id?: UuidNullableFilter<"role_permission"> | string | null
    permission_id?: UuidNullableFilter<"role_permission"> | string | null
    permission?: XOR<PermissionNullableScalarRelationFilter, permissionWhereInput> | null
    role?: XOR<RoleNullableScalarRelationFilter, roleWhereInput> | null
  }

  export type role_permissionOrderByWithRelationInput = {
    id?: SortOrder
    role_id?: SortOrderInput | SortOrder
    permission_id?: SortOrderInput | SortOrder
    permission?: permissionOrderByWithRelationInput
    role?: roleOrderByWithRelationInput
  }

  export type role_permissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: role_permissionWhereInput | role_permissionWhereInput[]
    OR?: role_permissionWhereInput[]
    NOT?: role_permissionWhereInput | role_permissionWhereInput[]
    role_id?: UuidNullableFilter<"role_permission"> | string | null
    permission_id?: UuidNullableFilter<"role_permission"> | string | null
    permission?: XOR<PermissionNullableScalarRelationFilter, permissionWhereInput> | null
    role?: XOR<RoleNullableScalarRelationFilter, roleWhereInput> | null
  }, "id">

  export type role_permissionOrderByWithAggregationInput = {
    id?: SortOrder
    role_id?: SortOrderInput | SortOrder
    permission_id?: SortOrderInput | SortOrder
    _count?: role_permissionCountOrderByAggregateInput
    _max?: role_permissionMaxOrderByAggregateInput
    _min?: role_permissionMinOrderByAggregateInput
  }

  export type role_permissionScalarWhereWithAggregatesInput = {
    AND?: role_permissionScalarWhereWithAggregatesInput | role_permissionScalarWhereWithAggregatesInput[]
    OR?: role_permissionScalarWhereWithAggregatesInput[]
    NOT?: role_permissionScalarWhereWithAggregatesInput | role_permissionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"role_permission"> | string
    role_id?: UuidNullableWithAggregatesFilter<"role_permission"> | string | null
    permission_id?: UuidNullableWithAggregatesFilter<"role_permission"> | string | null
  }

  export type serviceWhereInput = {
    AND?: serviceWhereInput | serviceWhereInput[]
    OR?: serviceWhereInput[]
    NOT?: serviceWhereInput | serviceWhereInput[]
    id?: UuidFilter<"service"> | string
    service_category_id?: UuidNullableFilter<"service"> | string | null
    name?: StringNullableFilter<"service"> | string | null
    unit?: StringNullableFilter<"service"> | string | null
    description?: StringNullableFilter<"service"> | string | null
    created?: DateTimeNullableFilter<"service"> | Date | string | null
    updated?: DateTimeNullableFilter<"service"> | Date | string | null
    status?: BoolNullableFilter<"service"> | boolean | null
    client_service?: Client_serviceListRelationFilter
    invoice_detail?: Invoice_detailListRelationFilter
    quote_detail?: Quote_detailListRelationFilter
    service_category?: XOR<Service_categoryNullableScalarRelationFilter, service_categoryWhereInput> | null
    service_usage?: Service_usageListRelationFilter
  }

  export type serviceOrderByWithRelationInput = {
    id?: SortOrder
    service_category_id?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    client_service?: client_serviceOrderByRelationAggregateInput
    invoice_detail?: invoice_detailOrderByRelationAggregateInput
    quote_detail?: quote_detailOrderByRelationAggregateInput
    service_category?: service_categoryOrderByWithRelationInput
    service_usage?: service_usageOrderByRelationAggregateInput
  }

  export type serviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: serviceWhereInput | serviceWhereInput[]
    OR?: serviceWhereInput[]
    NOT?: serviceWhereInput | serviceWhereInput[]
    service_category_id?: UuidNullableFilter<"service"> | string | null
    name?: StringNullableFilter<"service"> | string | null
    unit?: StringNullableFilter<"service"> | string | null
    description?: StringNullableFilter<"service"> | string | null
    created?: DateTimeNullableFilter<"service"> | Date | string | null
    updated?: DateTimeNullableFilter<"service"> | Date | string | null
    status?: BoolNullableFilter<"service"> | boolean | null
    client_service?: Client_serviceListRelationFilter
    invoice_detail?: Invoice_detailListRelationFilter
    quote_detail?: Quote_detailListRelationFilter
    service_category?: XOR<Service_categoryNullableScalarRelationFilter, service_categoryWhereInput> | null
    service_usage?: Service_usageListRelationFilter
  }, "id">

  export type serviceOrderByWithAggregationInput = {
    id?: SortOrder
    service_category_id?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: serviceCountOrderByAggregateInput
    _max?: serviceMaxOrderByAggregateInput
    _min?: serviceMinOrderByAggregateInput
  }

  export type serviceScalarWhereWithAggregatesInput = {
    AND?: serviceScalarWhereWithAggregatesInput | serviceScalarWhereWithAggregatesInput[]
    OR?: serviceScalarWhereWithAggregatesInput[]
    NOT?: serviceScalarWhereWithAggregatesInput | serviceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"service"> | string
    service_category_id?: UuidNullableWithAggregatesFilter<"service"> | string | null
    name?: StringNullableWithAggregatesFilter<"service"> | string | null
    unit?: StringNullableWithAggregatesFilter<"service"> | string | null
    description?: StringNullableWithAggregatesFilter<"service"> | string | null
    created?: DateTimeNullableWithAggregatesFilter<"service"> | Date | string | null
    updated?: DateTimeNullableWithAggregatesFilter<"service"> | Date | string | null
    status?: BoolNullableWithAggregatesFilter<"service"> | boolean | null
  }

  export type service_categoryWhereInput = {
    AND?: service_categoryWhereInput | service_categoryWhereInput[]
    OR?: service_categoryWhereInput[]
    NOT?: service_categoryWhereInput | service_categoryWhereInput[]
    id?: UuidFilter<"service_category"> | string
    name?: StringNullableFilter<"service_category"> | string | null
    service?: ServiceListRelationFilter
  }

  export type service_categoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    service?: serviceOrderByRelationAggregateInput
  }

  export type service_categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: service_categoryWhereInput | service_categoryWhereInput[]
    OR?: service_categoryWhereInput[]
    NOT?: service_categoryWhereInput | service_categoryWhereInput[]
    name?: StringNullableFilter<"service_category"> | string | null
    service?: ServiceListRelationFilter
  }, "id">

  export type service_categoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    _count?: service_categoryCountOrderByAggregateInput
    _max?: service_categoryMaxOrderByAggregateInput
    _min?: service_categoryMinOrderByAggregateInput
  }

  export type service_categoryScalarWhereWithAggregatesInput = {
    AND?: service_categoryScalarWhereWithAggregatesInput | service_categoryScalarWhereWithAggregatesInput[]
    OR?: service_categoryScalarWhereWithAggregatesInput[]
    NOT?: service_categoryScalarWhereWithAggregatesInput | service_categoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"service_category"> | string
    name?: StringNullableWithAggregatesFilter<"service_category"> | string | null
  }

  export type service_usageWhereInput = {
    AND?: service_usageWhereInput | service_usageWhereInput[]
    OR?: service_usageWhereInput[]
    NOT?: service_usageWhereInput | service_usageWhereInput[]
    id?: UuidFilter<"service_usage"> | string
    client_id?: UuidNullableFilter<"service_usage"> | string | null
    service_id?: UuidNullableFilter<"service_usage"> | string | null
    start_date?: DateTimeNullableFilter<"service_usage"> | Date | string | null
    end_date?: DateTimeNullableFilter<"service_usage"> | Date | string | null
    usage?: StringNullableFilter<"service_usage"> | string | null
    created?: DateTimeNullableFilter<"service_usage"> | Date | string | null
    status?: StringNullableFilter<"service_usage"> | string | null
    client?: XOR<ClientNullableScalarRelationFilter, clientWhereInput> | null
    service?: XOR<ServiceNullableScalarRelationFilter, serviceWhereInput> | null
  }

  export type service_usageOrderByWithRelationInput = {
    id?: SortOrder
    client_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    usage?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    client?: clientOrderByWithRelationInput
    service?: serviceOrderByWithRelationInput
  }

  export type service_usageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: service_usageWhereInput | service_usageWhereInput[]
    OR?: service_usageWhereInput[]
    NOT?: service_usageWhereInput | service_usageWhereInput[]
    client_id?: UuidNullableFilter<"service_usage"> | string | null
    service_id?: UuidNullableFilter<"service_usage"> | string | null
    start_date?: DateTimeNullableFilter<"service_usage"> | Date | string | null
    end_date?: DateTimeNullableFilter<"service_usage"> | Date | string | null
    usage?: StringNullableFilter<"service_usage"> | string | null
    created?: DateTimeNullableFilter<"service_usage"> | Date | string | null
    status?: StringNullableFilter<"service_usage"> | string | null
    client?: XOR<ClientNullableScalarRelationFilter, clientWhereInput> | null
    service?: XOR<ServiceNullableScalarRelationFilter, serviceWhereInput> | null
  }, "id">

  export type service_usageOrderByWithAggregationInput = {
    id?: SortOrder
    client_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    usage?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: service_usageCountOrderByAggregateInput
    _max?: service_usageMaxOrderByAggregateInput
    _min?: service_usageMinOrderByAggregateInput
  }

  export type service_usageScalarWhereWithAggregatesInput = {
    AND?: service_usageScalarWhereWithAggregatesInput | service_usageScalarWhereWithAggregatesInput[]
    OR?: service_usageScalarWhereWithAggregatesInput[]
    NOT?: service_usageScalarWhereWithAggregatesInput | service_usageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"service_usage"> | string
    client_id?: UuidNullableWithAggregatesFilter<"service_usage"> | string | null
    service_id?: UuidNullableWithAggregatesFilter<"service_usage"> | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"service_usage"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"service_usage"> | Date | string | null
    usage?: StringNullableWithAggregatesFilter<"service_usage"> | string | null
    created?: DateTimeNullableWithAggregatesFilter<"service_usage"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"service_usage"> | string | null
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: UuidFilter<"user"> | string
    role_id?: UuidNullableFilter<"user"> | string | null
    client_id?: UuidNullableFilter<"user"> | string | null
    user?: StringNullableFilter<"user"> | string | null
    pass?: StringNullableFilter<"user"> | string | null
    name?: StringNullableFilter<"user"> | string | null
    created?: DateTimeNullableFilter<"user"> | Date | string | null
    updated?: DateTimeNullableFilter<"user"> | Date | string | null
    status?: BoolNullableFilter<"user"> | boolean | null
    log?: LogListRelationFilter
    client?: XOR<ClientNullableScalarRelationFilter, clientWhereInput> | null
    role?: XOR<RoleNullableScalarRelationFilter, roleWhereInput> | null
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    role_id?: SortOrderInput | SortOrder
    client_id?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    pass?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    log?: logOrderByRelationAggregateInput
    client?: clientOrderByWithRelationInput
    role?: roleOrderByWithRelationInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    role_id?: UuidNullableFilter<"user"> | string | null
    client_id?: UuidNullableFilter<"user"> | string | null
    user?: StringNullableFilter<"user"> | string | null
    pass?: StringNullableFilter<"user"> | string | null
    name?: StringNullableFilter<"user"> | string | null
    created?: DateTimeNullableFilter<"user"> | Date | string | null
    updated?: DateTimeNullableFilter<"user"> | Date | string | null
    status?: BoolNullableFilter<"user"> | boolean | null
    log?: LogListRelationFilter
    client?: XOR<ClientNullableScalarRelationFilter, clientWhereInput> | null
    role?: XOR<RoleNullableScalarRelationFilter, roleWhereInput> | null
  }, "id">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    role_id?: SortOrderInput | SortOrder
    client_id?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    pass?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    updated?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"user"> | string
    role_id?: UuidNullableWithAggregatesFilter<"user"> | string | null
    client_id?: UuidNullableWithAggregatesFilter<"user"> | string | null
    user?: StringNullableWithAggregatesFilter<"user"> | string | null
    pass?: StringNullableWithAggregatesFilter<"user"> | string | null
    name?: StringNullableWithAggregatesFilter<"user"> | string | null
    created?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    updated?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    status?: BoolNullableWithAggregatesFilter<"user"> | boolean | null
  }

  export type clientCreateInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_details?: client_detailsCreateNestedManyWithoutClientInput
    client_service?: client_serviceCreateNestedManyWithoutClientInput
    invoice?: invoiceCreateNestedManyWithoutClientInput
    log?: logCreateNestedManyWithoutClientInput
    payment?: paymentCreateNestedManyWithoutClientInput
    quote?: quoteCreateNestedManyWithoutClientInput
    service_usage?: service_usageCreateNestedManyWithoutClientInput
    user?: userCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_details?: client_detailsUncheckedCreateNestedManyWithoutClientInput
    client_service?: client_serviceUncheckedCreateNestedManyWithoutClientInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClientInput
    log?: logUncheckedCreateNestedManyWithoutClientInput
    payment?: paymentUncheckedCreateNestedManyWithoutClientInput
    quote?: quoteUncheckedCreateNestedManyWithoutClientInput
    service_usage?: service_usageUncheckedCreateNestedManyWithoutClientInput
    user?: userUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_details?: client_detailsUpdateManyWithoutClientNestedInput
    client_service?: client_serviceUpdateManyWithoutClientNestedInput
    invoice?: invoiceUpdateManyWithoutClientNestedInput
    log?: logUpdateManyWithoutClientNestedInput
    payment?: paymentUpdateManyWithoutClientNestedInput
    quote?: quoteUpdateManyWithoutClientNestedInput
    service_usage?: service_usageUpdateManyWithoutClientNestedInput
    user?: userUpdateManyWithoutClientNestedInput
  }

  export type clientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_details?: client_detailsUncheckedUpdateManyWithoutClientNestedInput
    client_service?: client_serviceUncheckedUpdateManyWithoutClientNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClientNestedInput
    log?: logUncheckedUpdateManyWithoutClientNestedInput
    payment?: paymentUncheckedUpdateManyWithoutClientNestedInput
    quote?: quoteUncheckedUpdateManyWithoutClientNestedInput
    service_usage?: service_usageUncheckedUpdateManyWithoutClientNestedInput
    user?: userUncheckedUpdateManyWithoutClientNestedInput
  }

  export type clientCreateManyInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type clientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type clientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type client_detailsCreateInput = {
    id: string
    value?: string | null
    client_parameter?: client_parameterCreateNestedOneWithoutClient_detailsInput
    client?: clientCreateNestedOneWithoutClient_detailsInput
  }

  export type client_detailsUncheckedCreateInput = {
    id: string
    client_id?: string | null
    c_parameter_id?: string | null
    value?: string | null
  }

  export type client_detailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    client_parameter?: client_parameterUpdateOneWithoutClient_detailsNestedInput
    client?: clientUpdateOneWithoutClient_detailsNestedInput
  }

  export type client_detailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    c_parameter_id?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type client_detailsCreateManyInput = {
    id: string
    client_id?: string | null
    c_parameter_id?: string | null
    value?: string | null
  }

  export type client_detailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type client_detailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    c_parameter_id?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type client_parameterCreateInput = {
    id: string
    name?: string | null
    client_details?: client_detailsCreateNestedManyWithoutClient_parameterInput
  }

  export type client_parameterUncheckedCreateInput = {
    id: string
    name?: string | null
    client_details?: client_detailsUncheckedCreateNestedManyWithoutClient_parameterInput
  }

  export type client_parameterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    client_details?: client_detailsUpdateManyWithoutClient_parameterNestedInput
  }

  export type client_parameterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    client_details?: client_detailsUncheckedUpdateManyWithoutClient_parameterNestedInput
  }

  export type client_parameterCreateManyInput = {
    id: string
    name?: string | null
  }

  export type client_parameterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type client_parameterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type client_serviceCreateInput = {
    id: string
    created?: Date | string | null
    updated?: Date | string | null
    started?: Date | string | null
    delivery?: Date | string | null
    expiry?: Date | string | null
    frequency?: string | null
    unit?: string | null
    url_api?: string | null
    token_api?: string | null
    client?: clientCreateNestedOneWithoutClient_serviceInput
    service?: serviceCreateNestedOneWithoutClient_serviceInput
  }

  export type client_serviceUncheckedCreateInput = {
    id: string
    client_id?: string | null
    service_id?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    started?: Date | string | null
    delivery?: Date | string | null
    expiry?: Date | string | null
    frequency?: string | null
    unit?: string | null
    url_api?: string | null
    token_api?: string | null
  }

  export type client_serviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    url_api?: NullableStringFieldUpdateOperationsInput | string | null
    token_api?: NullableStringFieldUpdateOperationsInput | string | null
    client?: clientUpdateOneWithoutClient_serviceNestedInput
    service?: serviceUpdateOneWithoutClient_serviceNestedInput
  }

  export type client_serviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    url_api?: NullableStringFieldUpdateOperationsInput | string | null
    token_api?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type client_serviceCreateManyInput = {
    id: string
    client_id?: string | null
    service_id?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    started?: Date | string | null
    delivery?: Date | string | null
    expiry?: Date | string | null
    frequency?: string | null
    unit?: string | null
    url_api?: string | null
    token_api?: string | null
  }

  export type client_serviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    url_api?: NullableStringFieldUpdateOperationsInput | string | null
    token_api?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type client_serviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    url_api?: NullableStringFieldUpdateOperationsInput | string | null
    token_api?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invoiceCreateInput = {
    id: string
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client?: clientCreateNestedOneWithoutInvoiceInput
    invoice_detail?: invoice_detailCreateNestedManyWithoutInvoiceInput
    payment_attachment?: payment_attachmentCreateNestedManyWithoutInvoiceInput
    quote_attachment?: quote_attachmentCreateNestedManyWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateInput = {
    id: string
    client_id?: string | null
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    invoice_detail?: invoice_detailUncheckedCreateNestedManyWithoutInvoiceInput
    payment_attachment?: payment_attachmentUncheckedCreateNestedManyWithoutInvoiceInput
    quote_attachment?: quote_attachmentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type invoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client?: clientUpdateOneWithoutInvoiceNestedInput
    invoice_detail?: invoice_detailUpdateManyWithoutInvoiceNestedInput
    payment_attachment?: payment_attachmentUpdateManyWithoutInvoiceNestedInput
    quote_attachment?: quote_attachmentUpdateManyWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    invoice_detail?: invoice_detailUncheckedUpdateManyWithoutInvoiceNestedInput
    payment_attachment?: payment_attachmentUncheckedUpdateManyWithoutInvoiceNestedInput
    quote_attachment?: quote_attachmentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type invoiceCreateManyInput = {
    id: string
    client_id?: string | null
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type invoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invoice_detailCreateInput = {
    id: string
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    invoice?: invoiceCreateNestedOneWithoutInvoice_detailInput
    service?: serviceCreateNestedOneWithoutInvoice_detailInput
  }

  export type invoice_detailUncheckedCreateInput = {
    id: string
    invoice_id?: string | null
    service_id?: string | null
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type invoice_detailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    invoice?: invoiceUpdateOneWithoutInvoice_detailNestedInput
    service?: serviceUpdateOneWithoutInvoice_detailNestedInput
  }

  export type invoice_detailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invoice_detailCreateManyInput = {
    id: string
    invoice_id?: string | null
    service_id?: string | null
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type invoice_detailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invoice_detailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type logCreateInput = {
    id: string
    user_name?: string | null
    ip?: string | null
    type?: string | null
    detail?: string | null
    created?: Date | string | null
    client?: clientCreateNestedOneWithoutLogInput
    role?: roleCreateNestedOneWithoutLogInput
    user?: userCreateNestedOneWithoutLogInput
  }

  export type logUncheckedCreateInput = {
    id: string
    user_id?: string | null
    role_id?: string | null
    client_id?: string | null
    user_name?: string | null
    ip?: string | null
    type?: string | null
    detail?: string | null
    created?: Date | string | null
  }

  export type logUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: clientUpdateOneWithoutLogNestedInput
    role?: roleUpdateOneWithoutLogNestedInput
    user?: userUpdateOneWithoutLogNestedInput
  }

  export type logUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type logCreateManyInput = {
    id: string
    user_id?: string | null
    role_id?: string | null
    client_id?: string | null
    user_name?: string | null
    ip?: string | null
    type?: string | null
    detail?: string | null
    created?: Date | string | null
  }

  export type logUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type logUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentCreateInput = {
    id: string
    code?: string | null
    value?: string | null
    status_pay?: string | null
    method?: string | null
    type?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client?: clientCreateNestedOneWithoutPaymentInput
    payment_method?: payment_methodCreateNestedOneWithoutPaymentInput
  }

  export type paymentUncheckedCreateInput = {
    id: string
    client_id?: string | null
    code?: string | null
    value?: string | null
    status_pay?: string | null
    method?: string | null
    payment_method_id?: string | null
    type?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type paymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    status_pay?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client?: clientUpdateOneWithoutPaymentNestedInput
    payment_method?: payment_methodUpdateOneWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    status_pay?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type paymentCreateManyInput = {
    id: string
    client_id?: string | null
    code?: string | null
    value?: string | null
    status_pay?: string | null
    method?: string | null
    payment_method_id?: string | null
    type?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type paymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    status_pay?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type paymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    status_pay?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type payment_attachmentCreateInput = {
    id: string
    invoice?: invoiceCreateNestedOneWithoutPayment_attachmentInput
  }

  export type payment_attachmentUncheckedCreateInput = {
    id: string
    invoice_id?: string | null
  }

  export type payment_attachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice?: invoiceUpdateOneWithoutPayment_attachmentNestedInput
  }

  export type payment_attachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payment_attachmentCreateManyInput = {
    id: string
    invoice_id?: string | null
  }

  export type payment_attachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type payment_attachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payment_methodCreateInput = {
    id: string
    name?: string | null
    payment?: paymentCreateNestedManyWithoutPayment_methodInput
  }

  export type payment_methodUncheckedCreateInput = {
    id: string
    name?: string | null
    payment?: paymentUncheckedCreateNestedManyWithoutPayment_methodInput
  }

  export type payment_methodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: paymentUpdateManyWithoutPayment_methodNestedInput
  }

  export type payment_methodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: paymentUncheckedUpdateManyWithoutPayment_methodNestedInput
  }

  export type payment_methodCreateManyInput = {
    id: string
    name?: string | null
  }

  export type payment_methodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payment_methodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permissionCreateInput = {
    id: string
    name?: string | null
    section?: string | null
    role_permission?: role_permissionCreateNestedManyWithoutPermissionInput
  }

  export type permissionUncheckedCreateInput = {
    id: string
    name?: string | null
    section?: string | null
    role_permission?: role_permissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type permissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    role_permission?: role_permissionUpdateManyWithoutPermissionNestedInput
  }

  export type permissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    role_permission?: role_permissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type permissionCreateManyInput = {
    id: string
    name?: string | null
    section?: string | null
  }

  export type permissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quoteCreateInput = {
    id: string
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client?: clientCreateNestedOneWithoutQuoteInput
    quote_attachment?: quote_attachmentCreateNestedManyWithoutQuoteInput
    quote_detail?: quote_detailCreateNestedManyWithoutQuoteInput
  }

  export type quoteUncheckedCreateInput = {
    id: string
    client_id?: string | null
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    quote_attachment?: quote_attachmentUncheckedCreateNestedManyWithoutQuoteInput
    quote_detail?: quote_detailUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type quoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client?: clientUpdateOneWithoutQuoteNestedInput
    quote_attachment?: quote_attachmentUpdateManyWithoutQuoteNestedInput
    quote_detail?: quote_detailUpdateManyWithoutQuoteNestedInput
  }

  export type quoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quote_attachment?: quote_attachmentUncheckedUpdateManyWithoutQuoteNestedInput
    quote_detail?: quote_detailUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type quoteCreateManyInput = {
    id: string
    client_id?: string | null
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type quoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type quoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type quote_attachmentCreateInput = {
    id: string
    invoice?: invoiceCreateNestedOneWithoutQuote_attachmentInput
    quote?: quoteCreateNestedOneWithoutQuote_attachmentInput
  }

  export type quote_attachmentUncheckedCreateInput = {
    id: string
    quote_id?: string | null
    invoice_id?: string | null
  }

  export type quote_attachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice?: invoiceUpdateOneWithoutQuote_attachmentNestedInput
    quote?: quoteUpdateOneWithoutQuote_attachmentNestedInput
  }

  export type quote_attachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quote_attachmentCreateManyInput = {
    id: string
    quote_id?: string | null
    invoice_id?: string | null
  }

  export type quote_attachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type quote_attachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quote_detailCreateInput = {
    id: string
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    quote?: quoteCreateNestedOneWithoutQuote_detailInput
    service?: serviceCreateNestedOneWithoutQuote_detailInput
  }

  export type quote_detailUncheckedCreateInput = {
    id: string
    quote_id?: string | null
    service_id?: string | null
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type quote_detailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quote?: quoteUpdateOneWithoutQuote_detailNestedInput
    service?: serviceUpdateOneWithoutQuote_detailNestedInput
  }

  export type quote_detailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote_id?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type quote_detailCreateManyInput = {
    id: string
    quote_id?: string | null
    service_id?: string | null
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type quote_detailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type quote_detailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote_id?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type roleCreateInput = {
    id: string
    name?: string | null
    role_category?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    description?: string | null
    log?: logCreateNestedManyWithoutRoleInput
    role_permission?: role_permissionCreateNestedManyWithoutRoleInput
    user?: userCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateInput = {
    id: string
    name?: string | null
    role_category?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    description?: string | null
    log?: logUncheckedCreateNestedManyWithoutRoleInput
    role_permission?: role_permissionUncheckedCreateNestedManyWithoutRoleInput
    user?: userUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role_category?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    log?: logUpdateManyWithoutRoleNestedInput
    role_permission?: role_permissionUpdateManyWithoutRoleNestedInput
    user?: userUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role_category?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    log?: logUncheckedUpdateManyWithoutRoleNestedInput
    role_permission?: role_permissionUncheckedUpdateManyWithoutRoleNestedInput
    user?: userUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type roleCreateManyInput = {
    id: string
    name?: string | null
    role_category?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    description?: string | null
  }

  export type roleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role_category?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role_category?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type role_permissionCreateInput = {
    id: string
    permission?: permissionCreateNestedOneWithoutRole_permissionInput
    role?: roleCreateNestedOneWithoutRole_permissionInput
  }

  export type role_permissionUncheckedCreateInput = {
    id: string
    role_id?: string | null
    permission_id?: string | null
  }

  export type role_permissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: permissionUpdateOneWithoutRole_permissionNestedInput
    role?: roleUpdateOneWithoutRole_permissionNestedInput
  }

  export type role_permissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    permission_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type role_permissionCreateManyInput = {
    id: string
    role_id?: string | null
    permission_id?: string | null
  }

  export type role_permissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type role_permissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    permission_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviceCreateInput = {
    id: string
    name?: string | null
    unit?: string | null
    description?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_service?: client_serviceCreateNestedManyWithoutServiceInput
    invoice_detail?: invoice_detailCreateNestedManyWithoutServiceInput
    quote_detail?: quote_detailCreateNestedManyWithoutServiceInput
    service_category?: service_categoryCreateNestedOneWithoutServiceInput
    service_usage?: service_usageCreateNestedManyWithoutServiceInput
  }

  export type serviceUncheckedCreateInput = {
    id: string
    service_category_id?: string | null
    name?: string | null
    unit?: string | null
    description?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_service?: client_serviceUncheckedCreateNestedManyWithoutServiceInput
    invoice_detail?: invoice_detailUncheckedCreateNestedManyWithoutServiceInput
    quote_detail?: quote_detailUncheckedCreateNestedManyWithoutServiceInput
    service_usage?: service_usageUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_service?: client_serviceUpdateManyWithoutServiceNestedInput
    invoice_detail?: invoice_detailUpdateManyWithoutServiceNestedInput
    quote_detail?: quote_detailUpdateManyWithoutServiceNestedInput
    service_category?: service_categoryUpdateOneWithoutServiceNestedInput
    service_usage?: service_usageUpdateManyWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_service?: client_serviceUncheckedUpdateManyWithoutServiceNestedInput
    invoice_detail?: invoice_detailUncheckedUpdateManyWithoutServiceNestedInput
    quote_detail?: quote_detailUncheckedUpdateManyWithoutServiceNestedInput
    service_usage?: service_usageUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type serviceCreateManyInput = {
    id: string
    service_category_id?: string | null
    name?: string | null
    unit?: string | null
    description?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type serviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type serviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type service_categoryCreateInput = {
    id: string
    name?: string | null
    service?: serviceCreateNestedManyWithoutService_categoryInput
  }

  export type service_categoryUncheckedCreateInput = {
    id: string
    name?: string | null
    service?: serviceUncheckedCreateNestedManyWithoutService_categoryInput
  }

  export type service_categoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    service?: serviceUpdateManyWithoutService_categoryNestedInput
  }

  export type service_categoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    service?: serviceUncheckedUpdateManyWithoutService_categoryNestedInput
  }

  export type service_categoryCreateManyInput = {
    id: string
    name?: string | null
  }

  export type service_categoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type service_categoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type service_usageCreateInput = {
    id: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    usage?: string | null
    created?: Date | string | null
    status?: string | null
    client?: clientCreateNestedOneWithoutService_usageInput
    service?: serviceCreateNestedOneWithoutService_usageInput
  }

  export type service_usageUncheckedCreateInput = {
    id: string
    client_id?: string | null
    service_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    usage?: string | null
    created?: Date | string | null
    status?: string | null
  }

  export type service_usageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usage?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    client?: clientUpdateOneWithoutService_usageNestedInput
    service?: serviceUpdateOneWithoutService_usageNestedInput
  }

  export type service_usageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usage?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type service_usageCreateManyInput = {
    id: string
    client_id?: string | null
    service_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    usage?: string | null
    created?: Date | string | null
    status?: string | null
  }

  export type service_usageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usage?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type service_usageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usage?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userCreateInput = {
    id: string
    user?: string | null
    pass?: string | null
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    log?: logCreateNestedManyWithoutUserInput
    client?: clientCreateNestedOneWithoutUserInput
    role?: roleCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id: string
    role_id?: string | null
    client_id?: string | null
    user?: string | null
    pass?: string | null
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    log?: logUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    log?: logUpdateManyWithoutUserNestedInput
    client?: clientUpdateOneWithoutUserNestedInput
    role?: roleUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    log?: logUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id: string
    role_id?: string | null
    client_id?: string | null
    user?: string | null
    pass?: string | null
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type Client_detailsListRelationFilter = {
    every?: client_detailsWhereInput
    some?: client_detailsWhereInput
    none?: client_detailsWhereInput
  }

  export type Client_serviceListRelationFilter = {
    every?: client_serviceWhereInput
    some?: client_serviceWhereInput
    none?: client_serviceWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: invoiceWhereInput
    some?: invoiceWhereInput
    none?: invoiceWhereInput
  }

  export type LogListRelationFilter = {
    every?: logWhereInput
    some?: logWhereInput
    none?: logWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: paymentWhereInput
    some?: paymentWhereInput
    none?: paymentWhereInput
  }

  export type QuoteListRelationFilter = {
    every?: quoteWhereInput
    some?: quoteWhereInput
    none?: quoteWhereInput
  }

  export type Service_usageListRelationFilter = {
    every?: service_usageWhereInput
    some?: service_usageWhereInput
    none?: service_usageWhereInput
  }

  export type UserListRelationFilter = {
    every?: userWhereInput
    some?: userWhereInput
    none?: userWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type client_detailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type client_serviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type invoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type logOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type quoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type service_usageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type clientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type clientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type Client_parameterNullableScalarRelationFilter = {
    is?: client_parameterWhereInput | null
    isNot?: client_parameterWhereInput | null
  }

  export type ClientNullableScalarRelationFilter = {
    is?: clientWhereInput | null
    isNot?: clientWhereInput | null
  }

  export type client_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    c_parameter_id?: SortOrder
    value?: SortOrder
  }

  export type client_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    c_parameter_id?: SortOrder
    value?: SortOrder
  }

  export type client_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    c_parameter_id?: SortOrder
    value?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type client_parameterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type client_parameterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type client_parameterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ServiceNullableScalarRelationFilter = {
    is?: serviceWhereInput | null
    isNot?: serviceWhereInput | null
  }

  export type client_serviceCountOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    service_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    started?: SortOrder
    delivery?: SortOrder
    expiry?: SortOrder
    frequency?: SortOrder
    unit?: SortOrder
    url_api?: SortOrder
    token_api?: SortOrder
  }

  export type client_serviceMaxOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    service_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    started?: SortOrder
    delivery?: SortOrder
    expiry?: SortOrder
    frequency?: SortOrder
    unit?: SortOrder
    url_api?: SortOrder
    token_api?: SortOrder
  }

  export type client_serviceMinOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    service_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    started?: SortOrder
    delivery?: SortOrder
    expiry?: SortOrder
    frequency?: SortOrder
    unit?: SortOrder
    url_api?: SortOrder
    token_api?: SortOrder
  }

  export type Invoice_detailListRelationFilter = {
    every?: invoice_detailWhereInput
    some?: invoice_detailWhereInput
    none?: invoice_detailWhereInput
  }

  export type Payment_attachmentListRelationFilter = {
    every?: payment_attachmentWhereInput
    some?: payment_attachmentWhereInput
    none?: payment_attachmentWhereInput
  }

  export type Quote_attachmentListRelationFilter = {
    every?: quote_attachmentWhereInput
    some?: quote_attachmentWhereInput
    none?: quote_attachmentWhereInput
  }

  export type invoice_detailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type payment_attachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type quote_attachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type invoiceCountOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    description?: SortOrder
    value?: SortOrder
    url?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type invoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    description?: SortOrder
    value?: SortOrder
    url?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type invoiceMinOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    description?: SortOrder
    value?: SortOrder
    url?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: invoiceWhereInput | null
    isNot?: invoiceWhereInput | null
  }

  export type invoice_detailCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    service_id?: SortOrder
    item?: SortOrder
    quantity?: SortOrder
    total_value?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type invoice_detailAvgOrderByAggregateInput = {
    item?: SortOrder
    quantity?: SortOrder
    total_value?: SortOrder
  }

  export type invoice_detailMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    service_id?: SortOrder
    item?: SortOrder
    quantity?: SortOrder
    total_value?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type invoice_detailMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    service_id?: SortOrder
    item?: SortOrder
    quantity?: SortOrder
    total_value?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type invoice_detailSumOrderByAggregateInput = {
    item?: SortOrder
    quantity?: SortOrder
    total_value?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type RoleNullableScalarRelationFilter = {
    is?: roleWhereInput | null
    isNot?: roleWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type logCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    role_id?: SortOrder
    client_id?: SortOrder
    user_name?: SortOrder
    ip?: SortOrder
    type?: SortOrder
    detail?: SortOrder
    created?: SortOrder
  }

  export type logMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    role_id?: SortOrder
    client_id?: SortOrder
    user_name?: SortOrder
    ip?: SortOrder
    type?: SortOrder
    detail?: SortOrder
    created?: SortOrder
  }

  export type logMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    role_id?: SortOrder
    client_id?: SortOrder
    user_name?: SortOrder
    ip?: SortOrder
    type?: SortOrder
    detail?: SortOrder
    created?: SortOrder
  }

  export type Payment_methodNullableScalarRelationFilter = {
    is?: payment_methodWhereInput | null
    isNot?: payment_methodWhereInput | null
  }

  export type paymentCountOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    status_pay?: SortOrder
    method?: SortOrder
    payment_method_id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type paymentMaxOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    status_pay?: SortOrder
    method?: SortOrder
    payment_method_id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type paymentMinOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    status_pay?: SortOrder
    method?: SortOrder
    payment_method_id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type payment_attachmentCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
  }

  export type payment_attachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
  }

  export type payment_attachmentMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
  }

  export type payment_methodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type payment_methodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type payment_methodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type Role_permissionListRelationFilter = {
    every?: role_permissionWhereInput
    some?: role_permissionWhereInput
    none?: role_permissionWhereInput
  }

  export type role_permissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type permissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    section?: SortOrder
  }

  export type permissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    section?: SortOrder
  }

  export type permissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    section?: SortOrder
  }

  export type Quote_detailListRelationFilter = {
    every?: quote_detailWhereInput
    some?: quote_detailWhereInput
    none?: quote_detailWhereInput
  }

  export type quote_detailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type quoteCountOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    description?: SortOrder
    value?: SortOrder
    url?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type quoteMaxOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    description?: SortOrder
    value?: SortOrder
    url?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type quoteMinOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    description?: SortOrder
    value?: SortOrder
    url?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type QuoteNullableScalarRelationFilter = {
    is?: quoteWhereInput | null
    isNot?: quoteWhereInput | null
  }

  export type quote_attachmentCountOrderByAggregateInput = {
    id?: SortOrder
    quote_id?: SortOrder
    invoice_id?: SortOrder
  }

  export type quote_attachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    quote_id?: SortOrder
    invoice_id?: SortOrder
  }

  export type quote_attachmentMinOrderByAggregateInput = {
    id?: SortOrder
    quote_id?: SortOrder
    invoice_id?: SortOrder
  }

  export type quote_detailCountOrderByAggregateInput = {
    id?: SortOrder
    quote_id?: SortOrder
    service_id?: SortOrder
    item?: SortOrder
    quantity?: SortOrder
    total_value?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type quote_detailAvgOrderByAggregateInput = {
    item?: SortOrder
    quantity?: SortOrder
    total_value?: SortOrder
  }

  export type quote_detailMaxOrderByAggregateInput = {
    id?: SortOrder
    quote_id?: SortOrder
    service_id?: SortOrder
    item?: SortOrder
    quantity?: SortOrder
    total_value?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type quote_detailMinOrderByAggregateInput = {
    id?: SortOrder
    quote_id?: SortOrder
    service_id?: SortOrder
    item?: SortOrder
    quantity?: SortOrder
    total_value?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type quote_detailSumOrderByAggregateInput = {
    item?: SortOrder
    quantity?: SortOrder
    total_value?: SortOrder
  }

  export type roleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role_category?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
    description?: SortOrder
  }

  export type roleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role_category?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
    description?: SortOrder
  }

  export type roleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role_category?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
    description?: SortOrder
  }

  export type PermissionNullableScalarRelationFilter = {
    is?: permissionWhereInput | null
    isNot?: permissionWhereInput | null
  }

  export type role_permissionCountOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type role_permissionMaxOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type role_permissionMinOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type Service_categoryNullableScalarRelationFilter = {
    is?: service_categoryWhereInput | null
    isNot?: service_categoryWhereInput | null
  }

  export type serviceCountOrderByAggregateInput = {
    id?: SortOrder
    service_category_id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type serviceMaxOrderByAggregateInput = {
    id?: SortOrder
    service_category_id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type serviceMinOrderByAggregateInput = {
    id?: SortOrder
    service_category_id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type ServiceListRelationFilter = {
    every?: serviceWhereInput
    some?: serviceWhereInput
    none?: serviceWhereInput
  }

  export type serviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type service_categoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type service_categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type service_categoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type service_usageCountOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    service_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    usage?: SortOrder
    created?: SortOrder
    status?: SortOrder
  }

  export type service_usageMaxOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    service_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    usage?: SortOrder
    created?: SortOrder
    status?: SortOrder
  }

  export type service_usageMinOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    service_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    usage?: SortOrder
    created?: SortOrder
    status?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    client_id?: SortOrder
    user?: SortOrder
    pass?: SortOrder
    name?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    client_id?: SortOrder
    user?: SortOrder
    pass?: SortOrder
    name?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    client_id?: SortOrder
    user?: SortOrder
    pass?: SortOrder
    name?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    status?: SortOrder
  }

  export type client_detailsCreateNestedManyWithoutClientInput = {
    create?: XOR<client_detailsCreateWithoutClientInput, client_detailsUncheckedCreateWithoutClientInput> | client_detailsCreateWithoutClientInput[] | client_detailsUncheckedCreateWithoutClientInput[]
    connectOrCreate?: client_detailsCreateOrConnectWithoutClientInput | client_detailsCreateOrConnectWithoutClientInput[]
    createMany?: client_detailsCreateManyClientInputEnvelope
    connect?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
  }

  export type client_serviceCreateNestedManyWithoutClientInput = {
    create?: XOR<client_serviceCreateWithoutClientInput, client_serviceUncheckedCreateWithoutClientInput> | client_serviceCreateWithoutClientInput[] | client_serviceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: client_serviceCreateOrConnectWithoutClientInput | client_serviceCreateOrConnectWithoutClientInput[]
    createMany?: client_serviceCreateManyClientInputEnvelope
    connect?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
  }

  export type invoiceCreateNestedManyWithoutClientInput = {
    create?: XOR<invoiceCreateWithoutClientInput, invoiceUncheckedCreateWithoutClientInput> | invoiceCreateWithoutClientInput[] | invoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutClientInput | invoiceCreateOrConnectWithoutClientInput[]
    createMany?: invoiceCreateManyClientInputEnvelope
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
  }

  export type logCreateNestedManyWithoutClientInput = {
    create?: XOR<logCreateWithoutClientInput, logUncheckedCreateWithoutClientInput> | logCreateWithoutClientInput[] | logUncheckedCreateWithoutClientInput[]
    connectOrCreate?: logCreateOrConnectWithoutClientInput | logCreateOrConnectWithoutClientInput[]
    createMany?: logCreateManyClientInputEnvelope
    connect?: logWhereUniqueInput | logWhereUniqueInput[]
  }

  export type paymentCreateNestedManyWithoutClientInput = {
    create?: XOR<paymentCreateWithoutClientInput, paymentUncheckedCreateWithoutClientInput> | paymentCreateWithoutClientInput[] | paymentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutClientInput | paymentCreateOrConnectWithoutClientInput[]
    createMany?: paymentCreateManyClientInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type quoteCreateNestedManyWithoutClientInput = {
    create?: XOR<quoteCreateWithoutClientInput, quoteUncheckedCreateWithoutClientInput> | quoteCreateWithoutClientInput[] | quoteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: quoteCreateOrConnectWithoutClientInput | quoteCreateOrConnectWithoutClientInput[]
    createMany?: quoteCreateManyClientInputEnvelope
    connect?: quoteWhereUniqueInput | quoteWhereUniqueInput[]
  }

  export type service_usageCreateNestedManyWithoutClientInput = {
    create?: XOR<service_usageCreateWithoutClientInput, service_usageUncheckedCreateWithoutClientInput> | service_usageCreateWithoutClientInput[] | service_usageUncheckedCreateWithoutClientInput[]
    connectOrCreate?: service_usageCreateOrConnectWithoutClientInput | service_usageCreateOrConnectWithoutClientInput[]
    createMany?: service_usageCreateManyClientInputEnvelope
    connect?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
  }

  export type userCreateNestedManyWithoutClientInput = {
    create?: XOR<userCreateWithoutClientInput, userUncheckedCreateWithoutClientInput> | userCreateWithoutClientInput[] | userUncheckedCreateWithoutClientInput[]
    connectOrCreate?: userCreateOrConnectWithoutClientInput | userCreateOrConnectWithoutClientInput[]
    createMany?: userCreateManyClientInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type client_detailsUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<client_detailsCreateWithoutClientInput, client_detailsUncheckedCreateWithoutClientInput> | client_detailsCreateWithoutClientInput[] | client_detailsUncheckedCreateWithoutClientInput[]
    connectOrCreate?: client_detailsCreateOrConnectWithoutClientInput | client_detailsCreateOrConnectWithoutClientInput[]
    createMany?: client_detailsCreateManyClientInputEnvelope
    connect?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
  }

  export type client_serviceUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<client_serviceCreateWithoutClientInput, client_serviceUncheckedCreateWithoutClientInput> | client_serviceCreateWithoutClientInput[] | client_serviceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: client_serviceCreateOrConnectWithoutClientInput | client_serviceCreateOrConnectWithoutClientInput[]
    createMany?: client_serviceCreateManyClientInputEnvelope
    connect?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
  }

  export type invoiceUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<invoiceCreateWithoutClientInput, invoiceUncheckedCreateWithoutClientInput> | invoiceCreateWithoutClientInput[] | invoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutClientInput | invoiceCreateOrConnectWithoutClientInput[]
    createMany?: invoiceCreateManyClientInputEnvelope
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
  }

  export type logUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<logCreateWithoutClientInput, logUncheckedCreateWithoutClientInput> | logCreateWithoutClientInput[] | logUncheckedCreateWithoutClientInput[]
    connectOrCreate?: logCreateOrConnectWithoutClientInput | logCreateOrConnectWithoutClientInput[]
    createMany?: logCreateManyClientInputEnvelope
    connect?: logWhereUniqueInput | logWhereUniqueInput[]
  }

  export type paymentUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<paymentCreateWithoutClientInput, paymentUncheckedCreateWithoutClientInput> | paymentCreateWithoutClientInput[] | paymentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutClientInput | paymentCreateOrConnectWithoutClientInput[]
    createMany?: paymentCreateManyClientInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type quoteUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<quoteCreateWithoutClientInput, quoteUncheckedCreateWithoutClientInput> | quoteCreateWithoutClientInput[] | quoteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: quoteCreateOrConnectWithoutClientInput | quoteCreateOrConnectWithoutClientInput[]
    createMany?: quoteCreateManyClientInputEnvelope
    connect?: quoteWhereUniqueInput | quoteWhereUniqueInput[]
  }

  export type service_usageUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<service_usageCreateWithoutClientInput, service_usageUncheckedCreateWithoutClientInput> | service_usageCreateWithoutClientInput[] | service_usageUncheckedCreateWithoutClientInput[]
    connectOrCreate?: service_usageCreateOrConnectWithoutClientInput | service_usageCreateOrConnectWithoutClientInput[]
    createMany?: service_usageCreateManyClientInputEnvelope
    connect?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<userCreateWithoutClientInput, userUncheckedCreateWithoutClientInput> | userCreateWithoutClientInput[] | userUncheckedCreateWithoutClientInput[]
    connectOrCreate?: userCreateOrConnectWithoutClientInput | userCreateOrConnectWithoutClientInput[]
    createMany?: userCreateManyClientInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type client_detailsUpdateManyWithoutClientNestedInput = {
    create?: XOR<client_detailsCreateWithoutClientInput, client_detailsUncheckedCreateWithoutClientInput> | client_detailsCreateWithoutClientInput[] | client_detailsUncheckedCreateWithoutClientInput[]
    connectOrCreate?: client_detailsCreateOrConnectWithoutClientInput | client_detailsCreateOrConnectWithoutClientInput[]
    upsert?: client_detailsUpsertWithWhereUniqueWithoutClientInput | client_detailsUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: client_detailsCreateManyClientInputEnvelope
    set?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
    disconnect?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
    delete?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
    connect?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
    update?: client_detailsUpdateWithWhereUniqueWithoutClientInput | client_detailsUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: client_detailsUpdateManyWithWhereWithoutClientInput | client_detailsUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: client_detailsScalarWhereInput | client_detailsScalarWhereInput[]
  }

  export type client_serviceUpdateManyWithoutClientNestedInput = {
    create?: XOR<client_serviceCreateWithoutClientInput, client_serviceUncheckedCreateWithoutClientInput> | client_serviceCreateWithoutClientInput[] | client_serviceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: client_serviceCreateOrConnectWithoutClientInput | client_serviceCreateOrConnectWithoutClientInput[]
    upsert?: client_serviceUpsertWithWhereUniqueWithoutClientInput | client_serviceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: client_serviceCreateManyClientInputEnvelope
    set?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
    disconnect?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
    delete?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
    connect?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
    update?: client_serviceUpdateWithWhereUniqueWithoutClientInput | client_serviceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: client_serviceUpdateManyWithWhereWithoutClientInput | client_serviceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: client_serviceScalarWhereInput | client_serviceScalarWhereInput[]
  }

  export type invoiceUpdateManyWithoutClientNestedInput = {
    create?: XOR<invoiceCreateWithoutClientInput, invoiceUncheckedCreateWithoutClientInput> | invoiceCreateWithoutClientInput[] | invoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutClientInput | invoiceCreateOrConnectWithoutClientInput[]
    upsert?: invoiceUpsertWithWhereUniqueWithoutClientInput | invoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: invoiceCreateManyClientInputEnvelope
    set?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    disconnect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    delete?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    update?: invoiceUpdateWithWhereUniqueWithoutClientInput | invoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: invoiceUpdateManyWithWhereWithoutClientInput | invoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: invoiceScalarWhereInput | invoiceScalarWhereInput[]
  }

  export type logUpdateManyWithoutClientNestedInput = {
    create?: XOR<logCreateWithoutClientInput, logUncheckedCreateWithoutClientInput> | logCreateWithoutClientInput[] | logUncheckedCreateWithoutClientInput[]
    connectOrCreate?: logCreateOrConnectWithoutClientInput | logCreateOrConnectWithoutClientInput[]
    upsert?: logUpsertWithWhereUniqueWithoutClientInput | logUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: logCreateManyClientInputEnvelope
    set?: logWhereUniqueInput | logWhereUniqueInput[]
    disconnect?: logWhereUniqueInput | logWhereUniqueInput[]
    delete?: logWhereUniqueInput | logWhereUniqueInput[]
    connect?: logWhereUniqueInput | logWhereUniqueInput[]
    update?: logUpdateWithWhereUniqueWithoutClientInput | logUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: logUpdateManyWithWhereWithoutClientInput | logUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: logScalarWhereInput | logScalarWhereInput[]
  }

  export type paymentUpdateManyWithoutClientNestedInput = {
    create?: XOR<paymentCreateWithoutClientInput, paymentUncheckedCreateWithoutClientInput> | paymentCreateWithoutClientInput[] | paymentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutClientInput | paymentCreateOrConnectWithoutClientInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutClientInput | paymentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: paymentCreateManyClientInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutClientInput | paymentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutClientInput | paymentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type quoteUpdateManyWithoutClientNestedInput = {
    create?: XOR<quoteCreateWithoutClientInput, quoteUncheckedCreateWithoutClientInput> | quoteCreateWithoutClientInput[] | quoteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: quoteCreateOrConnectWithoutClientInput | quoteCreateOrConnectWithoutClientInput[]
    upsert?: quoteUpsertWithWhereUniqueWithoutClientInput | quoteUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: quoteCreateManyClientInputEnvelope
    set?: quoteWhereUniqueInput | quoteWhereUniqueInput[]
    disconnect?: quoteWhereUniqueInput | quoteWhereUniqueInput[]
    delete?: quoteWhereUniqueInput | quoteWhereUniqueInput[]
    connect?: quoteWhereUniqueInput | quoteWhereUniqueInput[]
    update?: quoteUpdateWithWhereUniqueWithoutClientInput | quoteUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: quoteUpdateManyWithWhereWithoutClientInput | quoteUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: quoteScalarWhereInput | quoteScalarWhereInput[]
  }

  export type service_usageUpdateManyWithoutClientNestedInput = {
    create?: XOR<service_usageCreateWithoutClientInput, service_usageUncheckedCreateWithoutClientInput> | service_usageCreateWithoutClientInput[] | service_usageUncheckedCreateWithoutClientInput[]
    connectOrCreate?: service_usageCreateOrConnectWithoutClientInput | service_usageCreateOrConnectWithoutClientInput[]
    upsert?: service_usageUpsertWithWhereUniqueWithoutClientInput | service_usageUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: service_usageCreateManyClientInputEnvelope
    set?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
    disconnect?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
    delete?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
    connect?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
    update?: service_usageUpdateWithWhereUniqueWithoutClientInput | service_usageUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: service_usageUpdateManyWithWhereWithoutClientInput | service_usageUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: service_usageScalarWhereInput | service_usageScalarWhereInput[]
  }

  export type userUpdateManyWithoutClientNestedInput = {
    create?: XOR<userCreateWithoutClientInput, userUncheckedCreateWithoutClientInput> | userCreateWithoutClientInput[] | userUncheckedCreateWithoutClientInput[]
    connectOrCreate?: userCreateOrConnectWithoutClientInput | userCreateOrConnectWithoutClientInput[]
    upsert?: userUpsertWithWhereUniqueWithoutClientInput | userUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: userCreateManyClientInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutClientInput | userUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: userUpdateManyWithWhereWithoutClientInput | userUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type client_detailsUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<client_detailsCreateWithoutClientInput, client_detailsUncheckedCreateWithoutClientInput> | client_detailsCreateWithoutClientInput[] | client_detailsUncheckedCreateWithoutClientInput[]
    connectOrCreate?: client_detailsCreateOrConnectWithoutClientInput | client_detailsCreateOrConnectWithoutClientInput[]
    upsert?: client_detailsUpsertWithWhereUniqueWithoutClientInput | client_detailsUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: client_detailsCreateManyClientInputEnvelope
    set?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
    disconnect?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
    delete?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
    connect?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
    update?: client_detailsUpdateWithWhereUniqueWithoutClientInput | client_detailsUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: client_detailsUpdateManyWithWhereWithoutClientInput | client_detailsUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: client_detailsScalarWhereInput | client_detailsScalarWhereInput[]
  }

  export type client_serviceUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<client_serviceCreateWithoutClientInput, client_serviceUncheckedCreateWithoutClientInput> | client_serviceCreateWithoutClientInput[] | client_serviceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: client_serviceCreateOrConnectWithoutClientInput | client_serviceCreateOrConnectWithoutClientInput[]
    upsert?: client_serviceUpsertWithWhereUniqueWithoutClientInput | client_serviceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: client_serviceCreateManyClientInputEnvelope
    set?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
    disconnect?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
    delete?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
    connect?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
    update?: client_serviceUpdateWithWhereUniqueWithoutClientInput | client_serviceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: client_serviceUpdateManyWithWhereWithoutClientInput | client_serviceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: client_serviceScalarWhereInput | client_serviceScalarWhereInput[]
  }

  export type invoiceUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<invoiceCreateWithoutClientInput, invoiceUncheckedCreateWithoutClientInput> | invoiceCreateWithoutClientInput[] | invoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutClientInput | invoiceCreateOrConnectWithoutClientInput[]
    upsert?: invoiceUpsertWithWhereUniqueWithoutClientInput | invoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: invoiceCreateManyClientInputEnvelope
    set?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    disconnect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    delete?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    update?: invoiceUpdateWithWhereUniqueWithoutClientInput | invoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: invoiceUpdateManyWithWhereWithoutClientInput | invoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: invoiceScalarWhereInput | invoiceScalarWhereInput[]
  }

  export type logUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<logCreateWithoutClientInput, logUncheckedCreateWithoutClientInput> | logCreateWithoutClientInput[] | logUncheckedCreateWithoutClientInput[]
    connectOrCreate?: logCreateOrConnectWithoutClientInput | logCreateOrConnectWithoutClientInput[]
    upsert?: logUpsertWithWhereUniqueWithoutClientInput | logUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: logCreateManyClientInputEnvelope
    set?: logWhereUniqueInput | logWhereUniqueInput[]
    disconnect?: logWhereUniqueInput | logWhereUniqueInput[]
    delete?: logWhereUniqueInput | logWhereUniqueInput[]
    connect?: logWhereUniqueInput | logWhereUniqueInput[]
    update?: logUpdateWithWhereUniqueWithoutClientInput | logUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: logUpdateManyWithWhereWithoutClientInput | logUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: logScalarWhereInput | logScalarWhereInput[]
  }

  export type paymentUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<paymentCreateWithoutClientInput, paymentUncheckedCreateWithoutClientInput> | paymentCreateWithoutClientInput[] | paymentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutClientInput | paymentCreateOrConnectWithoutClientInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutClientInput | paymentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: paymentCreateManyClientInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutClientInput | paymentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutClientInput | paymentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type quoteUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<quoteCreateWithoutClientInput, quoteUncheckedCreateWithoutClientInput> | quoteCreateWithoutClientInput[] | quoteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: quoteCreateOrConnectWithoutClientInput | quoteCreateOrConnectWithoutClientInput[]
    upsert?: quoteUpsertWithWhereUniqueWithoutClientInput | quoteUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: quoteCreateManyClientInputEnvelope
    set?: quoteWhereUniqueInput | quoteWhereUniqueInput[]
    disconnect?: quoteWhereUniqueInput | quoteWhereUniqueInput[]
    delete?: quoteWhereUniqueInput | quoteWhereUniqueInput[]
    connect?: quoteWhereUniqueInput | quoteWhereUniqueInput[]
    update?: quoteUpdateWithWhereUniqueWithoutClientInput | quoteUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: quoteUpdateManyWithWhereWithoutClientInput | quoteUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: quoteScalarWhereInput | quoteScalarWhereInput[]
  }

  export type service_usageUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<service_usageCreateWithoutClientInput, service_usageUncheckedCreateWithoutClientInput> | service_usageCreateWithoutClientInput[] | service_usageUncheckedCreateWithoutClientInput[]
    connectOrCreate?: service_usageCreateOrConnectWithoutClientInput | service_usageCreateOrConnectWithoutClientInput[]
    upsert?: service_usageUpsertWithWhereUniqueWithoutClientInput | service_usageUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: service_usageCreateManyClientInputEnvelope
    set?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
    disconnect?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
    delete?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
    connect?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
    update?: service_usageUpdateWithWhereUniqueWithoutClientInput | service_usageUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: service_usageUpdateManyWithWhereWithoutClientInput | service_usageUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: service_usageScalarWhereInput | service_usageScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<userCreateWithoutClientInput, userUncheckedCreateWithoutClientInput> | userCreateWithoutClientInput[] | userUncheckedCreateWithoutClientInput[]
    connectOrCreate?: userCreateOrConnectWithoutClientInput | userCreateOrConnectWithoutClientInput[]
    upsert?: userUpsertWithWhereUniqueWithoutClientInput | userUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: userCreateManyClientInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutClientInput | userUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: userUpdateManyWithWhereWithoutClientInput | userUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type client_parameterCreateNestedOneWithoutClient_detailsInput = {
    create?: XOR<client_parameterCreateWithoutClient_detailsInput, client_parameterUncheckedCreateWithoutClient_detailsInput>
    connectOrCreate?: client_parameterCreateOrConnectWithoutClient_detailsInput
    connect?: client_parameterWhereUniqueInput
  }

  export type clientCreateNestedOneWithoutClient_detailsInput = {
    create?: XOR<clientCreateWithoutClient_detailsInput, clientUncheckedCreateWithoutClient_detailsInput>
    connectOrCreate?: clientCreateOrConnectWithoutClient_detailsInput
    connect?: clientWhereUniqueInput
  }

  export type client_parameterUpdateOneWithoutClient_detailsNestedInput = {
    create?: XOR<client_parameterCreateWithoutClient_detailsInput, client_parameterUncheckedCreateWithoutClient_detailsInput>
    connectOrCreate?: client_parameterCreateOrConnectWithoutClient_detailsInput
    upsert?: client_parameterUpsertWithoutClient_detailsInput
    disconnect?: client_parameterWhereInput | boolean
    delete?: client_parameterWhereInput | boolean
    connect?: client_parameterWhereUniqueInput
    update?: XOR<XOR<client_parameterUpdateToOneWithWhereWithoutClient_detailsInput, client_parameterUpdateWithoutClient_detailsInput>, client_parameterUncheckedUpdateWithoutClient_detailsInput>
  }

  export type clientUpdateOneWithoutClient_detailsNestedInput = {
    create?: XOR<clientCreateWithoutClient_detailsInput, clientUncheckedCreateWithoutClient_detailsInput>
    connectOrCreate?: clientCreateOrConnectWithoutClient_detailsInput
    upsert?: clientUpsertWithoutClient_detailsInput
    disconnect?: clientWhereInput | boolean
    delete?: clientWhereInput | boolean
    connect?: clientWhereUniqueInput
    update?: XOR<XOR<clientUpdateToOneWithWhereWithoutClient_detailsInput, clientUpdateWithoutClient_detailsInput>, clientUncheckedUpdateWithoutClient_detailsInput>
  }

  export type client_detailsCreateNestedManyWithoutClient_parameterInput = {
    create?: XOR<client_detailsCreateWithoutClient_parameterInput, client_detailsUncheckedCreateWithoutClient_parameterInput> | client_detailsCreateWithoutClient_parameterInput[] | client_detailsUncheckedCreateWithoutClient_parameterInput[]
    connectOrCreate?: client_detailsCreateOrConnectWithoutClient_parameterInput | client_detailsCreateOrConnectWithoutClient_parameterInput[]
    createMany?: client_detailsCreateManyClient_parameterInputEnvelope
    connect?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
  }

  export type client_detailsUncheckedCreateNestedManyWithoutClient_parameterInput = {
    create?: XOR<client_detailsCreateWithoutClient_parameterInput, client_detailsUncheckedCreateWithoutClient_parameterInput> | client_detailsCreateWithoutClient_parameterInput[] | client_detailsUncheckedCreateWithoutClient_parameterInput[]
    connectOrCreate?: client_detailsCreateOrConnectWithoutClient_parameterInput | client_detailsCreateOrConnectWithoutClient_parameterInput[]
    createMany?: client_detailsCreateManyClient_parameterInputEnvelope
    connect?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
  }

  export type client_detailsUpdateManyWithoutClient_parameterNestedInput = {
    create?: XOR<client_detailsCreateWithoutClient_parameterInput, client_detailsUncheckedCreateWithoutClient_parameterInput> | client_detailsCreateWithoutClient_parameterInput[] | client_detailsUncheckedCreateWithoutClient_parameterInput[]
    connectOrCreate?: client_detailsCreateOrConnectWithoutClient_parameterInput | client_detailsCreateOrConnectWithoutClient_parameterInput[]
    upsert?: client_detailsUpsertWithWhereUniqueWithoutClient_parameterInput | client_detailsUpsertWithWhereUniqueWithoutClient_parameterInput[]
    createMany?: client_detailsCreateManyClient_parameterInputEnvelope
    set?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
    disconnect?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
    delete?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
    connect?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
    update?: client_detailsUpdateWithWhereUniqueWithoutClient_parameterInput | client_detailsUpdateWithWhereUniqueWithoutClient_parameterInput[]
    updateMany?: client_detailsUpdateManyWithWhereWithoutClient_parameterInput | client_detailsUpdateManyWithWhereWithoutClient_parameterInput[]
    deleteMany?: client_detailsScalarWhereInput | client_detailsScalarWhereInput[]
  }

  export type client_detailsUncheckedUpdateManyWithoutClient_parameterNestedInput = {
    create?: XOR<client_detailsCreateWithoutClient_parameterInput, client_detailsUncheckedCreateWithoutClient_parameterInput> | client_detailsCreateWithoutClient_parameterInput[] | client_detailsUncheckedCreateWithoutClient_parameterInput[]
    connectOrCreate?: client_detailsCreateOrConnectWithoutClient_parameterInput | client_detailsCreateOrConnectWithoutClient_parameterInput[]
    upsert?: client_detailsUpsertWithWhereUniqueWithoutClient_parameterInput | client_detailsUpsertWithWhereUniqueWithoutClient_parameterInput[]
    createMany?: client_detailsCreateManyClient_parameterInputEnvelope
    set?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
    disconnect?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
    delete?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
    connect?: client_detailsWhereUniqueInput | client_detailsWhereUniqueInput[]
    update?: client_detailsUpdateWithWhereUniqueWithoutClient_parameterInput | client_detailsUpdateWithWhereUniqueWithoutClient_parameterInput[]
    updateMany?: client_detailsUpdateManyWithWhereWithoutClient_parameterInput | client_detailsUpdateManyWithWhereWithoutClient_parameterInput[]
    deleteMany?: client_detailsScalarWhereInput | client_detailsScalarWhereInput[]
  }

  export type clientCreateNestedOneWithoutClient_serviceInput = {
    create?: XOR<clientCreateWithoutClient_serviceInput, clientUncheckedCreateWithoutClient_serviceInput>
    connectOrCreate?: clientCreateOrConnectWithoutClient_serviceInput
    connect?: clientWhereUniqueInput
  }

  export type serviceCreateNestedOneWithoutClient_serviceInput = {
    create?: XOR<serviceCreateWithoutClient_serviceInput, serviceUncheckedCreateWithoutClient_serviceInput>
    connectOrCreate?: serviceCreateOrConnectWithoutClient_serviceInput
    connect?: serviceWhereUniqueInput
  }

  export type clientUpdateOneWithoutClient_serviceNestedInput = {
    create?: XOR<clientCreateWithoutClient_serviceInput, clientUncheckedCreateWithoutClient_serviceInput>
    connectOrCreate?: clientCreateOrConnectWithoutClient_serviceInput
    upsert?: clientUpsertWithoutClient_serviceInput
    disconnect?: clientWhereInput | boolean
    delete?: clientWhereInput | boolean
    connect?: clientWhereUniqueInput
    update?: XOR<XOR<clientUpdateToOneWithWhereWithoutClient_serviceInput, clientUpdateWithoutClient_serviceInput>, clientUncheckedUpdateWithoutClient_serviceInput>
  }

  export type serviceUpdateOneWithoutClient_serviceNestedInput = {
    create?: XOR<serviceCreateWithoutClient_serviceInput, serviceUncheckedCreateWithoutClient_serviceInput>
    connectOrCreate?: serviceCreateOrConnectWithoutClient_serviceInput
    upsert?: serviceUpsertWithoutClient_serviceInput
    disconnect?: serviceWhereInput | boolean
    delete?: serviceWhereInput | boolean
    connect?: serviceWhereUniqueInput
    update?: XOR<XOR<serviceUpdateToOneWithWhereWithoutClient_serviceInput, serviceUpdateWithoutClient_serviceInput>, serviceUncheckedUpdateWithoutClient_serviceInput>
  }

  export type clientCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<clientCreateWithoutInvoiceInput, clientUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: clientCreateOrConnectWithoutInvoiceInput
    connect?: clientWhereUniqueInput
  }

  export type invoice_detailCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<invoice_detailCreateWithoutInvoiceInput, invoice_detailUncheckedCreateWithoutInvoiceInput> | invoice_detailCreateWithoutInvoiceInput[] | invoice_detailUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: invoice_detailCreateOrConnectWithoutInvoiceInput | invoice_detailCreateOrConnectWithoutInvoiceInput[]
    createMany?: invoice_detailCreateManyInvoiceInputEnvelope
    connect?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
  }

  export type payment_attachmentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<payment_attachmentCreateWithoutInvoiceInput, payment_attachmentUncheckedCreateWithoutInvoiceInput> | payment_attachmentCreateWithoutInvoiceInput[] | payment_attachmentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: payment_attachmentCreateOrConnectWithoutInvoiceInput | payment_attachmentCreateOrConnectWithoutInvoiceInput[]
    createMany?: payment_attachmentCreateManyInvoiceInputEnvelope
    connect?: payment_attachmentWhereUniqueInput | payment_attachmentWhereUniqueInput[]
  }

  export type quote_attachmentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<quote_attachmentCreateWithoutInvoiceInput, quote_attachmentUncheckedCreateWithoutInvoiceInput> | quote_attachmentCreateWithoutInvoiceInput[] | quote_attachmentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: quote_attachmentCreateOrConnectWithoutInvoiceInput | quote_attachmentCreateOrConnectWithoutInvoiceInput[]
    createMany?: quote_attachmentCreateManyInvoiceInputEnvelope
    connect?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
  }

  export type invoice_detailUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<invoice_detailCreateWithoutInvoiceInput, invoice_detailUncheckedCreateWithoutInvoiceInput> | invoice_detailCreateWithoutInvoiceInput[] | invoice_detailUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: invoice_detailCreateOrConnectWithoutInvoiceInput | invoice_detailCreateOrConnectWithoutInvoiceInput[]
    createMany?: invoice_detailCreateManyInvoiceInputEnvelope
    connect?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
  }

  export type payment_attachmentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<payment_attachmentCreateWithoutInvoiceInput, payment_attachmentUncheckedCreateWithoutInvoiceInput> | payment_attachmentCreateWithoutInvoiceInput[] | payment_attachmentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: payment_attachmentCreateOrConnectWithoutInvoiceInput | payment_attachmentCreateOrConnectWithoutInvoiceInput[]
    createMany?: payment_attachmentCreateManyInvoiceInputEnvelope
    connect?: payment_attachmentWhereUniqueInput | payment_attachmentWhereUniqueInput[]
  }

  export type quote_attachmentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<quote_attachmentCreateWithoutInvoiceInput, quote_attachmentUncheckedCreateWithoutInvoiceInput> | quote_attachmentCreateWithoutInvoiceInput[] | quote_attachmentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: quote_attachmentCreateOrConnectWithoutInvoiceInput | quote_attachmentCreateOrConnectWithoutInvoiceInput[]
    createMany?: quote_attachmentCreateManyInvoiceInputEnvelope
    connect?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
  }

  export type clientUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<clientCreateWithoutInvoiceInput, clientUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: clientCreateOrConnectWithoutInvoiceInput
    upsert?: clientUpsertWithoutInvoiceInput
    disconnect?: clientWhereInput | boolean
    delete?: clientWhereInput | boolean
    connect?: clientWhereUniqueInput
    update?: XOR<XOR<clientUpdateToOneWithWhereWithoutInvoiceInput, clientUpdateWithoutInvoiceInput>, clientUncheckedUpdateWithoutInvoiceInput>
  }

  export type invoice_detailUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<invoice_detailCreateWithoutInvoiceInput, invoice_detailUncheckedCreateWithoutInvoiceInput> | invoice_detailCreateWithoutInvoiceInput[] | invoice_detailUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: invoice_detailCreateOrConnectWithoutInvoiceInput | invoice_detailCreateOrConnectWithoutInvoiceInput[]
    upsert?: invoice_detailUpsertWithWhereUniqueWithoutInvoiceInput | invoice_detailUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: invoice_detailCreateManyInvoiceInputEnvelope
    set?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
    disconnect?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
    delete?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
    connect?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
    update?: invoice_detailUpdateWithWhereUniqueWithoutInvoiceInput | invoice_detailUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: invoice_detailUpdateManyWithWhereWithoutInvoiceInput | invoice_detailUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: invoice_detailScalarWhereInput | invoice_detailScalarWhereInput[]
  }

  export type payment_attachmentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<payment_attachmentCreateWithoutInvoiceInput, payment_attachmentUncheckedCreateWithoutInvoiceInput> | payment_attachmentCreateWithoutInvoiceInput[] | payment_attachmentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: payment_attachmentCreateOrConnectWithoutInvoiceInput | payment_attachmentCreateOrConnectWithoutInvoiceInput[]
    upsert?: payment_attachmentUpsertWithWhereUniqueWithoutInvoiceInput | payment_attachmentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: payment_attachmentCreateManyInvoiceInputEnvelope
    set?: payment_attachmentWhereUniqueInput | payment_attachmentWhereUniqueInput[]
    disconnect?: payment_attachmentWhereUniqueInput | payment_attachmentWhereUniqueInput[]
    delete?: payment_attachmentWhereUniqueInput | payment_attachmentWhereUniqueInput[]
    connect?: payment_attachmentWhereUniqueInput | payment_attachmentWhereUniqueInput[]
    update?: payment_attachmentUpdateWithWhereUniqueWithoutInvoiceInput | payment_attachmentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: payment_attachmentUpdateManyWithWhereWithoutInvoiceInput | payment_attachmentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: payment_attachmentScalarWhereInput | payment_attachmentScalarWhereInput[]
  }

  export type quote_attachmentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<quote_attachmentCreateWithoutInvoiceInput, quote_attachmentUncheckedCreateWithoutInvoiceInput> | quote_attachmentCreateWithoutInvoiceInput[] | quote_attachmentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: quote_attachmentCreateOrConnectWithoutInvoiceInput | quote_attachmentCreateOrConnectWithoutInvoiceInput[]
    upsert?: quote_attachmentUpsertWithWhereUniqueWithoutInvoiceInput | quote_attachmentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: quote_attachmentCreateManyInvoiceInputEnvelope
    set?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
    disconnect?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
    delete?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
    connect?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
    update?: quote_attachmentUpdateWithWhereUniqueWithoutInvoiceInput | quote_attachmentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: quote_attachmentUpdateManyWithWhereWithoutInvoiceInput | quote_attachmentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: quote_attachmentScalarWhereInput | quote_attachmentScalarWhereInput[]
  }

  export type invoice_detailUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<invoice_detailCreateWithoutInvoiceInput, invoice_detailUncheckedCreateWithoutInvoiceInput> | invoice_detailCreateWithoutInvoiceInput[] | invoice_detailUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: invoice_detailCreateOrConnectWithoutInvoiceInput | invoice_detailCreateOrConnectWithoutInvoiceInput[]
    upsert?: invoice_detailUpsertWithWhereUniqueWithoutInvoiceInput | invoice_detailUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: invoice_detailCreateManyInvoiceInputEnvelope
    set?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
    disconnect?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
    delete?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
    connect?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
    update?: invoice_detailUpdateWithWhereUniqueWithoutInvoiceInput | invoice_detailUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: invoice_detailUpdateManyWithWhereWithoutInvoiceInput | invoice_detailUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: invoice_detailScalarWhereInput | invoice_detailScalarWhereInput[]
  }

  export type payment_attachmentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<payment_attachmentCreateWithoutInvoiceInput, payment_attachmentUncheckedCreateWithoutInvoiceInput> | payment_attachmentCreateWithoutInvoiceInput[] | payment_attachmentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: payment_attachmentCreateOrConnectWithoutInvoiceInput | payment_attachmentCreateOrConnectWithoutInvoiceInput[]
    upsert?: payment_attachmentUpsertWithWhereUniqueWithoutInvoiceInput | payment_attachmentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: payment_attachmentCreateManyInvoiceInputEnvelope
    set?: payment_attachmentWhereUniqueInput | payment_attachmentWhereUniqueInput[]
    disconnect?: payment_attachmentWhereUniqueInput | payment_attachmentWhereUniqueInput[]
    delete?: payment_attachmentWhereUniqueInput | payment_attachmentWhereUniqueInput[]
    connect?: payment_attachmentWhereUniqueInput | payment_attachmentWhereUniqueInput[]
    update?: payment_attachmentUpdateWithWhereUniqueWithoutInvoiceInput | payment_attachmentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: payment_attachmentUpdateManyWithWhereWithoutInvoiceInput | payment_attachmentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: payment_attachmentScalarWhereInput | payment_attachmentScalarWhereInput[]
  }

  export type quote_attachmentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<quote_attachmentCreateWithoutInvoiceInput, quote_attachmentUncheckedCreateWithoutInvoiceInput> | quote_attachmentCreateWithoutInvoiceInput[] | quote_attachmentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: quote_attachmentCreateOrConnectWithoutInvoiceInput | quote_attachmentCreateOrConnectWithoutInvoiceInput[]
    upsert?: quote_attachmentUpsertWithWhereUniqueWithoutInvoiceInput | quote_attachmentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: quote_attachmentCreateManyInvoiceInputEnvelope
    set?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
    disconnect?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
    delete?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
    connect?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
    update?: quote_attachmentUpdateWithWhereUniqueWithoutInvoiceInput | quote_attachmentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: quote_attachmentUpdateManyWithWhereWithoutInvoiceInput | quote_attachmentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: quote_attachmentScalarWhereInput | quote_attachmentScalarWhereInput[]
  }

  export type invoiceCreateNestedOneWithoutInvoice_detailInput = {
    create?: XOR<invoiceCreateWithoutInvoice_detailInput, invoiceUncheckedCreateWithoutInvoice_detailInput>
    connectOrCreate?: invoiceCreateOrConnectWithoutInvoice_detailInput
    connect?: invoiceWhereUniqueInput
  }

  export type serviceCreateNestedOneWithoutInvoice_detailInput = {
    create?: XOR<serviceCreateWithoutInvoice_detailInput, serviceUncheckedCreateWithoutInvoice_detailInput>
    connectOrCreate?: serviceCreateOrConnectWithoutInvoice_detailInput
    connect?: serviceWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type invoiceUpdateOneWithoutInvoice_detailNestedInput = {
    create?: XOR<invoiceCreateWithoutInvoice_detailInput, invoiceUncheckedCreateWithoutInvoice_detailInput>
    connectOrCreate?: invoiceCreateOrConnectWithoutInvoice_detailInput
    upsert?: invoiceUpsertWithoutInvoice_detailInput
    disconnect?: invoiceWhereInput | boolean
    delete?: invoiceWhereInput | boolean
    connect?: invoiceWhereUniqueInput
    update?: XOR<XOR<invoiceUpdateToOneWithWhereWithoutInvoice_detailInput, invoiceUpdateWithoutInvoice_detailInput>, invoiceUncheckedUpdateWithoutInvoice_detailInput>
  }

  export type serviceUpdateOneWithoutInvoice_detailNestedInput = {
    create?: XOR<serviceCreateWithoutInvoice_detailInput, serviceUncheckedCreateWithoutInvoice_detailInput>
    connectOrCreate?: serviceCreateOrConnectWithoutInvoice_detailInput
    upsert?: serviceUpsertWithoutInvoice_detailInput
    disconnect?: serviceWhereInput | boolean
    delete?: serviceWhereInput | boolean
    connect?: serviceWhereUniqueInput
    update?: XOR<XOR<serviceUpdateToOneWithWhereWithoutInvoice_detailInput, serviceUpdateWithoutInvoice_detailInput>, serviceUncheckedUpdateWithoutInvoice_detailInput>
  }

  export type clientCreateNestedOneWithoutLogInput = {
    create?: XOR<clientCreateWithoutLogInput, clientUncheckedCreateWithoutLogInput>
    connectOrCreate?: clientCreateOrConnectWithoutLogInput
    connect?: clientWhereUniqueInput
  }

  export type roleCreateNestedOneWithoutLogInput = {
    create?: XOR<roleCreateWithoutLogInput, roleUncheckedCreateWithoutLogInput>
    connectOrCreate?: roleCreateOrConnectWithoutLogInput
    connect?: roleWhereUniqueInput
  }

  export type userCreateNestedOneWithoutLogInput = {
    create?: XOR<userCreateWithoutLogInput, userUncheckedCreateWithoutLogInput>
    connectOrCreate?: userCreateOrConnectWithoutLogInput
    connect?: userWhereUniqueInput
  }

  export type clientUpdateOneWithoutLogNestedInput = {
    create?: XOR<clientCreateWithoutLogInput, clientUncheckedCreateWithoutLogInput>
    connectOrCreate?: clientCreateOrConnectWithoutLogInput
    upsert?: clientUpsertWithoutLogInput
    disconnect?: clientWhereInput | boolean
    delete?: clientWhereInput | boolean
    connect?: clientWhereUniqueInput
    update?: XOR<XOR<clientUpdateToOneWithWhereWithoutLogInput, clientUpdateWithoutLogInput>, clientUncheckedUpdateWithoutLogInput>
  }

  export type roleUpdateOneWithoutLogNestedInput = {
    create?: XOR<roleCreateWithoutLogInput, roleUncheckedCreateWithoutLogInput>
    connectOrCreate?: roleCreateOrConnectWithoutLogInput
    upsert?: roleUpsertWithoutLogInput
    disconnect?: roleWhereInput | boolean
    delete?: roleWhereInput | boolean
    connect?: roleWhereUniqueInput
    update?: XOR<XOR<roleUpdateToOneWithWhereWithoutLogInput, roleUpdateWithoutLogInput>, roleUncheckedUpdateWithoutLogInput>
  }

  export type userUpdateOneWithoutLogNestedInput = {
    create?: XOR<userCreateWithoutLogInput, userUncheckedCreateWithoutLogInput>
    connectOrCreate?: userCreateOrConnectWithoutLogInput
    upsert?: userUpsertWithoutLogInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutLogInput, userUpdateWithoutLogInput>, userUncheckedUpdateWithoutLogInput>
  }

  export type clientCreateNestedOneWithoutPaymentInput = {
    create?: XOR<clientCreateWithoutPaymentInput, clientUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: clientCreateOrConnectWithoutPaymentInput
    connect?: clientWhereUniqueInput
  }

  export type payment_methodCreateNestedOneWithoutPaymentInput = {
    create?: XOR<payment_methodCreateWithoutPaymentInput, payment_methodUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: payment_methodCreateOrConnectWithoutPaymentInput
    connect?: payment_methodWhereUniqueInput
  }

  export type clientUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<clientCreateWithoutPaymentInput, clientUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: clientCreateOrConnectWithoutPaymentInput
    upsert?: clientUpsertWithoutPaymentInput
    disconnect?: clientWhereInput | boolean
    delete?: clientWhereInput | boolean
    connect?: clientWhereUniqueInput
    update?: XOR<XOR<clientUpdateToOneWithWhereWithoutPaymentInput, clientUpdateWithoutPaymentInput>, clientUncheckedUpdateWithoutPaymentInput>
  }

  export type payment_methodUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<payment_methodCreateWithoutPaymentInput, payment_methodUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: payment_methodCreateOrConnectWithoutPaymentInput
    upsert?: payment_methodUpsertWithoutPaymentInput
    disconnect?: payment_methodWhereInput | boolean
    delete?: payment_methodWhereInput | boolean
    connect?: payment_methodWhereUniqueInput
    update?: XOR<XOR<payment_methodUpdateToOneWithWhereWithoutPaymentInput, payment_methodUpdateWithoutPaymentInput>, payment_methodUncheckedUpdateWithoutPaymentInput>
  }

  export type invoiceCreateNestedOneWithoutPayment_attachmentInput = {
    create?: XOR<invoiceCreateWithoutPayment_attachmentInput, invoiceUncheckedCreateWithoutPayment_attachmentInput>
    connectOrCreate?: invoiceCreateOrConnectWithoutPayment_attachmentInput
    connect?: invoiceWhereUniqueInput
  }

  export type invoiceUpdateOneWithoutPayment_attachmentNestedInput = {
    create?: XOR<invoiceCreateWithoutPayment_attachmentInput, invoiceUncheckedCreateWithoutPayment_attachmentInput>
    connectOrCreate?: invoiceCreateOrConnectWithoutPayment_attachmentInput
    upsert?: invoiceUpsertWithoutPayment_attachmentInput
    disconnect?: invoiceWhereInput | boolean
    delete?: invoiceWhereInput | boolean
    connect?: invoiceWhereUniqueInput
    update?: XOR<XOR<invoiceUpdateToOneWithWhereWithoutPayment_attachmentInput, invoiceUpdateWithoutPayment_attachmentInput>, invoiceUncheckedUpdateWithoutPayment_attachmentInput>
  }

  export type paymentCreateNestedManyWithoutPayment_methodInput = {
    create?: XOR<paymentCreateWithoutPayment_methodInput, paymentUncheckedCreateWithoutPayment_methodInput> | paymentCreateWithoutPayment_methodInput[] | paymentUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutPayment_methodInput | paymentCreateOrConnectWithoutPayment_methodInput[]
    createMany?: paymentCreateManyPayment_methodInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type paymentUncheckedCreateNestedManyWithoutPayment_methodInput = {
    create?: XOR<paymentCreateWithoutPayment_methodInput, paymentUncheckedCreateWithoutPayment_methodInput> | paymentCreateWithoutPayment_methodInput[] | paymentUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutPayment_methodInput | paymentCreateOrConnectWithoutPayment_methodInput[]
    createMany?: paymentCreateManyPayment_methodInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type paymentUpdateManyWithoutPayment_methodNestedInput = {
    create?: XOR<paymentCreateWithoutPayment_methodInput, paymentUncheckedCreateWithoutPayment_methodInput> | paymentCreateWithoutPayment_methodInput[] | paymentUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutPayment_methodInput | paymentCreateOrConnectWithoutPayment_methodInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutPayment_methodInput | paymentUpsertWithWhereUniqueWithoutPayment_methodInput[]
    createMany?: paymentCreateManyPayment_methodInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutPayment_methodInput | paymentUpdateWithWhereUniqueWithoutPayment_methodInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutPayment_methodInput | paymentUpdateManyWithWhereWithoutPayment_methodInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type paymentUncheckedUpdateManyWithoutPayment_methodNestedInput = {
    create?: XOR<paymentCreateWithoutPayment_methodInput, paymentUncheckedCreateWithoutPayment_methodInput> | paymentCreateWithoutPayment_methodInput[] | paymentUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutPayment_methodInput | paymentCreateOrConnectWithoutPayment_methodInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutPayment_methodInput | paymentUpsertWithWhereUniqueWithoutPayment_methodInput[]
    createMany?: paymentCreateManyPayment_methodInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutPayment_methodInput | paymentUpdateWithWhereUniqueWithoutPayment_methodInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutPayment_methodInput | paymentUpdateManyWithWhereWithoutPayment_methodInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type role_permissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<role_permissionCreateWithoutPermissionInput, role_permissionUncheckedCreateWithoutPermissionInput> | role_permissionCreateWithoutPermissionInput[] | role_permissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: role_permissionCreateOrConnectWithoutPermissionInput | role_permissionCreateOrConnectWithoutPermissionInput[]
    createMany?: role_permissionCreateManyPermissionInputEnvelope
    connect?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
  }

  export type role_permissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<role_permissionCreateWithoutPermissionInput, role_permissionUncheckedCreateWithoutPermissionInput> | role_permissionCreateWithoutPermissionInput[] | role_permissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: role_permissionCreateOrConnectWithoutPermissionInput | role_permissionCreateOrConnectWithoutPermissionInput[]
    createMany?: role_permissionCreateManyPermissionInputEnvelope
    connect?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
  }

  export type role_permissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<role_permissionCreateWithoutPermissionInput, role_permissionUncheckedCreateWithoutPermissionInput> | role_permissionCreateWithoutPermissionInput[] | role_permissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: role_permissionCreateOrConnectWithoutPermissionInput | role_permissionCreateOrConnectWithoutPermissionInput[]
    upsert?: role_permissionUpsertWithWhereUniqueWithoutPermissionInput | role_permissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: role_permissionCreateManyPermissionInputEnvelope
    set?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
    disconnect?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
    delete?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
    connect?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
    update?: role_permissionUpdateWithWhereUniqueWithoutPermissionInput | role_permissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: role_permissionUpdateManyWithWhereWithoutPermissionInput | role_permissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: role_permissionScalarWhereInput | role_permissionScalarWhereInput[]
  }

  export type role_permissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<role_permissionCreateWithoutPermissionInput, role_permissionUncheckedCreateWithoutPermissionInput> | role_permissionCreateWithoutPermissionInput[] | role_permissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: role_permissionCreateOrConnectWithoutPermissionInput | role_permissionCreateOrConnectWithoutPermissionInput[]
    upsert?: role_permissionUpsertWithWhereUniqueWithoutPermissionInput | role_permissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: role_permissionCreateManyPermissionInputEnvelope
    set?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
    disconnect?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
    delete?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
    connect?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
    update?: role_permissionUpdateWithWhereUniqueWithoutPermissionInput | role_permissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: role_permissionUpdateManyWithWhereWithoutPermissionInput | role_permissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: role_permissionScalarWhereInput | role_permissionScalarWhereInput[]
  }

  export type clientCreateNestedOneWithoutQuoteInput = {
    create?: XOR<clientCreateWithoutQuoteInput, clientUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: clientCreateOrConnectWithoutQuoteInput
    connect?: clientWhereUniqueInput
  }

  export type quote_attachmentCreateNestedManyWithoutQuoteInput = {
    create?: XOR<quote_attachmentCreateWithoutQuoteInput, quote_attachmentUncheckedCreateWithoutQuoteInput> | quote_attachmentCreateWithoutQuoteInput[] | quote_attachmentUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: quote_attachmentCreateOrConnectWithoutQuoteInput | quote_attachmentCreateOrConnectWithoutQuoteInput[]
    createMany?: quote_attachmentCreateManyQuoteInputEnvelope
    connect?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
  }

  export type quote_detailCreateNestedManyWithoutQuoteInput = {
    create?: XOR<quote_detailCreateWithoutQuoteInput, quote_detailUncheckedCreateWithoutQuoteInput> | quote_detailCreateWithoutQuoteInput[] | quote_detailUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: quote_detailCreateOrConnectWithoutQuoteInput | quote_detailCreateOrConnectWithoutQuoteInput[]
    createMany?: quote_detailCreateManyQuoteInputEnvelope
    connect?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
  }

  export type quote_attachmentUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<quote_attachmentCreateWithoutQuoteInput, quote_attachmentUncheckedCreateWithoutQuoteInput> | quote_attachmentCreateWithoutQuoteInput[] | quote_attachmentUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: quote_attachmentCreateOrConnectWithoutQuoteInput | quote_attachmentCreateOrConnectWithoutQuoteInput[]
    createMany?: quote_attachmentCreateManyQuoteInputEnvelope
    connect?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
  }

  export type quote_detailUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<quote_detailCreateWithoutQuoteInput, quote_detailUncheckedCreateWithoutQuoteInput> | quote_detailCreateWithoutQuoteInput[] | quote_detailUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: quote_detailCreateOrConnectWithoutQuoteInput | quote_detailCreateOrConnectWithoutQuoteInput[]
    createMany?: quote_detailCreateManyQuoteInputEnvelope
    connect?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
  }

  export type clientUpdateOneWithoutQuoteNestedInput = {
    create?: XOR<clientCreateWithoutQuoteInput, clientUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: clientCreateOrConnectWithoutQuoteInput
    upsert?: clientUpsertWithoutQuoteInput
    disconnect?: clientWhereInput | boolean
    delete?: clientWhereInput | boolean
    connect?: clientWhereUniqueInput
    update?: XOR<XOR<clientUpdateToOneWithWhereWithoutQuoteInput, clientUpdateWithoutQuoteInput>, clientUncheckedUpdateWithoutQuoteInput>
  }

  export type quote_attachmentUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<quote_attachmentCreateWithoutQuoteInput, quote_attachmentUncheckedCreateWithoutQuoteInput> | quote_attachmentCreateWithoutQuoteInput[] | quote_attachmentUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: quote_attachmentCreateOrConnectWithoutQuoteInput | quote_attachmentCreateOrConnectWithoutQuoteInput[]
    upsert?: quote_attachmentUpsertWithWhereUniqueWithoutQuoteInput | quote_attachmentUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: quote_attachmentCreateManyQuoteInputEnvelope
    set?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
    disconnect?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
    delete?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
    connect?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
    update?: quote_attachmentUpdateWithWhereUniqueWithoutQuoteInput | quote_attachmentUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: quote_attachmentUpdateManyWithWhereWithoutQuoteInput | quote_attachmentUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: quote_attachmentScalarWhereInput | quote_attachmentScalarWhereInput[]
  }

  export type quote_detailUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<quote_detailCreateWithoutQuoteInput, quote_detailUncheckedCreateWithoutQuoteInput> | quote_detailCreateWithoutQuoteInput[] | quote_detailUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: quote_detailCreateOrConnectWithoutQuoteInput | quote_detailCreateOrConnectWithoutQuoteInput[]
    upsert?: quote_detailUpsertWithWhereUniqueWithoutQuoteInput | quote_detailUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: quote_detailCreateManyQuoteInputEnvelope
    set?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
    disconnect?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
    delete?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
    connect?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
    update?: quote_detailUpdateWithWhereUniqueWithoutQuoteInput | quote_detailUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: quote_detailUpdateManyWithWhereWithoutQuoteInput | quote_detailUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: quote_detailScalarWhereInput | quote_detailScalarWhereInput[]
  }

  export type quote_attachmentUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<quote_attachmentCreateWithoutQuoteInput, quote_attachmentUncheckedCreateWithoutQuoteInput> | quote_attachmentCreateWithoutQuoteInput[] | quote_attachmentUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: quote_attachmentCreateOrConnectWithoutQuoteInput | quote_attachmentCreateOrConnectWithoutQuoteInput[]
    upsert?: quote_attachmentUpsertWithWhereUniqueWithoutQuoteInput | quote_attachmentUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: quote_attachmentCreateManyQuoteInputEnvelope
    set?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
    disconnect?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
    delete?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
    connect?: quote_attachmentWhereUniqueInput | quote_attachmentWhereUniqueInput[]
    update?: quote_attachmentUpdateWithWhereUniqueWithoutQuoteInput | quote_attachmentUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: quote_attachmentUpdateManyWithWhereWithoutQuoteInput | quote_attachmentUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: quote_attachmentScalarWhereInput | quote_attachmentScalarWhereInput[]
  }

  export type quote_detailUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<quote_detailCreateWithoutQuoteInput, quote_detailUncheckedCreateWithoutQuoteInput> | quote_detailCreateWithoutQuoteInput[] | quote_detailUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: quote_detailCreateOrConnectWithoutQuoteInput | quote_detailCreateOrConnectWithoutQuoteInput[]
    upsert?: quote_detailUpsertWithWhereUniqueWithoutQuoteInput | quote_detailUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: quote_detailCreateManyQuoteInputEnvelope
    set?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
    disconnect?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
    delete?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
    connect?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
    update?: quote_detailUpdateWithWhereUniqueWithoutQuoteInput | quote_detailUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: quote_detailUpdateManyWithWhereWithoutQuoteInput | quote_detailUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: quote_detailScalarWhereInput | quote_detailScalarWhereInput[]
  }

  export type invoiceCreateNestedOneWithoutQuote_attachmentInput = {
    create?: XOR<invoiceCreateWithoutQuote_attachmentInput, invoiceUncheckedCreateWithoutQuote_attachmentInput>
    connectOrCreate?: invoiceCreateOrConnectWithoutQuote_attachmentInput
    connect?: invoiceWhereUniqueInput
  }

  export type quoteCreateNestedOneWithoutQuote_attachmentInput = {
    create?: XOR<quoteCreateWithoutQuote_attachmentInput, quoteUncheckedCreateWithoutQuote_attachmentInput>
    connectOrCreate?: quoteCreateOrConnectWithoutQuote_attachmentInput
    connect?: quoteWhereUniqueInput
  }

  export type invoiceUpdateOneWithoutQuote_attachmentNestedInput = {
    create?: XOR<invoiceCreateWithoutQuote_attachmentInput, invoiceUncheckedCreateWithoutQuote_attachmentInput>
    connectOrCreate?: invoiceCreateOrConnectWithoutQuote_attachmentInput
    upsert?: invoiceUpsertWithoutQuote_attachmentInput
    disconnect?: invoiceWhereInput | boolean
    delete?: invoiceWhereInput | boolean
    connect?: invoiceWhereUniqueInput
    update?: XOR<XOR<invoiceUpdateToOneWithWhereWithoutQuote_attachmentInput, invoiceUpdateWithoutQuote_attachmentInput>, invoiceUncheckedUpdateWithoutQuote_attachmentInput>
  }

  export type quoteUpdateOneWithoutQuote_attachmentNestedInput = {
    create?: XOR<quoteCreateWithoutQuote_attachmentInput, quoteUncheckedCreateWithoutQuote_attachmentInput>
    connectOrCreate?: quoteCreateOrConnectWithoutQuote_attachmentInput
    upsert?: quoteUpsertWithoutQuote_attachmentInput
    disconnect?: quoteWhereInput | boolean
    delete?: quoteWhereInput | boolean
    connect?: quoteWhereUniqueInput
    update?: XOR<XOR<quoteUpdateToOneWithWhereWithoutQuote_attachmentInput, quoteUpdateWithoutQuote_attachmentInput>, quoteUncheckedUpdateWithoutQuote_attachmentInput>
  }

  export type quoteCreateNestedOneWithoutQuote_detailInput = {
    create?: XOR<quoteCreateWithoutQuote_detailInput, quoteUncheckedCreateWithoutQuote_detailInput>
    connectOrCreate?: quoteCreateOrConnectWithoutQuote_detailInput
    connect?: quoteWhereUniqueInput
  }

  export type serviceCreateNestedOneWithoutQuote_detailInput = {
    create?: XOR<serviceCreateWithoutQuote_detailInput, serviceUncheckedCreateWithoutQuote_detailInput>
    connectOrCreate?: serviceCreateOrConnectWithoutQuote_detailInput
    connect?: serviceWhereUniqueInput
  }

  export type quoteUpdateOneWithoutQuote_detailNestedInput = {
    create?: XOR<quoteCreateWithoutQuote_detailInput, quoteUncheckedCreateWithoutQuote_detailInput>
    connectOrCreate?: quoteCreateOrConnectWithoutQuote_detailInput
    upsert?: quoteUpsertWithoutQuote_detailInput
    disconnect?: quoteWhereInput | boolean
    delete?: quoteWhereInput | boolean
    connect?: quoteWhereUniqueInput
    update?: XOR<XOR<quoteUpdateToOneWithWhereWithoutQuote_detailInput, quoteUpdateWithoutQuote_detailInput>, quoteUncheckedUpdateWithoutQuote_detailInput>
  }

  export type serviceUpdateOneWithoutQuote_detailNestedInput = {
    create?: XOR<serviceCreateWithoutQuote_detailInput, serviceUncheckedCreateWithoutQuote_detailInput>
    connectOrCreate?: serviceCreateOrConnectWithoutQuote_detailInput
    upsert?: serviceUpsertWithoutQuote_detailInput
    disconnect?: serviceWhereInput | boolean
    delete?: serviceWhereInput | boolean
    connect?: serviceWhereUniqueInput
    update?: XOR<XOR<serviceUpdateToOneWithWhereWithoutQuote_detailInput, serviceUpdateWithoutQuote_detailInput>, serviceUncheckedUpdateWithoutQuote_detailInput>
  }

  export type logCreateNestedManyWithoutRoleInput = {
    create?: XOR<logCreateWithoutRoleInput, logUncheckedCreateWithoutRoleInput> | logCreateWithoutRoleInput[] | logUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: logCreateOrConnectWithoutRoleInput | logCreateOrConnectWithoutRoleInput[]
    createMany?: logCreateManyRoleInputEnvelope
    connect?: logWhereUniqueInput | logWhereUniqueInput[]
  }

  export type role_permissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<role_permissionCreateWithoutRoleInput, role_permissionUncheckedCreateWithoutRoleInput> | role_permissionCreateWithoutRoleInput[] | role_permissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: role_permissionCreateOrConnectWithoutRoleInput | role_permissionCreateOrConnectWithoutRoleInput[]
    createMany?: role_permissionCreateManyRoleInputEnvelope
    connect?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
  }

  export type userCreateNestedManyWithoutRoleInput = {
    create?: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput> | userCreateWithoutRoleInput[] | userUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userCreateOrConnectWithoutRoleInput | userCreateOrConnectWithoutRoleInput[]
    createMany?: userCreateManyRoleInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type logUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<logCreateWithoutRoleInput, logUncheckedCreateWithoutRoleInput> | logCreateWithoutRoleInput[] | logUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: logCreateOrConnectWithoutRoleInput | logCreateOrConnectWithoutRoleInput[]
    createMany?: logCreateManyRoleInputEnvelope
    connect?: logWhereUniqueInput | logWhereUniqueInput[]
  }

  export type role_permissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<role_permissionCreateWithoutRoleInput, role_permissionUncheckedCreateWithoutRoleInput> | role_permissionCreateWithoutRoleInput[] | role_permissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: role_permissionCreateOrConnectWithoutRoleInput | role_permissionCreateOrConnectWithoutRoleInput[]
    createMany?: role_permissionCreateManyRoleInputEnvelope
    connect?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput> | userCreateWithoutRoleInput[] | userUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userCreateOrConnectWithoutRoleInput | userCreateOrConnectWithoutRoleInput[]
    createMany?: userCreateManyRoleInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type logUpdateManyWithoutRoleNestedInput = {
    create?: XOR<logCreateWithoutRoleInput, logUncheckedCreateWithoutRoleInput> | logCreateWithoutRoleInput[] | logUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: logCreateOrConnectWithoutRoleInput | logCreateOrConnectWithoutRoleInput[]
    upsert?: logUpsertWithWhereUniqueWithoutRoleInput | logUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: logCreateManyRoleInputEnvelope
    set?: logWhereUniqueInput | logWhereUniqueInput[]
    disconnect?: logWhereUniqueInput | logWhereUniqueInput[]
    delete?: logWhereUniqueInput | logWhereUniqueInput[]
    connect?: logWhereUniqueInput | logWhereUniqueInput[]
    update?: logUpdateWithWhereUniqueWithoutRoleInput | logUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: logUpdateManyWithWhereWithoutRoleInput | logUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: logScalarWhereInput | logScalarWhereInput[]
  }

  export type role_permissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<role_permissionCreateWithoutRoleInput, role_permissionUncheckedCreateWithoutRoleInput> | role_permissionCreateWithoutRoleInput[] | role_permissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: role_permissionCreateOrConnectWithoutRoleInput | role_permissionCreateOrConnectWithoutRoleInput[]
    upsert?: role_permissionUpsertWithWhereUniqueWithoutRoleInput | role_permissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: role_permissionCreateManyRoleInputEnvelope
    set?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
    disconnect?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
    delete?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
    connect?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
    update?: role_permissionUpdateWithWhereUniqueWithoutRoleInput | role_permissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: role_permissionUpdateManyWithWhereWithoutRoleInput | role_permissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: role_permissionScalarWhereInput | role_permissionScalarWhereInput[]
  }

  export type userUpdateManyWithoutRoleNestedInput = {
    create?: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput> | userCreateWithoutRoleInput[] | userUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userCreateOrConnectWithoutRoleInput | userCreateOrConnectWithoutRoleInput[]
    upsert?: userUpsertWithWhereUniqueWithoutRoleInput | userUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: userCreateManyRoleInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutRoleInput | userUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: userUpdateManyWithWhereWithoutRoleInput | userUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type logUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<logCreateWithoutRoleInput, logUncheckedCreateWithoutRoleInput> | logCreateWithoutRoleInput[] | logUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: logCreateOrConnectWithoutRoleInput | logCreateOrConnectWithoutRoleInput[]
    upsert?: logUpsertWithWhereUniqueWithoutRoleInput | logUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: logCreateManyRoleInputEnvelope
    set?: logWhereUniqueInput | logWhereUniqueInput[]
    disconnect?: logWhereUniqueInput | logWhereUniqueInput[]
    delete?: logWhereUniqueInput | logWhereUniqueInput[]
    connect?: logWhereUniqueInput | logWhereUniqueInput[]
    update?: logUpdateWithWhereUniqueWithoutRoleInput | logUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: logUpdateManyWithWhereWithoutRoleInput | logUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: logScalarWhereInput | logScalarWhereInput[]
  }

  export type role_permissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<role_permissionCreateWithoutRoleInput, role_permissionUncheckedCreateWithoutRoleInput> | role_permissionCreateWithoutRoleInput[] | role_permissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: role_permissionCreateOrConnectWithoutRoleInput | role_permissionCreateOrConnectWithoutRoleInput[]
    upsert?: role_permissionUpsertWithWhereUniqueWithoutRoleInput | role_permissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: role_permissionCreateManyRoleInputEnvelope
    set?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
    disconnect?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
    delete?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
    connect?: role_permissionWhereUniqueInput | role_permissionWhereUniqueInput[]
    update?: role_permissionUpdateWithWhereUniqueWithoutRoleInput | role_permissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: role_permissionUpdateManyWithWhereWithoutRoleInput | role_permissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: role_permissionScalarWhereInput | role_permissionScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput> | userCreateWithoutRoleInput[] | userUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userCreateOrConnectWithoutRoleInput | userCreateOrConnectWithoutRoleInput[]
    upsert?: userUpsertWithWhereUniqueWithoutRoleInput | userUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: userCreateManyRoleInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutRoleInput | userUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: userUpdateManyWithWhereWithoutRoleInput | userUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type permissionCreateNestedOneWithoutRole_permissionInput = {
    create?: XOR<permissionCreateWithoutRole_permissionInput, permissionUncheckedCreateWithoutRole_permissionInput>
    connectOrCreate?: permissionCreateOrConnectWithoutRole_permissionInput
    connect?: permissionWhereUniqueInput
  }

  export type roleCreateNestedOneWithoutRole_permissionInput = {
    create?: XOR<roleCreateWithoutRole_permissionInput, roleUncheckedCreateWithoutRole_permissionInput>
    connectOrCreate?: roleCreateOrConnectWithoutRole_permissionInput
    connect?: roleWhereUniqueInput
  }

  export type permissionUpdateOneWithoutRole_permissionNestedInput = {
    create?: XOR<permissionCreateWithoutRole_permissionInput, permissionUncheckedCreateWithoutRole_permissionInput>
    connectOrCreate?: permissionCreateOrConnectWithoutRole_permissionInput
    upsert?: permissionUpsertWithoutRole_permissionInput
    disconnect?: permissionWhereInput | boolean
    delete?: permissionWhereInput | boolean
    connect?: permissionWhereUniqueInput
    update?: XOR<XOR<permissionUpdateToOneWithWhereWithoutRole_permissionInput, permissionUpdateWithoutRole_permissionInput>, permissionUncheckedUpdateWithoutRole_permissionInput>
  }

  export type roleUpdateOneWithoutRole_permissionNestedInput = {
    create?: XOR<roleCreateWithoutRole_permissionInput, roleUncheckedCreateWithoutRole_permissionInput>
    connectOrCreate?: roleCreateOrConnectWithoutRole_permissionInput
    upsert?: roleUpsertWithoutRole_permissionInput
    disconnect?: roleWhereInput | boolean
    delete?: roleWhereInput | boolean
    connect?: roleWhereUniqueInput
    update?: XOR<XOR<roleUpdateToOneWithWhereWithoutRole_permissionInput, roleUpdateWithoutRole_permissionInput>, roleUncheckedUpdateWithoutRole_permissionInput>
  }

  export type client_serviceCreateNestedManyWithoutServiceInput = {
    create?: XOR<client_serviceCreateWithoutServiceInput, client_serviceUncheckedCreateWithoutServiceInput> | client_serviceCreateWithoutServiceInput[] | client_serviceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: client_serviceCreateOrConnectWithoutServiceInput | client_serviceCreateOrConnectWithoutServiceInput[]
    createMany?: client_serviceCreateManyServiceInputEnvelope
    connect?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
  }

  export type invoice_detailCreateNestedManyWithoutServiceInput = {
    create?: XOR<invoice_detailCreateWithoutServiceInput, invoice_detailUncheckedCreateWithoutServiceInput> | invoice_detailCreateWithoutServiceInput[] | invoice_detailUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: invoice_detailCreateOrConnectWithoutServiceInput | invoice_detailCreateOrConnectWithoutServiceInput[]
    createMany?: invoice_detailCreateManyServiceInputEnvelope
    connect?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
  }

  export type quote_detailCreateNestedManyWithoutServiceInput = {
    create?: XOR<quote_detailCreateWithoutServiceInput, quote_detailUncheckedCreateWithoutServiceInput> | quote_detailCreateWithoutServiceInput[] | quote_detailUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: quote_detailCreateOrConnectWithoutServiceInput | quote_detailCreateOrConnectWithoutServiceInput[]
    createMany?: quote_detailCreateManyServiceInputEnvelope
    connect?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
  }

  export type service_categoryCreateNestedOneWithoutServiceInput = {
    create?: XOR<service_categoryCreateWithoutServiceInput, service_categoryUncheckedCreateWithoutServiceInput>
    connectOrCreate?: service_categoryCreateOrConnectWithoutServiceInput
    connect?: service_categoryWhereUniqueInput
  }

  export type service_usageCreateNestedManyWithoutServiceInput = {
    create?: XOR<service_usageCreateWithoutServiceInput, service_usageUncheckedCreateWithoutServiceInput> | service_usageCreateWithoutServiceInput[] | service_usageUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: service_usageCreateOrConnectWithoutServiceInput | service_usageCreateOrConnectWithoutServiceInput[]
    createMany?: service_usageCreateManyServiceInputEnvelope
    connect?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
  }

  export type client_serviceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<client_serviceCreateWithoutServiceInput, client_serviceUncheckedCreateWithoutServiceInput> | client_serviceCreateWithoutServiceInput[] | client_serviceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: client_serviceCreateOrConnectWithoutServiceInput | client_serviceCreateOrConnectWithoutServiceInput[]
    createMany?: client_serviceCreateManyServiceInputEnvelope
    connect?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
  }

  export type invoice_detailUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<invoice_detailCreateWithoutServiceInput, invoice_detailUncheckedCreateWithoutServiceInput> | invoice_detailCreateWithoutServiceInput[] | invoice_detailUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: invoice_detailCreateOrConnectWithoutServiceInput | invoice_detailCreateOrConnectWithoutServiceInput[]
    createMany?: invoice_detailCreateManyServiceInputEnvelope
    connect?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
  }

  export type quote_detailUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<quote_detailCreateWithoutServiceInput, quote_detailUncheckedCreateWithoutServiceInput> | quote_detailCreateWithoutServiceInput[] | quote_detailUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: quote_detailCreateOrConnectWithoutServiceInput | quote_detailCreateOrConnectWithoutServiceInput[]
    createMany?: quote_detailCreateManyServiceInputEnvelope
    connect?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
  }

  export type service_usageUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<service_usageCreateWithoutServiceInput, service_usageUncheckedCreateWithoutServiceInput> | service_usageCreateWithoutServiceInput[] | service_usageUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: service_usageCreateOrConnectWithoutServiceInput | service_usageCreateOrConnectWithoutServiceInput[]
    createMany?: service_usageCreateManyServiceInputEnvelope
    connect?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
  }

  export type client_serviceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<client_serviceCreateWithoutServiceInput, client_serviceUncheckedCreateWithoutServiceInput> | client_serviceCreateWithoutServiceInput[] | client_serviceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: client_serviceCreateOrConnectWithoutServiceInput | client_serviceCreateOrConnectWithoutServiceInput[]
    upsert?: client_serviceUpsertWithWhereUniqueWithoutServiceInput | client_serviceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: client_serviceCreateManyServiceInputEnvelope
    set?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
    disconnect?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
    delete?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
    connect?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
    update?: client_serviceUpdateWithWhereUniqueWithoutServiceInput | client_serviceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: client_serviceUpdateManyWithWhereWithoutServiceInput | client_serviceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: client_serviceScalarWhereInput | client_serviceScalarWhereInput[]
  }

  export type invoice_detailUpdateManyWithoutServiceNestedInput = {
    create?: XOR<invoice_detailCreateWithoutServiceInput, invoice_detailUncheckedCreateWithoutServiceInput> | invoice_detailCreateWithoutServiceInput[] | invoice_detailUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: invoice_detailCreateOrConnectWithoutServiceInput | invoice_detailCreateOrConnectWithoutServiceInput[]
    upsert?: invoice_detailUpsertWithWhereUniqueWithoutServiceInput | invoice_detailUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: invoice_detailCreateManyServiceInputEnvelope
    set?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
    disconnect?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
    delete?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
    connect?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
    update?: invoice_detailUpdateWithWhereUniqueWithoutServiceInput | invoice_detailUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: invoice_detailUpdateManyWithWhereWithoutServiceInput | invoice_detailUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: invoice_detailScalarWhereInput | invoice_detailScalarWhereInput[]
  }

  export type quote_detailUpdateManyWithoutServiceNestedInput = {
    create?: XOR<quote_detailCreateWithoutServiceInput, quote_detailUncheckedCreateWithoutServiceInput> | quote_detailCreateWithoutServiceInput[] | quote_detailUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: quote_detailCreateOrConnectWithoutServiceInput | quote_detailCreateOrConnectWithoutServiceInput[]
    upsert?: quote_detailUpsertWithWhereUniqueWithoutServiceInput | quote_detailUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: quote_detailCreateManyServiceInputEnvelope
    set?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
    disconnect?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
    delete?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
    connect?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
    update?: quote_detailUpdateWithWhereUniqueWithoutServiceInput | quote_detailUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: quote_detailUpdateManyWithWhereWithoutServiceInput | quote_detailUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: quote_detailScalarWhereInput | quote_detailScalarWhereInput[]
  }

  export type service_categoryUpdateOneWithoutServiceNestedInput = {
    create?: XOR<service_categoryCreateWithoutServiceInput, service_categoryUncheckedCreateWithoutServiceInput>
    connectOrCreate?: service_categoryCreateOrConnectWithoutServiceInput
    upsert?: service_categoryUpsertWithoutServiceInput
    disconnect?: service_categoryWhereInput | boolean
    delete?: service_categoryWhereInput | boolean
    connect?: service_categoryWhereUniqueInput
    update?: XOR<XOR<service_categoryUpdateToOneWithWhereWithoutServiceInput, service_categoryUpdateWithoutServiceInput>, service_categoryUncheckedUpdateWithoutServiceInput>
  }

  export type service_usageUpdateManyWithoutServiceNestedInput = {
    create?: XOR<service_usageCreateWithoutServiceInput, service_usageUncheckedCreateWithoutServiceInput> | service_usageCreateWithoutServiceInput[] | service_usageUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: service_usageCreateOrConnectWithoutServiceInput | service_usageCreateOrConnectWithoutServiceInput[]
    upsert?: service_usageUpsertWithWhereUniqueWithoutServiceInput | service_usageUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: service_usageCreateManyServiceInputEnvelope
    set?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
    disconnect?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
    delete?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
    connect?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
    update?: service_usageUpdateWithWhereUniqueWithoutServiceInput | service_usageUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: service_usageUpdateManyWithWhereWithoutServiceInput | service_usageUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: service_usageScalarWhereInput | service_usageScalarWhereInput[]
  }

  export type client_serviceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<client_serviceCreateWithoutServiceInput, client_serviceUncheckedCreateWithoutServiceInput> | client_serviceCreateWithoutServiceInput[] | client_serviceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: client_serviceCreateOrConnectWithoutServiceInput | client_serviceCreateOrConnectWithoutServiceInput[]
    upsert?: client_serviceUpsertWithWhereUniqueWithoutServiceInput | client_serviceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: client_serviceCreateManyServiceInputEnvelope
    set?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
    disconnect?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
    delete?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
    connect?: client_serviceWhereUniqueInput | client_serviceWhereUniqueInput[]
    update?: client_serviceUpdateWithWhereUniqueWithoutServiceInput | client_serviceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: client_serviceUpdateManyWithWhereWithoutServiceInput | client_serviceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: client_serviceScalarWhereInput | client_serviceScalarWhereInput[]
  }

  export type invoice_detailUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<invoice_detailCreateWithoutServiceInput, invoice_detailUncheckedCreateWithoutServiceInput> | invoice_detailCreateWithoutServiceInput[] | invoice_detailUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: invoice_detailCreateOrConnectWithoutServiceInput | invoice_detailCreateOrConnectWithoutServiceInput[]
    upsert?: invoice_detailUpsertWithWhereUniqueWithoutServiceInput | invoice_detailUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: invoice_detailCreateManyServiceInputEnvelope
    set?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
    disconnect?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
    delete?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
    connect?: invoice_detailWhereUniqueInput | invoice_detailWhereUniqueInput[]
    update?: invoice_detailUpdateWithWhereUniqueWithoutServiceInput | invoice_detailUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: invoice_detailUpdateManyWithWhereWithoutServiceInput | invoice_detailUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: invoice_detailScalarWhereInput | invoice_detailScalarWhereInput[]
  }

  export type quote_detailUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<quote_detailCreateWithoutServiceInput, quote_detailUncheckedCreateWithoutServiceInput> | quote_detailCreateWithoutServiceInput[] | quote_detailUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: quote_detailCreateOrConnectWithoutServiceInput | quote_detailCreateOrConnectWithoutServiceInput[]
    upsert?: quote_detailUpsertWithWhereUniqueWithoutServiceInput | quote_detailUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: quote_detailCreateManyServiceInputEnvelope
    set?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
    disconnect?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
    delete?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
    connect?: quote_detailWhereUniqueInput | quote_detailWhereUniqueInput[]
    update?: quote_detailUpdateWithWhereUniqueWithoutServiceInput | quote_detailUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: quote_detailUpdateManyWithWhereWithoutServiceInput | quote_detailUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: quote_detailScalarWhereInput | quote_detailScalarWhereInput[]
  }

  export type service_usageUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<service_usageCreateWithoutServiceInput, service_usageUncheckedCreateWithoutServiceInput> | service_usageCreateWithoutServiceInput[] | service_usageUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: service_usageCreateOrConnectWithoutServiceInput | service_usageCreateOrConnectWithoutServiceInput[]
    upsert?: service_usageUpsertWithWhereUniqueWithoutServiceInput | service_usageUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: service_usageCreateManyServiceInputEnvelope
    set?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
    disconnect?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
    delete?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
    connect?: service_usageWhereUniqueInput | service_usageWhereUniqueInput[]
    update?: service_usageUpdateWithWhereUniqueWithoutServiceInput | service_usageUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: service_usageUpdateManyWithWhereWithoutServiceInput | service_usageUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: service_usageScalarWhereInput | service_usageScalarWhereInput[]
  }

  export type serviceCreateNestedManyWithoutService_categoryInput = {
    create?: XOR<serviceCreateWithoutService_categoryInput, serviceUncheckedCreateWithoutService_categoryInput> | serviceCreateWithoutService_categoryInput[] | serviceUncheckedCreateWithoutService_categoryInput[]
    connectOrCreate?: serviceCreateOrConnectWithoutService_categoryInput | serviceCreateOrConnectWithoutService_categoryInput[]
    createMany?: serviceCreateManyService_categoryInputEnvelope
    connect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
  }

  export type serviceUncheckedCreateNestedManyWithoutService_categoryInput = {
    create?: XOR<serviceCreateWithoutService_categoryInput, serviceUncheckedCreateWithoutService_categoryInput> | serviceCreateWithoutService_categoryInput[] | serviceUncheckedCreateWithoutService_categoryInput[]
    connectOrCreate?: serviceCreateOrConnectWithoutService_categoryInput | serviceCreateOrConnectWithoutService_categoryInput[]
    createMany?: serviceCreateManyService_categoryInputEnvelope
    connect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
  }

  export type serviceUpdateManyWithoutService_categoryNestedInput = {
    create?: XOR<serviceCreateWithoutService_categoryInput, serviceUncheckedCreateWithoutService_categoryInput> | serviceCreateWithoutService_categoryInput[] | serviceUncheckedCreateWithoutService_categoryInput[]
    connectOrCreate?: serviceCreateOrConnectWithoutService_categoryInput | serviceCreateOrConnectWithoutService_categoryInput[]
    upsert?: serviceUpsertWithWhereUniqueWithoutService_categoryInput | serviceUpsertWithWhereUniqueWithoutService_categoryInput[]
    createMany?: serviceCreateManyService_categoryInputEnvelope
    set?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    disconnect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    delete?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    connect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    update?: serviceUpdateWithWhereUniqueWithoutService_categoryInput | serviceUpdateWithWhereUniqueWithoutService_categoryInput[]
    updateMany?: serviceUpdateManyWithWhereWithoutService_categoryInput | serviceUpdateManyWithWhereWithoutService_categoryInput[]
    deleteMany?: serviceScalarWhereInput | serviceScalarWhereInput[]
  }

  export type serviceUncheckedUpdateManyWithoutService_categoryNestedInput = {
    create?: XOR<serviceCreateWithoutService_categoryInput, serviceUncheckedCreateWithoutService_categoryInput> | serviceCreateWithoutService_categoryInput[] | serviceUncheckedCreateWithoutService_categoryInput[]
    connectOrCreate?: serviceCreateOrConnectWithoutService_categoryInput | serviceCreateOrConnectWithoutService_categoryInput[]
    upsert?: serviceUpsertWithWhereUniqueWithoutService_categoryInput | serviceUpsertWithWhereUniqueWithoutService_categoryInput[]
    createMany?: serviceCreateManyService_categoryInputEnvelope
    set?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    disconnect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    delete?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    connect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    update?: serviceUpdateWithWhereUniqueWithoutService_categoryInput | serviceUpdateWithWhereUniqueWithoutService_categoryInput[]
    updateMany?: serviceUpdateManyWithWhereWithoutService_categoryInput | serviceUpdateManyWithWhereWithoutService_categoryInput[]
    deleteMany?: serviceScalarWhereInput | serviceScalarWhereInput[]
  }

  export type clientCreateNestedOneWithoutService_usageInput = {
    create?: XOR<clientCreateWithoutService_usageInput, clientUncheckedCreateWithoutService_usageInput>
    connectOrCreate?: clientCreateOrConnectWithoutService_usageInput
    connect?: clientWhereUniqueInput
  }

  export type serviceCreateNestedOneWithoutService_usageInput = {
    create?: XOR<serviceCreateWithoutService_usageInput, serviceUncheckedCreateWithoutService_usageInput>
    connectOrCreate?: serviceCreateOrConnectWithoutService_usageInput
    connect?: serviceWhereUniqueInput
  }

  export type clientUpdateOneWithoutService_usageNestedInput = {
    create?: XOR<clientCreateWithoutService_usageInput, clientUncheckedCreateWithoutService_usageInput>
    connectOrCreate?: clientCreateOrConnectWithoutService_usageInput
    upsert?: clientUpsertWithoutService_usageInput
    disconnect?: clientWhereInput | boolean
    delete?: clientWhereInput | boolean
    connect?: clientWhereUniqueInput
    update?: XOR<XOR<clientUpdateToOneWithWhereWithoutService_usageInput, clientUpdateWithoutService_usageInput>, clientUncheckedUpdateWithoutService_usageInput>
  }

  export type serviceUpdateOneWithoutService_usageNestedInput = {
    create?: XOR<serviceCreateWithoutService_usageInput, serviceUncheckedCreateWithoutService_usageInput>
    connectOrCreate?: serviceCreateOrConnectWithoutService_usageInput
    upsert?: serviceUpsertWithoutService_usageInput
    disconnect?: serviceWhereInput | boolean
    delete?: serviceWhereInput | boolean
    connect?: serviceWhereUniqueInput
    update?: XOR<XOR<serviceUpdateToOneWithWhereWithoutService_usageInput, serviceUpdateWithoutService_usageInput>, serviceUncheckedUpdateWithoutService_usageInput>
  }

  export type logCreateNestedManyWithoutUserInput = {
    create?: XOR<logCreateWithoutUserInput, logUncheckedCreateWithoutUserInput> | logCreateWithoutUserInput[] | logUncheckedCreateWithoutUserInput[]
    connectOrCreate?: logCreateOrConnectWithoutUserInput | logCreateOrConnectWithoutUserInput[]
    createMany?: logCreateManyUserInputEnvelope
    connect?: logWhereUniqueInput | logWhereUniqueInput[]
  }

  export type clientCreateNestedOneWithoutUserInput = {
    create?: XOR<clientCreateWithoutUserInput, clientUncheckedCreateWithoutUserInput>
    connectOrCreate?: clientCreateOrConnectWithoutUserInput
    connect?: clientWhereUniqueInput
  }

  export type roleCreateNestedOneWithoutUserInput = {
    create?: XOR<roleCreateWithoutUserInput, roleUncheckedCreateWithoutUserInput>
    connectOrCreate?: roleCreateOrConnectWithoutUserInput
    connect?: roleWhereUniqueInput
  }

  export type logUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<logCreateWithoutUserInput, logUncheckedCreateWithoutUserInput> | logCreateWithoutUserInput[] | logUncheckedCreateWithoutUserInput[]
    connectOrCreate?: logCreateOrConnectWithoutUserInput | logCreateOrConnectWithoutUserInput[]
    createMany?: logCreateManyUserInputEnvelope
    connect?: logWhereUniqueInput | logWhereUniqueInput[]
  }

  export type logUpdateManyWithoutUserNestedInput = {
    create?: XOR<logCreateWithoutUserInput, logUncheckedCreateWithoutUserInput> | logCreateWithoutUserInput[] | logUncheckedCreateWithoutUserInput[]
    connectOrCreate?: logCreateOrConnectWithoutUserInput | logCreateOrConnectWithoutUserInput[]
    upsert?: logUpsertWithWhereUniqueWithoutUserInput | logUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: logCreateManyUserInputEnvelope
    set?: logWhereUniqueInput | logWhereUniqueInput[]
    disconnect?: logWhereUniqueInput | logWhereUniqueInput[]
    delete?: logWhereUniqueInput | logWhereUniqueInput[]
    connect?: logWhereUniqueInput | logWhereUniqueInput[]
    update?: logUpdateWithWhereUniqueWithoutUserInput | logUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: logUpdateManyWithWhereWithoutUserInput | logUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: logScalarWhereInput | logScalarWhereInput[]
  }

  export type clientUpdateOneWithoutUserNestedInput = {
    create?: XOR<clientCreateWithoutUserInput, clientUncheckedCreateWithoutUserInput>
    connectOrCreate?: clientCreateOrConnectWithoutUserInput
    upsert?: clientUpsertWithoutUserInput
    disconnect?: clientWhereInput | boolean
    delete?: clientWhereInput | boolean
    connect?: clientWhereUniqueInput
    update?: XOR<XOR<clientUpdateToOneWithWhereWithoutUserInput, clientUpdateWithoutUserInput>, clientUncheckedUpdateWithoutUserInput>
  }

  export type roleUpdateOneWithoutUserNestedInput = {
    create?: XOR<roleCreateWithoutUserInput, roleUncheckedCreateWithoutUserInput>
    connectOrCreate?: roleCreateOrConnectWithoutUserInput
    upsert?: roleUpsertWithoutUserInput
    disconnect?: roleWhereInput | boolean
    delete?: roleWhereInput | boolean
    connect?: roleWhereUniqueInput
    update?: XOR<XOR<roleUpdateToOneWithWhereWithoutUserInput, roleUpdateWithoutUserInput>, roleUncheckedUpdateWithoutUserInput>
  }

  export type logUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<logCreateWithoutUserInput, logUncheckedCreateWithoutUserInput> | logCreateWithoutUserInput[] | logUncheckedCreateWithoutUserInput[]
    connectOrCreate?: logCreateOrConnectWithoutUserInput | logCreateOrConnectWithoutUserInput[]
    upsert?: logUpsertWithWhereUniqueWithoutUserInput | logUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: logCreateManyUserInputEnvelope
    set?: logWhereUniqueInput | logWhereUniqueInput[]
    disconnect?: logWhereUniqueInput | logWhereUniqueInput[]
    delete?: logWhereUniqueInput | logWhereUniqueInput[]
    connect?: logWhereUniqueInput | logWhereUniqueInput[]
    update?: logUpdateWithWhereUniqueWithoutUserInput | logUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: logUpdateManyWithWhereWithoutUserInput | logUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: logScalarWhereInput | logScalarWhereInput[]
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type client_detailsCreateWithoutClientInput = {
    id: string
    value?: string | null
    client_parameter?: client_parameterCreateNestedOneWithoutClient_detailsInput
  }

  export type client_detailsUncheckedCreateWithoutClientInput = {
    id: string
    c_parameter_id?: string | null
    value?: string | null
  }

  export type client_detailsCreateOrConnectWithoutClientInput = {
    where: client_detailsWhereUniqueInput
    create: XOR<client_detailsCreateWithoutClientInput, client_detailsUncheckedCreateWithoutClientInput>
  }

  export type client_detailsCreateManyClientInputEnvelope = {
    data: client_detailsCreateManyClientInput | client_detailsCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type client_serviceCreateWithoutClientInput = {
    id: string
    created?: Date | string | null
    updated?: Date | string | null
    started?: Date | string | null
    delivery?: Date | string | null
    expiry?: Date | string | null
    frequency?: string | null
    unit?: string | null
    url_api?: string | null
    token_api?: string | null
    service?: serviceCreateNestedOneWithoutClient_serviceInput
  }

  export type client_serviceUncheckedCreateWithoutClientInput = {
    id: string
    service_id?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    started?: Date | string | null
    delivery?: Date | string | null
    expiry?: Date | string | null
    frequency?: string | null
    unit?: string | null
    url_api?: string | null
    token_api?: string | null
  }

  export type client_serviceCreateOrConnectWithoutClientInput = {
    where: client_serviceWhereUniqueInput
    create: XOR<client_serviceCreateWithoutClientInput, client_serviceUncheckedCreateWithoutClientInput>
  }

  export type client_serviceCreateManyClientInputEnvelope = {
    data: client_serviceCreateManyClientInput | client_serviceCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type invoiceCreateWithoutClientInput = {
    id: string
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    invoice_detail?: invoice_detailCreateNestedManyWithoutInvoiceInput
    payment_attachment?: payment_attachmentCreateNestedManyWithoutInvoiceInput
    quote_attachment?: quote_attachmentCreateNestedManyWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateWithoutClientInput = {
    id: string
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    invoice_detail?: invoice_detailUncheckedCreateNestedManyWithoutInvoiceInput
    payment_attachment?: payment_attachmentUncheckedCreateNestedManyWithoutInvoiceInput
    quote_attachment?: quote_attachmentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type invoiceCreateOrConnectWithoutClientInput = {
    where: invoiceWhereUniqueInput
    create: XOR<invoiceCreateWithoutClientInput, invoiceUncheckedCreateWithoutClientInput>
  }

  export type invoiceCreateManyClientInputEnvelope = {
    data: invoiceCreateManyClientInput | invoiceCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type logCreateWithoutClientInput = {
    id: string
    user_name?: string | null
    ip?: string | null
    type?: string | null
    detail?: string | null
    created?: Date | string | null
    role?: roleCreateNestedOneWithoutLogInput
    user?: userCreateNestedOneWithoutLogInput
  }

  export type logUncheckedCreateWithoutClientInput = {
    id: string
    user_id?: string | null
    role_id?: string | null
    user_name?: string | null
    ip?: string | null
    type?: string | null
    detail?: string | null
    created?: Date | string | null
  }

  export type logCreateOrConnectWithoutClientInput = {
    where: logWhereUniqueInput
    create: XOR<logCreateWithoutClientInput, logUncheckedCreateWithoutClientInput>
  }

  export type logCreateManyClientInputEnvelope = {
    data: logCreateManyClientInput | logCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type paymentCreateWithoutClientInput = {
    id: string
    code?: string | null
    value?: string | null
    status_pay?: string | null
    method?: string | null
    type?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    payment_method?: payment_methodCreateNestedOneWithoutPaymentInput
  }

  export type paymentUncheckedCreateWithoutClientInput = {
    id: string
    code?: string | null
    value?: string | null
    status_pay?: string | null
    method?: string | null
    payment_method_id?: string | null
    type?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type paymentCreateOrConnectWithoutClientInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutClientInput, paymentUncheckedCreateWithoutClientInput>
  }

  export type paymentCreateManyClientInputEnvelope = {
    data: paymentCreateManyClientInput | paymentCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type quoteCreateWithoutClientInput = {
    id: string
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    quote_attachment?: quote_attachmentCreateNestedManyWithoutQuoteInput
    quote_detail?: quote_detailCreateNestedManyWithoutQuoteInput
  }

  export type quoteUncheckedCreateWithoutClientInput = {
    id: string
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    quote_attachment?: quote_attachmentUncheckedCreateNestedManyWithoutQuoteInput
    quote_detail?: quote_detailUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type quoteCreateOrConnectWithoutClientInput = {
    where: quoteWhereUniqueInput
    create: XOR<quoteCreateWithoutClientInput, quoteUncheckedCreateWithoutClientInput>
  }

  export type quoteCreateManyClientInputEnvelope = {
    data: quoteCreateManyClientInput | quoteCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type service_usageCreateWithoutClientInput = {
    id: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    usage?: string | null
    created?: Date | string | null
    status?: string | null
    service?: serviceCreateNestedOneWithoutService_usageInput
  }

  export type service_usageUncheckedCreateWithoutClientInput = {
    id: string
    service_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    usage?: string | null
    created?: Date | string | null
    status?: string | null
  }

  export type service_usageCreateOrConnectWithoutClientInput = {
    where: service_usageWhereUniqueInput
    create: XOR<service_usageCreateWithoutClientInput, service_usageUncheckedCreateWithoutClientInput>
  }

  export type service_usageCreateManyClientInputEnvelope = {
    data: service_usageCreateManyClientInput | service_usageCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutClientInput = {
    id: string
    user?: string | null
    pass?: string | null
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    log?: logCreateNestedManyWithoutUserInput
    role?: roleCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutClientInput = {
    id: string
    role_id?: string | null
    user?: string | null
    pass?: string | null
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    log?: logUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutClientInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutClientInput, userUncheckedCreateWithoutClientInput>
  }

  export type userCreateManyClientInputEnvelope = {
    data: userCreateManyClientInput | userCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type client_detailsUpsertWithWhereUniqueWithoutClientInput = {
    where: client_detailsWhereUniqueInput
    update: XOR<client_detailsUpdateWithoutClientInput, client_detailsUncheckedUpdateWithoutClientInput>
    create: XOR<client_detailsCreateWithoutClientInput, client_detailsUncheckedCreateWithoutClientInput>
  }

  export type client_detailsUpdateWithWhereUniqueWithoutClientInput = {
    where: client_detailsWhereUniqueInput
    data: XOR<client_detailsUpdateWithoutClientInput, client_detailsUncheckedUpdateWithoutClientInput>
  }

  export type client_detailsUpdateManyWithWhereWithoutClientInput = {
    where: client_detailsScalarWhereInput
    data: XOR<client_detailsUpdateManyMutationInput, client_detailsUncheckedUpdateManyWithoutClientInput>
  }

  export type client_detailsScalarWhereInput = {
    AND?: client_detailsScalarWhereInput | client_detailsScalarWhereInput[]
    OR?: client_detailsScalarWhereInput[]
    NOT?: client_detailsScalarWhereInput | client_detailsScalarWhereInput[]
    id?: UuidFilter<"client_details"> | string
    client_id?: UuidNullableFilter<"client_details"> | string | null
    c_parameter_id?: UuidNullableFilter<"client_details"> | string | null
    value?: StringNullableFilter<"client_details"> | string | null
  }

  export type client_serviceUpsertWithWhereUniqueWithoutClientInput = {
    where: client_serviceWhereUniqueInput
    update: XOR<client_serviceUpdateWithoutClientInput, client_serviceUncheckedUpdateWithoutClientInput>
    create: XOR<client_serviceCreateWithoutClientInput, client_serviceUncheckedCreateWithoutClientInput>
  }

  export type client_serviceUpdateWithWhereUniqueWithoutClientInput = {
    where: client_serviceWhereUniqueInput
    data: XOR<client_serviceUpdateWithoutClientInput, client_serviceUncheckedUpdateWithoutClientInput>
  }

  export type client_serviceUpdateManyWithWhereWithoutClientInput = {
    where: client_serviceScalarWhereInput
    data: XOR<client_serviceUpdateManyMutationInput, client_serviceUncheckedUpdateManyWithoutClientInput>
  }

  export type client_serviceScalarWhereInput = {
    AND?: client_serviceScalarWhereInput | client_serviceScalarWhereInput[]
    OR?: client_serviceScalarWhereInput[]
    NOT?: client_serviceScalarWhereInput | client_serviceScalarWhereInput[]
    id?: UuidFilter<"client_service"> | string
    client_id?: UuidNullableFilter<"client_service"> | string | null
    service_id?: UuidNullableFilter<"client_service"> | string | null
    created?: DateTimeNullableFilter<"client_service"> | Date | string | null
    updated?: DateTimeNullableFilter<"client_service"> | Date | string | null
    started?: DateTimeNullableFilter<"client_service"> | Date | string | null
    delivery?: DateTimeNullableFilter<"client_service"> | Date | string | null
    expiry?: DateTimeNullableFilter<"client_service"> | Date | string | null
    frequency?: StringNullableFilter<"client_service"> | string | null
    unit?: StringNullableFilter<"client_service"> | string | null
    url_api?: StringNullableFilter<"client_service"> | string | null
    token_api?: StringNullableFilter<"client_service"> | string | null
  }

  export type invoiceUpsertWithWhereUniqueWithoutClientInput = {
    where: invoiceWhereUniqueInput
    update: XOR<invoiceUpdateWithoutClientInput, invoiceUncheckedUpdateWithoutClientInput>
    create: XOR<invoiceCreateWithoutClientInput, invoiceUncheckedCreateWithoutClientInput>
  }

  export type invoiceUpdateWithWhereUniqueWithoutClientInput = {
    where: invoiceWhereUniqueInput
    data: XOR<invoiceUpdateWithoutClientInput, invoiceUncheckedUpdateWithoutClientInput>
  }

  export type invoiceUpdateManyWithWhereWithoutClientInput = {
    where: invoiceScalarWhereInput
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyWithoutClientInput>
  }

  export type invoiceScalarWhereInput = {
    AND?: invoiceScalarWhereInput | invoiceScalarWhereInput[]
    OR?: invoiceScalarWhereInput[]
    NOT?: invoiceScalarWhereInput | invoiceScalarWhereInput[]
    id?: UuidFilter<"invoice"> | string
    client_id?: UuidNullableFilter<"invoice"> | string | null
    description?: StringNullableFilter<"invoice"> | string | null
    value?: StringNullableFilter<"invoice"> | string | null
    url?: StringNullableFilter<"invoice"> | string | null
    created?: DateTimeNullableFilter<"invoice"> | Date | string | null
    updated?: DateTimeNullableFilter<"invoice"> | Date | string | null
    status?: BoolNullableFilter<"invoice"> | boolean | null
  }

  export type logUpsertWithWhereUniqueWithoutClientInput = {
    where: logWhereUniqueInput
    update: XOR<logUpdateWithoutClientInput, logUncheckedUpdateWithoutClientInput>
    create: XOR<logCreateWithoutClientInput, logUncheckedCreateWithoutClientInput>
  }

  export type logUpdateWithWhereUniqueWithoutClientInput = {
    where: logWhereUniqueInput
    data: XOR<logUpdateWithoutClientInput, logUncheckedUpdateWithoutClientInput>
  }

  export type logUpdateManyWithWhereWithoutClientInput = {
    where: logScalarWhereInput
    data: XOR<logUpdateManyMutationInput, logUncheckedUpdateManyWithoutClientInput>
  }

  export type logScalarWhereInput = {
    AND?: logScalarWhereInput | logScalarWhereInput[]
    OR?: logScalarWhereInput[]
    NOT?: logScalarWhereInput | logScalarWhereInput[]
    id?: UuidFilter<"log"> | string
    user_id?: UuidNullableFilter<"log"> | string | null
    role_id?: UuidNullableFilter<"log"> | string | null
    client_id?: UuidNullableFilter<"log"> | string | null
    user_name?: StringNullableFilter<"log"> | string | null
    ip?: StringNullableFilter<"log"> | string | null
    type?: StringNullableFilter<"log"> | string | null
    detail?: StringNullableFilter<"log"> | string | null
    created?: DateTimeNullableFilter<"log"> | Date | string | null
  }

  export type paymentUpsertWithWhereUniqueWithoutClientInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutClientInput, paymentUncheckedUpdateWithoutClientInput>
    create: XOR<paymentCreateWithoutClientInput, paymentUncheckedCreateWithoutClientInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutClientInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutClientInput, paymentUncheckedUpdateWithoutClientInput>
  }

  export type paymentUpdateManyWithWhereWithoutClientInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutClientInput>
  }

  export type paymentScalarWhereInput = {
    AND?: paymentScalarWhereInput | paymentScalarWhereInput[]
    OR?: paymentScalarWhereInput[]
    NOT?: paymentScalarWhereInput | paymentScalarWhereInput[]
    id?: UuidFilter<"payment"> | string
    client_id?: UuidNullableFilter<"payment"> | string | null
    code?: StringNullableFilter<"payment"> | string | null
    value?: StringNullableFilter<"payment"> | string | null
    status_pay?: StringNullableFilter<"payment"> | string | null
    method?: StringNullableFilter<"payment"> | string | null
    payment_method_id?: UuidNullableFilter<"payment"> | string | null
    type?: StringNullableFilter<"payment"> | string | null
    url?: StringNullableFilter<"payment"> | string | null
    created?: DateTimeNullableFilter<"payment"> | Date | string | null
    updated?: DateTimeNullableFilter<"payment"> | Date | string | null
    status?: BoolNullableFilter<"payment"> | boolean | null
  }

  export type quoteUpsertWithWhereUniqueWithoutClientInput = {
    where: quoteWhereUniqueInput
    update: XOR<quoteUpdateWithoutClientInput, quoteUncheckedUpdateWithoutClientInput>
    create: XOR<quoteCreateWithoutClientInput, quoteUncheckedCreateWithoutClientInput>
  }

  export type quoteUpdateWithWhereUniqueWithoutClientInput = {
    where: quoteWhereUniqueInput
    data: XOR<quoteUpdateWithoutClientInput, quoteUncheckedUpdateWithoutClientInput>
  }

  export type quoteUpdateManyWithWhereWithoutClientInput = {
    where: quoteScalarWhereInput
    data: XOR<quoteUpdateManyMutationInput, quoteUncheckedUpdateManyWithoutClientInput>
  }

  export type quoteScalarWhereInput = {
    AND?: quoteScalarWhereInput | quoteScalarWhereInput[]
    OR?: quoteScalarWhereInput[]
    NOT?: quoteScalarWhereInput | quoteScalarWhereInput[]
    id?: UuidFilter<"quote"> | string
    client_id?: UuidNullableFilter<"quote"> | string | null
    description?: StringNullableFilter<"quote"> | string | null
    value?: StringNullableFilter<"quote"> | string | null
    url?: StringNullableFilter<"quote"> | string | null
    created?: DateTimeNullableFilter<"quote"> | Date | string | null
    updated?: DateTimeNullableFilter<"quote"> | Date | string | null
    status?: BoolNullableFilter<"quote"> | boolean | null
  }

  export type service_usageUpsertWithWhereUniqueWithoutClientInput = {
    where: service_usageWhereUniqueInput
    update: XOR<service_usageUpdateWithoutClientInput, service_usageUncheckedUpdateWithoutClientInput>
    create: XOR<service_usageCreateWithoutClientInput, service_usageUncheckedCreateWithoutClientInput>
  }

  export type service_usageUpdateWithWhereUniqueWithoutClientInput = {
    where: service_usageWhereUniqueInput
    data: XOR<service_usageUpdateWithoutClientInput, service_usageUncheckedUpdateWithoutClientInput>
  }

  export type service_usageUpdateManyWithWhereWithoutClientInput = {
    where: service_usageScalarWhereInput
    data: XOR<service_usageUpdateManyMutationInput, service_usageUncheckedUpdateManyWithoutClientInput>
  }

  export type service_usageScalarWhereInput = {
    AND?: service_usageScalarWhereInput | service_usageScalarWhereInput[]
    OR?: service_usageScalarWhereInput[]
    NOT?: service_usageScalarWhereInput | service_usageScalarWhereInput[]
    id?: UuidFilter<"service_usage"> | string
    client_id?: UuidNullableFilter<"service_usage"> | string | null
    service_id?: UuidNullableFilter<"service_usage"> | string | null
    start_date?: DateTimeNullableFilter<"service_usage"> | Date | string | null
    end_date?: DateTimeNullableFilter<"service_usage"> | Date | string | null
    usage?: StringNullableFilter<"service_usage"> | string | null
    created?: DateTimeNullableFilter<"service_usage"> | Date | string | null
    status?: StringNullableFilter<"service_usage"> | string | null
  }

  export type userUpsertWithWhereUniqueWithoutClientInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutClientInput, userUncheckedUpdateWithoutClientInput>
    create: XOR<userCreateWithoutClientInput, userUncheckedCreateWithoutClientInput>
  }

  export type userUpdateWithWhereUniqueWithoutClientInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutClientInput, userUncheckedUpdateWithoutClientInput>
  }

  export type userUpdateManyWithWhereWithoutClientInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutClientInput>
  }

  export type userScalarWhereInput = {
    AND?: userScalarWhereInput | userScalarWhereInput[]
    OR?: userScalarWhereInput[]
    NOT?: userScalarWhereInput | userScalarWhereInput[]
    id?: UuidFilter<"user"> | string
    role_id?: UuidNullableFilter<"user"> | string | null
    client_id?: UuidNullableFilter<"user"> | string | null
    user?: StringNullableFilter<"user"> | string | null
    pass?: StringNullableFilter<"user"> | string | null
    name?: StringNullableFilter<"user"> | string | null
    created?: DateTimeNullableFilter<"user"> | Date | string | null
    updated?: DateTimeNullableFilter<"user"> | Date | string | null
    status?: BoolNullableFilter<"user"> | boolean | null
  }

  export type client_parameterCreateWithoutClient_detailsInput = {
    id: string
    name?: string | null
  }

  export type client_parameterUncheckedCreateWithoutClient_detailsInput = {
    id: string
    name?: string | null
  }

  export type client_parameterCreateOrConnectWithoutClient_detailsInput = {
    where: client_parameterWhereUniqueInput
    create: XOR<client_parameterCreateWithoutClient_detailsInput, client_parameterUncheckedCreateWithoutClient_detailsInput>
  }

  export type clientCreateWithoutClient_detailsInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_service?: client_serviceCreateNestedManyWithoutClientInput
    invoice?: invoiceCreateNestedManyWithoutClientInput
    log?: logCreateNestedManyWithoutClientInput
    payment?: paymentCreateNestedManyWithoutClientInput
    quote?: quoteCreateNestedManyWithoutClientInput
    service_usage?: service_usageCreateNestedManyWithoutClientInput
    user?: userCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateWithoutClient_detailsInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_service?: client_serviceUncheckedCreateNestedManyWithoutClientInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClientInput
    log?: logUncheckedCreateNestedManyWithoutClientInput
    payment?: paymentUncheckedCreateNestedManyWithoutClientInput
    quote?: quoteUncheckedCreateNestedManyWithoutClientInput
    service_usage?: service_usageUncheckedCreateNestedManyWithoutClientInput
    user?: userUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientCreateOrConnectWithoutClient_detailsInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutClient_detailsInput, clientUncheckedCreateWithoutClient_detailsInput>
  }

  export type client_parameterUpsertWithoutClient_detailsInput = {
    update: XOR<client_parameterUpdateWithoutClient_detailsInput, client_parameterUncheckedUpdateWithoutClient_detailsInput>
    create: XOR<client_parameterCreateWithoutClient_detailsInput, client_parameterUncheckedCreateWithoutClient_detailsInput>
    where?: client_parameterWhereInput
  }

  export type client_parameterUpdateToOneWithWhereWithoutClient_detailsInput = {
    where?: client_parameterWhereInput
    data: XOR<client_parameterUpdateWithoutClient_detailsInput, client_parameterUncheckedUpdateWithoutClient_detailsInput>
  }

  export type client_parameterUpdateWithoutClient_detailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type client_parameterUncheckedUpdateWithoutClient_detailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientUpsertWithoutClient_detailsInput = {
    update: XOR<clientUpdateWithoutClient_detailsInput, clientUncheckedUpdateWithoutClient_detailsInput>
    create: XOR<clientCreateWithoutClient_detailsInput, clientUncheckedCreateWithoutClient_detailsInput>
    where?: clientWhereInput
  }

  export type clientUpdateToOneWithWhereWithoutClient_detailsInput = {
    where?: clientWhereInput
    data: XOR<clientUpdateWithoutClient_detailsInput, clientUncheckedUpdateWithoutClient_detailsInput>
  }

  export type clientUpdateWithoutClient_detailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_service?: client_serviceUpdateManyWithoutClientNestedInput
    invoice?: invoiceUpdateManyWithoutClientNestedInput
    log?: logUpdateManyWithoutClientNestedInput
    payment?: paymentUpdateManyWithoutClientNestedInput
    quote?: quoteUpdateManyWithoutClientNestedInput
    service_usage?: service_usageUpdateManyWithoutClientNestedInput
    user?: userUpdateManyWithoutClientNestedInput
  }

  export type clientUncheckedUpdateWithoutClient_detailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_service?: client_serviceUncheckedUpdateManyWithoutClientNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClientNestedInput
    log?: logUncheckedUpdateManyWithoutClientNestedInput
    payment?: paymentUncheckedUpdateManyWithoutClientNestedInput
    quote?: quoteUncheckedUpdateManyWithoutClientNestedInput
    service_usage?: service_usageUncheckedUpdateManyWithoutClientNestedInput
    user?: userUncheckedUpdateManyWithoutClientNestedInput
  }

  export type client_detailsCreateWithoutClient_parameterInput = {
    id: string
    value?: string | null
    client?: clientCreateNestedOneWithoutClient_detailsInput
  }

  export type client_detailsUncheckedCreateWithoutClient_parameterInput = {
    id: string
    client_id?: string | null
    value?: string | null
  }

  export type client_detailsCreateOrConnectWithoutClient_parameterInput = {
    where: client_detailsWhereUniqueInput
    create: XOR<client_detailsCreateWithoutClient_parameterInput, client_detailsUncheckedCreateWithoutClient_parameterInput>
  }

  export type client_detailsCreateManyClient_parameterInputEnvelope = {
    data: client_detailsCreateManyClient_parameterInput | client_detailsCreateManyClient_parameterInput[]
    skipDuplicates?: boolean
  }

  export type client_detailsUpsertWithWhereUniqueWithoutClient_parameterInput = {
    where: client_detailsWhereUniqueInput
    update: XOR<client_detailsUpdateWithoutClient_parameterInput, client_detailsUncheckedUpdateWithoutClient_parameterInput>
    create: XOR<client_detailsCreateWithoutClient_parameterInput, client_detailsUncheckedCreateWithoutClient_parameterInput>
  }

  export type client_detailsUpdateWithWhereUniqueWithoutClient_parameterInput = {
    where: client_detailsWhereUniqueInput
    data: XOR<client_detailsUpdateWithoutClient_parameterInput, client_detailsUncheckedUpdateWithoutClient_parameterInput>
  }

  export type client_detailsUpdateManyWithWhereWithoutClient_parameterInput = {
    where: client_detailsScalarWhereInput
    data: XOR<client_detailsUpdateManyMutationInput, client_detailsUncheckedUpdateManyWithoutClient_parameterInput>
  }

  export type clientCreateWithoutClient_serviceInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_details?: client_detailsCreateNestedManyWithoutClientInput
    invoice?: invoiceCreateNestedManyWithoutClientInput
    log?: logCreateNestedManyWithoutClientInput
    payment?: paymentCreateNestedManyWithoutClientInput
    quote?: quoteCreateNestedManyWithoutClientInput
    service_usage?: service_usageCreateNestedManyWithoutClientInput
    user?: userCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateWithoutClient_serviceInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_details?: client_detailsUncheckedCreateNestedManyWithoutClientInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClientInput
    log?: logUncheckedCreateNestedManyWithoutClientInput
    payment?: paymentUncheckedCreateNestedManyWithoutClientInput
    quote?: quoteUncheckedCreateNestedManyWithoutClientInput
    service_usage?: service_usageUncheckedCreateNestedManyWithoutClientInput
    user?: userUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientCreateOrConnectWithoutClient_serviceInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutClient_serviceInput, clientUncheckedCreateWithoutClient_serviceInput>
  }

  export type serviceCreateWithoutClient_serviceInput = {
    id: string
    name?: string | null
    unit?: string | null
    description?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    invoice_detail?: invoice_detailCreateNestedManyWithoutServiceInput
    quote_detail?: quote_detailCreateNestedManyWithoutServiceInput
    service_category?: service_categoryCreateNestedOneWithoutServiceInput
    service_usage?: service_usageCreateNestedManyWithoutServiceInput
  }

  export type serviceUncheckedCreateWithoutClient_serviceInput = {
    id: string
    service_category_id?: string | null
    name?: string | null
    unit?: string | null
    description?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    invoice_detail?: invoice_detailUncheckedCreateNestedManyWithoutServiceInput
    quote_detail?: quote_detailUncheckedCreateNestedManyWithoutServiceInput
    service_usage?: service_usageUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceCreateOrConnectWithoutClient_serviceInput = {
    where: serviceWhereUniqueInput
    create: XOR<serviceCreateWithoutClient_serviceInput, serviceUncheckedCreateWithoutClient_serviceInput>
  }

  export type clientUpsertWithoutClient_serviceInput = {
    update: XOR<clientUpdateWithoutClient_serviceInput, clientUncheckedUpdateWithoutClient_serviceInput>
    create: XOR<clientCreateWithoutClient_serviceInput, clientUncheckedCreateWithoutClient_serviceInput>
    where?: clientWhereInput
  }

  export type clientUpdateToOneWithWhereWithoutClient_serviceInput = {
    where?: clientWhereInput
    data: XOR<clientUpdateWithoutClient_serviceInput, clientUncheckedUpdateWithoutClient_serviceInput>
  }

  export type clientUpdateWithoutClient_serviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_details?: client_detailsUpdateManyWithoutClientNestedInput
    invoice?: invoiceUpdateManyWithoutClientNestedInput
    log?: logUpdateManyWithoutClientNestedInput
    payment?: paymentUpdateManyWithoutClientNestedInput
    quote?: quoteUpdateManyWithoutClientNestedInput
    service_usage?: service_usageUpdateManyWithoutClientNestedInput
    user?: userUpdateManyWithoutClientNestedInput
  }

  export type clientUncheckedUpdateWithoutClient_serviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_details?: client_detailsUncheckedUpdateManyWithoutClientNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClientNestedInput
    log?: logUncheckedUpdateManyWithoutClientNestedInput
    payment?: paymentUncheckedUpdateManyWithoutClientNestedInput
    quote?: quoteUncheckedUpdateManyWithoutClientNestedInput
    service_usage?: service_usageUncheckedUpdateManyWithoutClientNestedInput
    user?: userUncheckedUpdateManyWithoutClientNestedInput
  }

  export type serviceUpsertWithoutClient_serviceInput = {
    update: XOR<serviceUpdateWithoutClient_serviceInput, serviceUncheckedUpdateWithoutClient_serviceInput>
    create: XOR<serviceCreateWithoutClient_serviceInput, serviceUncheckedCreateWithoutClient_serviceInput>
    where?: serviceWhereInput
  }

  export type serviceUpdateToOneWithWhereWithoutClient_serviceInput = {
    where?: serviceWhereInput
    data: XOR<serviceUpdateWithoutClient_serviceInput, serviceUncheckedUpdateWithoutClient_serviceInput>
  }

  export type serviceUpdateWithoutClient_serviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    invoice_detail?: invoice_detailUpdateManyWithoutServiceNestedInput
    quote_detail?: quote_detailUpdateManyWithoutServiceNestedInput
    service_category?: service_categoryUpdateOneWithoutServiceNestedInput
    service_usage?: service_usageUpdateManyWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateWithoutClient_serviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    invoice_detail?: invoice_detailUncheckedUpdateManyWithoutServiceNestedInput
    quote_detail?: quote_detailUncheckedUpdateManyWithoutServiceNestedInput
    service_usage?: service_usageUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type clientCreateWithoutInvoiceInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_details?: client_detailsCreateNestedManyWithoutClientInput
    client_service?: client_serviceCreateNestedManyWithoutClientInput
    log?: logCreateNestedManyWithoutClientInput
    payment?: paymentCreateNestedManyWithoutClientInput
    quote?: quoteCreateNestedManyWithoutClientInput
    service_usage?: service_usageCreateNestedManyWithoutClientInput
    user?: userCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateWithoutInvoiceInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_details?: client_detailsUncheckedCreateNestedManyWithoutClientInput
    client_service?: client_serviceUncheckedCreateNestedManyWithoutClientInput
    log?: logUncheckedCreateNestedManyWithoutClientInput
    payment?: paymentUncheckedCreateNestedManyWithoutClientInput
    quote?: quoteUncheckedCreateNestedManyWithoutClientInput
    service_usage?: service_usageUncheckedCreateNestedManyWithoutClientInput
    user?: userUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientCreateOrConnectWithoutInvoiceInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutInvoiceInput, clientUncheckedCreateWithoutInvoiceInput>
  }

  export type invoice_detailCreateWithoutInvoiceInput = {
    id: string
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    service?: serviceCreateNestedOneWithoutInvoice_detailInput
  }

  export type invoice_detailUncheckedCreateWithoutInvoiceInput = {
    id: string
    service_id?: string | null
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type invoice_detailCreateOrConnectWithoutInvoiceInput = {
    where: invoice_detailWhereUniqueInput
    create: XOR<invoice_detailCreateWithoutInvoiceInput, invoice_detailUncheckedCreateWithoutInvoiceInput>
  }

  export type invoice_detailCreateManyInvoiceInputEnvelope = {
    data: invoice_detailCreateManyInvoiceInput | invoice_detailCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type payment_attachmentCreateWithoutInvoiceInput = {
    id: string
  }

  export type payment_attachmentUncheckedCreateWithoutInvoiceInput = {
    id: string
  }

  export type payment_attachmentCreateOrConnectWithoutInvoiceInput = {
    where: payment_attachmentWhereUniqueInput
    create: XOR<payment_attachmentCreateWithoutInvoiceInput, payment_attachmentUncheckedCreateWithoutInvoiceInput>
  }

  export type payment_attachmentCreateManyInvoiceInputEnvelope = {
    data: payment_attachmentCreateManyInvoiceInput | payment_attachmentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type quote_attachmentCreateWithoutInvoiceInput = {
    id: string
    quote?: quoteCreateNestedOneWithoutQuote_attachmentInput
  }

  export type quote_attachmentUncheckedCreateWithoutInvoiceInput = {
    id: string
    quote_id?: string | null
  }

  export type quote_attachmentCreateOrConnectWithoutInvoiceInput = {
    where: quote_attachmentWhereUniqueInput
    create: XOR<quote_attachmentCreateWithoutInvoiceInput, quote_attachmentUncheckedCreateWithoutInvoiceInput>
  }

  export type quote_attachmentCreateManyInvoiceInputEnvelope = {
    data: quote_attachmentCreateManyInvoiceInput | quote_attachmentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type clientUpsertWithoutInvoiceInput = {
    update: XOR<clientUpdateWithoutInvoiceInput, clientUncheckedUpdateWithoutInvoiceInput>
    create: XOR<clientCreateWithoutInvoiceInput, clientUncheckedCreateWithoutInvoiceInput>
    where?: clientWhereInput
  }

  export type clientUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: clientWhereInput
    data: XOR<clientUpdateWithoutInvoiceInput, clientUncheckedUpdateWithoutInvoiceInput>
  }

  export type clientUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_details?: client_detailsUpdateManyWithoutClientNestedInput
    client_service?: client_serviceUpdateManyWithoutClientNestedInput
    log?: logUpdateManyWithoutClientNestedInput
    payment?: paymentUpdateManyWithoutClientNestedInput
    quote?: quoteUpdateManyWithoutClientNestedInput
    service_usage?: service_usageUpdateManyWithoutClientNestedInput
    user?: userUpdateManyWithoutClientNestedInput
  }

  export type clientUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_details?: client_detailsUncheckedUpdateManyWithoutClientNestedInput
    client_service?: client_serviceUncheckedUpdateManyWithoutClientNestedInput
    log?: logUncheckedUpdateManyWithoutClientNestedInput
    payment?: paymentUncheckedUpdateManyWithoutClientNestedInput
    quote?: quoteUncheckedUpdateManyWithoutClientNestedInput
    service_usage?: service_usageUncheckedUpdateManyWithoutClientNestedInput
    user?: userUncheckedUpdateManyWithoutClientNestedInput
  }

  export type invoice_detailUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: invoice_detailWhereUniqueInput
    update: XOR<invoice_detailUpdateWithoutInvoiceInput, invoice_detailUncheckedUpdateWithoutInvoiceInput>
    create: XOR<invoice_detailCreateWithoutInvoiceInput, invoice_detailUncheckedCreateWithoutInvoiceInput>
  }

  export type invoice_detailUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: invoice_detailWhereUniqueInput
    data: XOR<invoice_detailUpdateWithoutInvoiceInput, invoice_detailUncheckedUpdateWithoutInvoiceInput>
  }

  export type invoice_detailUpdateManyWithWhereWithoutInvoiceInput = {
    where: invoice_detailScalarWhereInput
    data: XOR<invoice_detailUpdateManyMutationInput, invoice_detailUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type invoice_detailScalarWhereInput = {
    AND?: invoice_detailScalarWhereInput | invoice_detailScalarWhereInput[]
    OR?: invoice_detailScalarWhereInput[]
    NOT?: invoice_detailScalarWhereInput | invoice_detailScalarWhereInput[]
    id?: UuidFilter<"invoice_detail"> | string
    invoice_id?: UuidNullableFilter<"invoice_detail"> | string | null
    service_id?: UuidNullableFilter<"invoice_detail"> | string | null
    item?: IntNullableFilter<"invoice_detail"> | number | null
    quantity?: IntNullableFilter<"invoice_detail"> | number | null
    total_value?: FloatNullableFilter<"invoice_detail"> | number | null
    created?: DateTimeNullableFilter<"invoice_detail"> | Date | string | null
    updated?: DateTimeNullableFilter<"invoice_detail"> | Date | string | null
    status?: BoolNullableFilter<"invoice_detail"> | boolean | null
  }

  export type payment_attachmentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: payment_attachmentWhereUniqueInput
    update: XOR<payment_attachmentUpdateWithoutInvoiceInput, payment_attachmentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<payment_attachmentCreateWithoutInvoiceInput, payment_attachmentUncheckedCreateWithoutInvoiceInput>
  }

  export type payment_attachmentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: payment_attachmentWhereUniqueInput
    data: XOR<payment_attachmentUpdateWithoutInvoiceInput, payment_attachmentUncheckedUpdateWithoutInvoiceInput>
  }

  export type payment_attachmentUpdateManyWithWhereWithoutInvoiceInput = {
    where: payment_attachmentScalarWhereInput
    data: XOR<payment_attachmentUpdateManyMutationInput, payment_attachmentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type payment_attachmentScalarWhereInput = {
    AND?: payment_attachmentScalarWhereInput | payment_attachmentScalarWhereInput[]
    OR?: payment_attachmentScalarWhereInput[]
    NOT?: payment_attachmentScalarWhereInput | payment_attachmentScalarWhereInput[]
    id?: UuidFilter<"payment_attachment"> | string
    invoice_id?: UuidNullableFilter<"payment_attachment"> | string | null
  }

  export type quote_attachmentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: quote_attachmentWhereUniqueInput
    update: XOR<quote_attachmentUpdateWithoutInvoiceInput, quote_attachmentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<quote_attachmentCreateWithoutInvoiceInput, quote_attachmentUncheckedCreateWithoutInvoiceInput>
  }

  export type quote_attachmentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: quote_attachmentWhereUniqueInput
    data: XOR<quote_attachmentUpdateWithoutInvoiceInput, quote_attachmentUncheckedUpdateWithoutInvoiceInput>
  }

  export type quote_attachmentUpdateManyWithWhereWithoutInvoiceInput = {
    where: quote_attachmentScalarWhereInput
    data: XOR<quote_attachmentUpdateManyMutationInput, quote_attachmentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type quote_attachmentScalarWhereInput = {
    AND?: quote_attachmentScalarWhereInput | quote_attachmentScalarWhereInput[]
    OR?: quote_attachmentScalarWhereInput[]
    NOT?: quote_attachmentScalarWhereInput | quote_attachmentScalarWhereInput[]
    id?: UuidFilter<"quote_attachment"> | string
    quote_id?: UuidNullableFilter<"quote_attachment"> | string | null
    invoice_id?: UuidNullableFilter<"quote_attachment"> | string | null
  }

  export type invoiceCreateWithoutInvoice_detailInput = {
    id: string
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client?: clientCreateNestedOneWithoutInvoiceInput
    payment_attachment?: payment_attachmentCreateNestedManyWithoutInvoiceInput
    quote_attachment?: quote_attachmentCreateNestedManyWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateWithoutInvoice_detailInput = {
    id: string
    client_id?: string | null
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    payment_attachment?: payment_attachmentUncheckedCreateNestedManyWithoutInvoiceInput
    quote_attachment?: quote_attachmentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type invoiceCreateOrConnectWithoutInvoice_detailInput = {
    where: invoiceWhereUniqueInput
    create: XOR<invoiceCreateWithoutInvoice_detailInput, invoiceUncheckedCreateWithoutInvoice_detailInput>
  }

  export type serviceCreateWithoutInvoice_detailInput = {
    id: string
    name?: string | null
    unit?: string | null
    description?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_service?: client_serviceCreateNestedManyWithoutServiceInput
    quote_detail?: quote_detailCreateNestedManyWithoutServiceInput
    service_category?: service_categoryCreateNestedOneWithoutServiceInput
    service_usage?: service_usageCreateNestedManyWithoutServiceInput
  }

  export type serviceUncheckedCreateWithoutInvoice_detailInput = {
    id: string
    service_category_id?: string | null
    name?: string | null
    unit?: string | null
    description?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_service?: client_serviceUncheckedCreateNestedManyWithoutServiceInput
    quote_detail?: quote_detailUncheckedCreateNestedManyWithoutServiceInput
    service_usage?: service_usageUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceCreateOrConnectWithoutInvoice_detailInput = {
    where: serviceWhereUniqueInput
    create: XOR<serviceCreateWithoutInvoice_detailInput, serviceUncheckedCreateWithoutInvoice_detailInput>
  }

  export type invoiceUpsertWithoutInvoice_detailInput = {
    update: XOR<invoiceUpdateWithoutInvoice_detailInput, invoiceUncheckedUpdateWithoutInvoice_detailInput>
    create: XOR<invoiceCreateWithoutInvoice_detailInput, invoiceUncheckedCreateWithoutInvoice_detailInput>
    where?: invoiceWhereInput
  }

  export type invoiceUpdateToOneWithWhereWithoutInvoice_detailInput = {
    where?: invoiceWhereInput
    data: XOR<invoiceUpdateWithoutInvoice_detailInput, invoiceUncheckedUpdateWithoutInvoice_detailInput>
  }

  export type invoiceUpdateWithoutInvoice_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client?: clientUpdateOneWithoutInvoiceNestedInput
    payment_attachment?: payment_attachmentUpdateManyWithoutInvoiceNestedInput
    quote_attachment?: quote_attachmentUpdateManyWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateWithoutInvoice_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_attachment?: payment_attachmentUncheckedUpdateManyWithoutInvoiceNestedInput
    quote_attachment?: quote_attachmentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type serviceUpsertWithoutInvoice_detailInput = {
    update: XOR<serviceUpdateWithoutInvoice_detailInput, serviceUncheckedUpdateWithoutInvoice_detailInput>
    create: XOR<serviceCreateWithoutInvoice_detailInput, serviceUncheckedCreateWithoutInvoice_detailInput>
    where?: serviceWhereInput
  }

  export type serviceUpdateToOneWithWhereWithoutInvoice_detailInput = {
    where?: serviceWhereInput
    data: XOR<serviceUpdateWithoutInvoice_detailInput, serviceUncheckedUpdateWithoutInvoice_detailInput>
  }

  export type serviceUpdateWithoutInvoice_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_service?: client_serviceUpdateManyWithoutServiceNestedInput
    quote_detail?: quote_detailUpdateManyWithoutServiceNestedInput
    service_category?: service_categoryUpdateOneWithoutServiceNestedInput
    service_usage?: service_usageUpdateManyWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateWithoutInvoice_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_service?: client_serviceUncheckedUpdateManyWithoutServiceNestedInput
    quote_detail?: quote_detailUncheckedUpdateManyWithoutServiceNestedInput
    service_usage?: service_usageUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type clientCreateWithoutLogInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_details?: client_detailsCreateNestedManyWithoutClientInput
    client_service?: client_serviceCreateNestedManyWithoutClientInput
    invoice?: invoiceCreateNestedManyWithoutClientInput
    payment?: paymentCreateNestedManyWithoutClientInput
    quote?: quoteCreateNestedManyWithoutClientInput
    service_usage?: service_usageCreateNestedManyWithoutClientInput
    user?: userCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateWithoutLogInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_details?: client_detailsUncheckedCreateNestedManyWithoutClientInput
    client_service?: client_serviceUncheckedCreateNestedManyWithoutClientInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClientInput
    payment?: paymentUncheckedCreateNestedManyWithoutClientInput
    quote?: quoteUncheckedCreateNestedManyWithoutClientInput
    service_usage?: service_usageUncheckedCreateNestedManyWithoutClientInput
    user?: userUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientCreateOrConnectWithoutLogInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutLogInput, clientUncheckedCreateWithoutLogInput>
  }

  export type roleCreateWithoutLogInput = {
    id: string
    name?: string | null
    role_category?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    description?: string | null
    role_permission?: role_permissionCreateNestedManyWithoutRoleInput
    user?: userCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateWithoutLogInput = {
    id: string
    name?: string | null
    role_category?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    description?: string | null
    role_permission?: role_permissionUncheckedCreateNestedManyWithoutRoleInput
    user?: userUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleCreateOrConnectWithoutLogInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutLogInput, roleUncheckedCreateWithoutLogInput>
  }

  export type userCreateWithoutLogInput = {
    id: string
    user?: string | null
    pass?: string | null
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client?: clientCreateNestedOneWithoutUserInput
    role?: roleCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutLogInput = {
    id: string
    role_id?: string | null
    client_id?: string | null
    user?: string | null
    pass?: string | null
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type userCreateOrConnectWithoutLogInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutLogInput, userUncheckedCreateWithoutLogInput>
  }

  export type clientUpsertWithoutLogInput = {
    update: XOR<clientUpdateWithoutLogInput, clientUncheckedUpdateWithoutLogInput>
    create: XOR<clientCreateWithoutLogInput, clientUncheckedCreateWithoutLogInput>
    where?: clientWhereInput
  }

  export type clientUpdateToOneWithWhereWithoutLogInput = {
    where?: clientWhereInput
    data: XOR<clientUpdateWithoutLogInput, clientUncheckedUpdateWithoutLogInput>
  }

  export type clientUpdateWithoutLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_details?: client_detailsUpdateManyWithoutClientNestedInput
    client_service?: client_serviceUpdateManyWithoutClientNestedInput
    invoice?: invoiceUpdateManyWithoutClientNestedInput
    payment?: paymentUpdateManyWithoutClientNestedInput
    quote?: quoteUpdateManyWithoutClientNestedInput
    service_usage?: service_usageUpdateManyWithoutClientNestedInput
    user?: userUpdateManyWithoutClientNestedInput
  }

  export type clientUncheckedUpdateWithoutLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_details?: client_detailsUncheckedUpdateManyWithoutClientNestedInput
    client_service?: client_serviceUncheckedUpdateManyWithoutClientNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClientNestedInput
    payment?: paymentUncheckedUpdateManyWithoutClientNestedInput
    quote?: quoteUncheckedUpdateManyWithoutClientNestedInput
    service_usage?: service_usageUncheckedUpdateManyWithoutClientNestedInput
    user?: userUncheckedUpdateManyWithoutClientNestedInput
  }

  export type roleUpsertWithoutLogInput = {
    update: XOR<roleUpdateWithoutLogInput, roleUncheckedUpdateWithoutLogInput>
    create: XOR<roleCreateWithoutLogInput, roleUncheckedCreateWithoutLogInput>
    where?: roleWhereInput
  }

  export type roleUpdateToOneWithWhereWithoutLogInput = {
    where?: roleWhereInput
    data: XOR<roleUpdateWithoutLogInput, roleUncheckedUpdateWithoutLogInput>
  }

  export type roleUpdateWithoutLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role_category?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role_permission?: role_permissionUpdateManyWithoutRoleNestedInput
    user?: userUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateWithoutLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role_category?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role_permission?: role_permissionUncheckedUpdateManyWithoutRoleNestedInput
    user?: userUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type userUpsertWithoutLogInput = {
    update: XOR<userUpdateWithoutLogInput, userUncheckedUpdateWithoutLogInput>
    create: XOR<userCreateWithoutLogInput, userUncheckedCreateWithoutLogInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutLogInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutLogInput, userUncheckedUpdateWithoutLogInput>
  }

  export type userUpdateWithoutLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client?: clientUpdateOneWithoutUserNestedInput
    role?: roleUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type clientCreateWithoutPaymentInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_details?: client_detailsCreateNestedManyWithoutClientInput
    client_service?: client_serviceCreateNestedManyWithoutClientInput
    invoice?: invoiceCreateNestedManyWithoutClientInput
    log?: logCreateNestedManyWithoutClientInput
    quote?: quoteCreateNestedManyWithoutClientInput
    service_usage?: service_usageCreateNestedManyWithoutClientInput
    user?: userCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateWithoutPaymentInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_details?: client_detailsUncheckedCreateNestedManyWithoutClientInput
    client_service?: client_serviceUncheckedCreateNestedManyWithoutClientInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClientInput
    log?: logUncheckedCreateNestedManyWithoutClientInput
    quote?: quoteUncheckedCreateNestedManyWithoutClientInput
    service_usage?: service_usageUncheckedCreateNestedManyWithoutClientInput
    user?: userUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientCreateOrConnectWithoutPaymentInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutPaymentInput, clientUncheckedCreateWithoutPaymentInput>
  }

  export type payment_methodCreateWithoutPaymentInput = {
    id: string
    name?: string | null
  }

  export type payment_methodUncheckedCreateWithoutPaymentInput = {
    id: string
    name?: string | null
  }

  export type payment_methodCreateOrConnectWithoutPaymentInput = {
    where: payment_methodWhereUniqueInput
    create: XOR<payment_methodCreateWithoutPaymentInput, payment_methodUncheckedCreateWithoutPaymentInput>
  }

  export type clientUpsertWithoutPaymentInput = {
    update: XOR<clientUpdateWithoutPaymentInput, clientUncheckedUpdateWithoutPaymentInput>
    create: XOR<clientCreateWithoutPaymentInput, clientUncheckedCreateWithoutPaymentInput>
    where?: clientWhereInput
  }

  export type clientUpdateToOneWithWhereWithoutPaymentInput = {
    where?: clientWhereInput
    data: XOR<clientUpdateWithoutPaymentInput, clientUncheckedUpdateWithoutPaymentInput>
  }

  export type clientUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_details?: client_detailsUpdateManyWithoutClientNestedInput
    client_service?: client_serviceUpdateManyWithoutClientNestedInput
    invoice?: invoiceUpdateManyWithoutClientNestedInput
    log?: logUpdateManyWithoutClientNestedInput
    quote?: quoteUpdateManyWithoutClientNestedInput
    service_usage?: service_usageUpdateManyWithoutClientNestedInput
    user?: userUpdateManyWithoutClientNestedInput
  }

  export type clientUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_details?: client_detailsUncheckedUpdateManyWithoutClientNestedInput
    client_service?: client_serviceUncheckedUpdateManyWithoutClientNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClientNestedInput
    log?: logUncheckedUpdateManyWithoutClientNestedInput
    quote?: quoteUncheckedUpdateManyWithoutClientNestedInput
    service_usage?: service_usageUncheckedUpdateManyWithoutClientNestedInput
    user?: userUncheckedUpdateManyWithoutClientNestedInput
  }

  export type payment_methodUpsertWithoutPaymentInput = {
    update: XOR<payment_methodUpdateWithoutPaymentInput, payment_methodUncheckedUpdateWithoutPaymentInput>
    create: XOR<payment_methodCreateWithoutPaymentInput, payment_methodUncheckedCreateWithoutPaymentInput>
    where?: payment_methodWhereInput
  }

  export type payment_methodUpdateToOneWithWhereWithoutPaymentInput = {
    where?: payment_methodWhereInput
    data: XOR<payment_methodUpdateWithoutPaymentInput, payment_methodUncheckedUpdateWithoutPaymentInput>
  }

  export type payment_methodUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payment_methodUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invoiceCreateWithoutPayment_attachmentInput = {
    id: string
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client?: clientCreateNestedOneWithoutInvoiceInput
    invoice_detail?: invoice_detailCreateNestedManyWithoutInvoiceInput
    quote_attachment?: quote_attachmentCreateNestedManyWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateWithoutPayment_attachmentInput = {
    id: string
    client_id?: string | null
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    invoice_detail?: invoice_detailUncheckedCreateNestedManyWithoutInvoiceInput
    quote_attachment?: quote_attachmentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type invoiceCreateOrConnectWithoutPayment_attachmentInput = {
    where: invoiceWhereUniqueInput
    create: XOR<invoiceCreateWithoutPayment_attachmentInput, invoiceUncheckedCreateWithoutPayment_attachmentInput>
  }

  export type invoiceUpsertWithoutPayment_attachmentInput = {
    update: XOR<invoiceUpdateWithoutPayment_attachmentInput, invoiceUncheckedUpdateWithoutPayment_attachmentInput>
    create: XOR<invoiceCreateWithoutPayment_attachmentInput, invoiceUncheckedCreateWithoutPayment_attachmentInput>
    where?: invoiceWhereInput
  }

  export type invoiceUpdateToOneWithWhereWithoutPayment_attachmentInput = {
    where?: invoiceWhereInput
    data: XOR<invoiceUpdateWithoutPayment_attachmentInput, invoiceUncheckedUpdateWithoutPayment_attachmentInput>
  }

  export type invoiceUpdateWithoutPayment_attachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client?: clientUpdateOneWithoutInvoiceNestedInput
    invoice_detail?: invoice_detailUpdateManyWithoutInvoiceNestedInput
    quote_attachment?: quote_attachmentUpdateManyWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateWithoutPayment_attachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    invoice_detail?: invoice_detailUncheckedUpdateManyWithoutInvoiceNestedInput
    quote_attachment?: quote_attachmentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type paymentCreateWithoutPayment_methodInput = {
    id: string
    code?: string | null
    value?: string | null
    status_pay?: string | null
    method?: string | null
    type?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client?: clientCreateNestedOneWithoutPaymentInput
  }

  export type paymentUncheckedCreateWithoutPayment_methodInput = {
    id: string
    client_id?: string | null
    code?: string | null
    value?: string | null
    status_pay?: string | null
    method?: string | null
    type?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type paymentCreateOrConnectWithoutPayment_methodInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutPayment_methodInput, paymentUncheckedCreateWithoutPayment_methodInput>
  }

  export type paymentCreateManyPayment_methodInputEnvelope = {
    data: paymentCreateManyPayment_methodInput | paymentCreateManyPayment_methodInput[]
    skipDuplicates?: boolean
  }

  export type paymentUpsertWithWhereUniqueWithoutPayment_methodInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutPayment_methodInput, paymentUncheckedUpdateWithoutPayment_methodInput>
    create: XOR<paymentCreateWithoutPayment_methodInput, paymentUncheckedCreateWithoutPayment_methodInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutPayment_methodInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutPayment_methodInput, paymentUncheckedUpdateWithoutPayment_methodInput>
  }

  export type paymentUpdateManyWithWhereWithoutPayment_methodInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutPayment_methodInput>
  }

  export type role_permissionCreateWithoutPermissionInput = {
    id: string
    role?: roleCreateNestedOneWithoutRole_permissionInput
  }

  export type role_permissionUncheckedCreateWithoutPermissionInput = {
    id: string
    role_id?: string | null
  }

  export type role_permissionCreateOrConnectWithoutPermissionInput = {
    where: role_permissionWhereUniqueInput
    create: XOR<role_permissionCreateWithoutPermissionInput, role_permissionUncheckedCreateWithoutPermissionInput>
  }

  export type role_permissionCreateManyPermissionInputEnvelope = {
    data: role_permissionCreateManyPermissionInput | role_permissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type role_permissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: role_permissionWhereUniqueInput
    update: XOR<role_permissionUpdateWithoutPermissionInput, role_permissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<role_permissionCreateWithoutPermissionInput, role_permissionUncheckedCreateWithoutPermissionInput>
  }

  export type role_permissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: role_permissionWhereUniqueInput
    data: XOR<role_permissionUpdateWithoutPermissionInput, role_permissionUncheckedUpdateWithoutPermissionInput>
  }

  export type role_permissionUpdateManyWithWhereWithoutPermissionInput = {
    where: role_permissionScalarWhereInput
    data: XOR<role_permissionUpdateManyMutationInput, role_permissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type role_permissionScalarWhereInput = {
    AND?: role_permissionScalarWhereInput | role_permissionScalarWhereInput[]
    OR?: role_permissionScalarWhereInput[]
    NOT?: role_permissionScalarWhereInput | role_permissionScalarWhereInput[]
    id?: UuidFilter<"role_permission"> | string
    role_id?: UuidNullableFilter<"role_permission"> | string | null
    permission_id?: UuidNullableFilter<"role_permission"> | string | null
  }

  export type clientCreateWithoutQuoteInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_details?: client_detailsCreateNestedManyWithoutClientInput
    client_service?: client_serviceCreateNestedManyWithoutClientInput
    invoice?: invoiceCreateNestedManyWithoutClientInput
    log?: logCreateNestedManyWithoutClientInput
    payment?: paymentCreateNestedManyWithoutClientInput
    service_usage?: service_usageCreateNestedManyWithoutClientInput
    user?: userCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateWithoutQuoteInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_details?: client_detailsUncheckedCreateNestedManyWithoutClientInput
    client_service?: client_serviceUncheckedCreateNestedManyWithoutClientInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClientInput
    log?: logUncheckedCreateNestedManyWithoutClientInput
    payment?: paymentUncheckedCreateNestedManyWithoutClientInput
    service_usage?: service_usageUncheckedCreateNestedManyWithoutClientInput
    user?: userUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientCreateOrConnectWithoutQuoteInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutQuoteInput, clientUncheckedCreateWithoutQuoteInput>
  }

  export type quote_attachmentCreateWithoutQuoteInput = {
    id: string
    invoice?: invoiceCreateNestedOneWithoutQuote_attachmentInput
  }

  export type quote_attachmentUncheckedCreateWithoutQuoteInput = {
    id: string
    invoice_id?: string | null
  }

  export type quote_attachmentCreateOrConnectWithoutQuoteInput = {
    where: quote_attachmentWhereUniqueInput
    create: XOR<quote_attachmentCreateWithoutQuoteInput, quote_attachmentUncheckedCreateWithoutQuoteInput>
  }

  export type quote_attachmentCreateManyQuoteInputEnvelope = {
    data: quote_attachmentCreateManyQuoteInput | quote_attachmentCreateManyQuoteInput[]
    skipDuplicates?: boolean
  }

  export type quote_detailCreateWithoutQuoteInput = {
    id: string
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    service?: serviceCreateNestedOneWithoutQuote_detailInput
  }

  export type quote_detailUncheckedCreateWithoutQuoteInput = {
    id: string
    service_id?: string | null
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type quote_detailCreateOrConnectWithoutQuoteInput = {
    where: quote_detailWhereUniqueInput
    create: XOR<quote_detailCreateWithoutQuoteInput, quote_detailUncheckedCreateWithoutQuoteInput>
  }

  export type quote_detailCreateManyQuoteInputEnvelope = {
    data: quote_detailCreateManyQuoteInput | quote_detailCreateManyQuoteInput[]
    skipDuplicates?: boolean
  }

  export type clientUpsertWithoutQuoteInput = {
    update: XOR<clientUpdateWithoutQuoteInput, clientUncheckedUpdateWithoutQuoteInput>
    create: XOR<clientCreateWithoutQuoteInput, clientUncheckedCreateWithoutQuoteInput>
    where?: clientWhereInput
  }

  export type clientUpdateToOneWithWhereWithoutQuoteInput = {
    where?: clientWhereInput
    data: XOR<clientUpdateWithoutQuoteInput, clientUncheckedUpdateWithoutQuoteInput>
  }

  export type clientUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_details?: client_detailsUpdateManyWithoutClientNestedInput
    client_service?: client_serviceUpdateManyWithoutClientNestedInput
    invoice?: invoiceUpdateManyWithoutClientNestedInput
    log?: logUpdateManyWithoutClientNestedInput
    payment?: paymentUpdateManyWithoutClientNestedInput
    service_usage?: service_usageUpdateManyWithoutClientNestedInput
    user?: userUpdateManyWithoutClientNestedInput
  }

  export type clientUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_details?: client_detailsUncheckedUpdateManyWithoutClientNestedInput
    client_service?: client_serviceUncheckedUpdateManyWithoutClientNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClientNestedInput
    log?: logUncheckedUpdateManyWithoutClientNestedInput
    payment?: paymentUncheckedUpdateManyWithoutClientNestedInput
    service_usage?: service_usageUncheckedUpdateManyWithoutClientNestedInput
    user?: userUncheckedUpdateManyWithoutClientNestedInput
  }

  export type quote_attachmentUpsertWithWhereUniqueWithoutQuoteInput = {
    where: quote_attachmentWhereUniqueInput
    update: XOR<quote_attachmentUpdateWithoutQuoteInput, quote_attachmentUncheckedUpdateWithoutQuoteInput>
    create: XOR<quote_attachmentCreateWithoutQuoteInput, quote_attachmentUncheckedCreateWithoutQuoteInput>
  }

  export type quote_attachmentUpdateWithWhereUniqueWithoutQuoteInput = {
    where: quote_attachmentWhereUniqueInput
    data: XOR<quote_attachmentUpdateWithoutQuoteInput, quote_attachmentUncheckedUpdateWithoutQuoteInput>
  }

  export type quote_attachmentUpdateManyWithWhereWithoutQuoteInput = {
    where: quote_attachmentScalarWhereInput
    data: XOR<quote_attachmentUpdateManyMutationInput, quote_attachmentUncheckedUpdateManyWithoutQuoteInput>
  }

  export type quote_detailUpsertWithWhereUniqueWithoutQuoteInput = {
    where: quote_detailWhereUniqueInput
    update: XOR<quote_detailUpdateWithoutQuoteInput, quote_detailUncheckedUpdateWithoutQuoteInput>
    create: XOR<quote_detailCreateWithoutQuoteInput, quote_detailUncheckedCreateWithoutQuoteInput>
  }

  export type quote_detailUpdateWithWhereUniqueWithoutQuoteInput = {
    where: quote_detailWhereUniqueInput
    data: XOR<quote_detailUpdateWithoutQuoteInput, quote_detailUncheckedUpdateWithoutQuoteInput>
  }

  export type quote_detailUpdateManyWithWhereWithoutQuoteInput = {
    where: quote_detailScalarWhereInput
    data: XOR<quote_detailUpdateManyMutationInput, quote_detailUncheckedUpdateManyWithoutQuoteInput>
  }

  export type quote_detailScalarWhereInput = {
    AND?: quote_detailScalarWhereInput | quote_detailScalarWhereInput[]
    OR?: quote_detailScalarWhereInput[]
    NOT?: quote_detailScalarWhereInput | quote_detailScalarWhereInput[]
    id?: UuidFilter<"quote_detail"> | string
    quote_id?: UuidNullableFilter<"quote_detail"> | string | null
    service_id?: UuidNullableFilter<"quote_detail"> | string | null
    item?: IntNullableFilter<"quote_detail"> | number | null
    quantity?: IntNullableFilter<"quote_detail"> | number | null
    total_value?: FloatNullableFilter<"quote_detail"> | number | null
    created?: DateTimeNullableFilter<"quote_detail"> | Date | string | null
    updated?: DateTimeNullableFilter<"quote_detail"> | Date | string | null
    status?: BoolNullableFilter<"quote_detail"> | boolean | null
  }

  export type invoiceCreateWithoutQuote_attachmentInput = {
    id: string
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client?: clientCreateNestedOneWithoutInvoiceInput
    invoice_detail?: invoice_detailCreateNestedManyWithoutInvoiceInput
    payment_attachment?: payment_attachmentCreateNestedManyWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateWithoutQuote_attachmentInput = {
    id: string
    client_id?: string | null
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    invoice_detail?: invoice_detailUncheckedCreateNestedManyWithoutInvoiceInput
    payment_attachment?: payment_attachmentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type invoiceCreateOrConnectWithoutQuote_attachmentInput = {
    where: invoiceWhereUniqueInput
    create: XOR<invoiceCreateWithoutQuote_attachmentInput, invoiceUncheckedCreateWithoutQuote_attachmentInput>
  }

  export type quoteCreateWithoutQuote_attachmentInput = {
    id: string
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client?: clientCreateNestedOneWithoutQuoteInput
    quote_detail?: quote_detailCreateNestedManyWithoutQuoteInput
  }

  export type quoteUncheckedCreateWithoutQuote_attachmentInput = {
    id: string
    client_id?: string | null
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    quote_detail?: quote_detailUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type quoteCreateOrConnectWithoutQuote_attachmentInput = {
    where: quoteWhereUniqueInput
    create: XOR<quoteCreateWithoutQuote_attachmentInput, quoteUncheckedCreateWithoutQuote_attachmentInput>
  }

  export type invoiceUpsertWithoutQuote_attachmentInput = {
    update: XOR<invoiceUpdateWithoutQuote_attachmentInput, invoiceUncheckedUpdateWithoutQuote_attachmentInput>
    create: XOR<invoiceCreateWithoutQuote_attachmentInput, invoiceUncheckedCreateWithoutQuote_attachmentInput>
    where?: invoiceWhereInput
  }

  export type invoiceUpdateToOneWithWhereWithoutQuote_attachmentInput = {
    where?: invoiceWhereInput
    data: XOR<invoiceUpdateWithoutQuote_attachmentInput, invoiceUncheckedUpdateWithoutQuote_attachmentInput>
  }

  export type invoiceUpdateWithoutQuote_attachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client?: clientUpdateOneWithoutInvoiceNestedInput
    invoice_detail?: invoice_detailUpdateManyWithoutInvoiceNestedInput
    payment_attachment?: payment_attachmentUpdateManyWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateWithoutQuote_attachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    invoice_detail?: invoice_detailUncheckedUpdateManyWithoutInvoiceNestedInput
    payment_attachment?: payment_attachmentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type quoteUpsertWithoutQuote_attachmentInput = {
    update: XOR<quoteUpdateWithoutQuote_attachmentInput, quoteUncheckedUpdateWithoutQuote_attachmentInput>
    create: XOR<quoteCreateWithoutQuote_attachmentInput, quoteUncheckedCreateWithoutQuote_attachmentInput>
    where?: quoteWhereInput
  }

  export type quoteUpdateToOneWithWhereWithoutQuote_attachmentInput = {
    where?: quoteWhereInput
    data: XOR<quoteUpdateWithoutQuote_attachmentInput, quoteUncheckedUpdateWithoutQuote_attachmentInput>
  }

  export type quoteUpdateWithoutQuote_attachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client?: clientUpdateOneWithoutQuoteNestedInput
    quote_detail?: quote_detailUpdateManyWithoutQuoteNestedInput
  }

  export type quoteUncheckedUpdateWithoutQuote_attachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quote_detail?: quote_detailUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type quoteCreateWithoutQuote_detailInput = {
    id: string
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client?: clientCreateNestedOneWithoutQuoteInput
    quote_attachment?: quote_attachmentCreateNestedManyWithoutQuoteInput
  }

  export type quoteUncheckedCreateWithoutQuote_detailInput = {
    id: string
    client_id?: string | null
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    quote_attachment?: quote_attachmentUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type quoteCreateOrConnectWithoutQuote_detailInput = {
    where: quoteWhereUniqueInput
    create: XOR<quoteCreateWithoutQuote_detailInput, quoteUncheckedCreateWithoutQuote_detailInput>
  }

  export type serviceCreateWithoutQuote_detailInput = {
    id: string
    name?: string | null
    unit?: string | null
    description?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_service?: client_serviceCreateNestedManyWithoutServiceInput
    invoice_detail?: invoice_detailCreateNestedManyWithoutServiceInput
    service_category?: service_categoryCreateNestedOneWithoutServiceInput
    service_usage?: service_usageCreateNestedManyWithoutServiceInput
  }

  export type serviceUncheckedCreateWithoutQuote_detailInput = {
    id: string
    service_category_id?: string | null
    name?: string | null
    unit?: string | null
    description?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_service?: client_serviceUncheckedCreateNestedManyWithoutServiceInput
    invoice_detail?: invoice_detailUncheckedCreateNestedManyWithoutServiceInput
    service_usage?: service_usageUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceCreateOrConnectWithoutQuote_detailInput = {
    where: serviceWhereUniqueInput
    create: XOR<serviceCreateWithoutQuote_detailInput, serviceUncheckedCreateWithoutQuote_detailInput>
  }

  export type quoteUpsertWithoutQuote_detailInput = {
    update: XOR<quoteUpdateWithoutQuote_detailInput, quoteUncheckedUpdateWithoutQuote_detailInput>
    create: XOR<quoteCreateWithoutQuote_detailInput, quoteUncheckedCreateWithoutQuote_detailInput>
    where?: quoteWhereInput
  }

  export type quoteUpdateToOneWithWhereWithoutQuote_detailInput = {
    where?: quoteWhereInput
    data: XOR<quoteUpdateWithoutQuote_detailInput, quoteUncheckedUpdateWithoutQuote_detailInput>
  }

  export type quoteUpdateWithoutQuote_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client?: clientUpdateOneWithoutQuoteNestedInput
    quote_attachment?: quote_attachmentUpdateManyWithoutQuoteNestedInput
  }

  export type quoteUncheckedUpdateWithoutQuote_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quote_attachment?: quote_attachmentUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type serviceUpsertWithoutQuote_detailInput = {
    update: XOR<serviceUpdateWithoutQuote_detailInput, serviceUncheckedUpdateWithoutQuote_detailInput>
    create: XOR<serviceCreateWithoutQuote_detailInput, serviceUncheckedCreateWithoutQuote_detailInput>
    where?: serviceWhereInput
  }

  export type serviceUpdateToOneWithWhereWithoutQuote_detailInput = {
    where?: serviceWhereInput
    data: XOR<serviceUpdateWithoutQuote_detailInput, serviceUncheckedUpdateWithoutQuote_detailInput>
  }

  export type serviceUpdateWithoutQuote_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_service?: client_serviceUpdateManyWithoutServiceNestedInput
    invoice_detail?: invoice_detailUpdateManyWithoutServiceNestedInput
    service_category?: service_categoryUpdateOneWithoutServiceNestedInput
    service_usage?: service_usageUpdateManyWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateWithoutQuote_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_service?: client_serviceUncheckedUpdateManyWithoutServiceNestedInput
    invoice_detail?: invoice_detailUncheckedUpdateManyWithoutServiceNestedInput
    service_usage?: service_usageUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type logCreateWithoutRoleInput = {
    id: string
    user_name?: string | null
    ip?: string | null
    type?: string | null
    detail?: string | null
    created?: Date | string | null
    client?: clientCreateNestedOneWithoutLogInput
    user?: userCreateNestedOneWithoutLogInput
  }

  export type logUncheckedCreateWithoutRoleInput = {
    id: string
    user_id?: string | null
    client_id?: string | null
    user_name?: string | null
    ip?: string | null
    type?: string | null
    detail?: string | null
    created?: Date | string | null
  }

  export type logCreateOrConnectWithoutRoleInput = {
    where: logWhereUniqueInput
    create: XOR<logCreateWithoutRoleInput, logUncheckedCreateWithoutRoleInput>
  }

  export type logCreateManyRoleInputEnvelope = {
    data: logCreateManyRoleInput | logCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type role_permissionCreateWithoutRoleInput = {
    id: string
    permission?: permissionCreateNestedOneWithoutRole_permissionInput
  }

  export type role_permissionUncheckedCreateWithoutRoleInput = {
    id: string
    permission_id?: string | null
  }

  export type role_permissionCreateOrConnectWithoutRoleInput = {
    where: role_permissionWhereUniqueInput
    create: XOR<role_permissionCreateWithoutRoleInput, role_permissionUncheckedCreateWithoutRoleInput>
  }

  export type role_permissionCreateManyRoleInputEnvelope = {
    data: role_permissionCreateManyRoleInput | role_permissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutRoleInput = {
    id: string
    user?: string | null
    pass?: string | null
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    log?: logCreateNestedManyWithoutUserInput
    client?: clientCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutRoleInput = {
    id: string
    client_id?: string | null
    user?: string | null
    pass?: string | null
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    log?: logUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRoleInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput>
  }

  export type userCreateManyRoleInputEnvelope = {
    data: userCreateManyRoleInput | userCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type logUpsertWithWhereUniqueWithoutRoleInput = {
    where: logWhereUniqueInput
    update: XOR<logUpdateWithoutRoleInput, logUncheckedUpdateWithoutRoleInput>
    create: XOR<logCreateWithoutRoleInput, logUncheckedCreateWithoutRoleInput>
  }

  export type logUpdateWithWhereUniqueWithoutRoleInput = {
    where: logWhereUniqueInput
    data: XOR<logUpdateWithoutRoleInput, logUncheckedUpdateWithoutRoleInput>
  }

  export type logUpdateManyWithWhereWithoutRoleInput = {
    where: logScalarWhereInput
    data: XOR<logUpdateManyMutationInput, logUncheckedUpdateManyWithoutRoleInput>
  }

  export type role_permissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: role_permissionWhereUniqueInput
    update: XOR<role_permissionUpdateWithoutRoleInput, role_permissionUncheckedUpdateWithoutRoleInput>
    create: XOR<role_permissionCreateWithoutRoleInput, role_permissionUncheckedCreateWithoutRoleInput>
  }

  export type role_permissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: role_permissionWhereUniqueInput
    data: XOR<role_permissionUpdateWithoutRoleInput, role_permissionUncheckedUpdateWithoutRoleInput>
  }

  export type role_permissionUpdateManyWithWhereWithoutRoleInput = {
    where: role_permissionScalarWhereInput
    data: XOR<role_permissionUpdateManyMutationInput, role_permissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type userUpsertWithWhereUniqueWithoutRoleInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutRoleInput, userUncheckedUpdateWithoutRoleInput>
    create: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput>
  }

  export type userUpdateWithWhereUniqueWithoutRoleInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutRoleInput, userUncheckedUpdateWithoutRoleInput>
  }

  export type userUpdateManyWithWhereWithoutRoleInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutRoleInput>
  }

  export type permissionCreateWithoutRole_permissionInput = {
    id: string
    name?: string | null
    section?: string | null
  }

  export type permissionUncheckedCreateWithoutRole_permissionInput = {
    id: string
    name?: string | null
    section?: string | null
  }

  export type permissionCreateOrConnectWithoutRole_permissionInput = {
    where: permissionWhereUniqueInput
    create: XOR<permissionCreateWithoutRole_permissionInput, permissionUncheckedCreateWithoutRole_permissionInput>
  }

  export type roleCreateWithoutRole_permissionInput = {
    id: string
    name?: string | null
    role_category?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    description?: string | null
    log?: logCreateNestedManyWithoutRoleInput
    user?: userCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateWithoutRole_permissionInput = {
    id: string
    name?: string | null
    role_category?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    description?: string | null
    log?: logUncheckedCreateNestedManyWithoutRoleInput
    user?: userUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleCreateOrConnectWithoutRole_permissionInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutRole_permissionInput, roleUncheckedCreateWithoutRole_permissionInput>
  }

  export type permissionUpsertWithoutRole_permissionInput = {
    update: XOR<permissionUpdateWithoutRole_permissionInput, permissionUncheckedUpdateWithoutRole_permissionInput>
    create: XOR<permissionCreateWithoutRole_permissionInput, permissionUncheckedCreateWithoutRole_permissionInput>
    where?: permissionWhereInput
  }

  export type permissionUpdateToOneWithWhereWithoutRole_permissionInput = {
    where?: permissionWhereInput
    data: XOR<permissionUpdateWithoutRole_permissionInput, permissionUncheckedUpdateWithoutRole_permissionInput>
  }

  export type permissionUpdateWithoutRole_permissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permissionUncheckedUpdateWithoutRole_permissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roleUpsertWithoutRole_permissionInput = {
    update: XOR<roleUpdateWithoutRole_permissionInput, roleUncheckedUpdateWithoutRole_permissionInput>
    create: XOR<roleCreateWithoutRole_permissionInput, roleUncheckedCreateWithoutRole_permissionInput>
    where?: roleWhereInput
  }

  export type roleUpdateToOneWithWhereWithoutRole_permissionInput = {
    where?: roleWhereInput
    data: XOR<roleUpdateWithoutRole_permissionInput, roleUncheckedUpdateWithoutRole_permissionInput>
  }

  export type roleUpdateWithoutRole_permissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role_category?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    log?: logUpdateManyWithoutRoleNestedInput
    user?: userUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateWithoutRole_permissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role_category?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    log?: logUncheckedUpdateManyWithoutRoleNestedInput
    user?: userUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type client_serviceCreateWithoutServiceInput = {
    id: string
    created?: Date | string | null
    updated?: Date | string | null
    started?: Date | string | null
    delivery?: Date | string | null
    expiry?: Date | string | null
    frequency?: string | null
    unit?: string | null
    url_api?: string | null
    token_api?: string | null
    client?: clientCreateNestedOneWithoutClient_serviceInput
  }

  export type client_serviceUncheckedCreateWithoutServiceInput = {
    id: string
    client_id?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    started?: Date | string | null
    delivery?: Date | string | null
    expiry?: Date | string | null
    frequency?: string | null
    unit?: string | null
    url_api?: string | null
    token_api?: string | null
  }

  export type client_serviceCreateOrConnectWithoutServiceInput = {
    where: client_serviceWhereUniqueInput
    create: XOR<client_serviceCreateWithoutServiceInput, client_serviceUncheckedCreateWithoutServiceInput>
  }

  export type client_serviceCreateManyServiceInputEnvelope = {
    data: client_serviceCreateManyServiceInput | client_serviceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type invoice_detailCreateWithoutServiceInput = {
    id: string
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    invoice?: invoiceCreateNestedOneWithoutInvoice_detailInput
  }

  export type invoice_detailUncheckedCreateWithoutServiceInput = {
    id: string
    invoice_id?: string | null
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type invoice_detailCreateOrConnectWithoutServiceInput = {
    where: invoice_detailWhereUniqueInput
    create: XOR<invoice_detailCreateWithoutServiceInput, invoice_detailUncheckedCreateWithoutServiceInput>
  }

  export type invoice_detailCreateManyServiceInputEnvelope = {
    data: invoice_detailCreateManyServiceInput | invoice_detailCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type quote_detailCreateWithoutServiceInput = {
    id: string
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    quote?: quoteCreateNestedOneWithoutQuote_detailInput
  }

  export type quote_detailUncheckedCreateWithoutServiceInput = {
    id: string
    quote_id?: string | null
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type quote_detailCreateOrConnectWithoutServiceInput = {
    where: quote_detailWhereUniqueInput
    create: XOR<quote_detailCreateWithoutServiceInput, quote_detailUncheckedCreateWithoutServiceInput>
  }

  export type quote_detailCreateManyServiceInputEnvelope = {
    data: quote_detailCreateManyServiceInput | quote_detailCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type service_categoryCreateWithoutServiceInput = {
    id: string
    name?: string | null
  }

  export type service_categoryUncheckedCreateWithoutServiceInput = {
    id: string
    name?: string | null
  }

  export type service_categoryCreateOrConnectWithoutServiceInput = {
    where: service_categoryWhereUniqueInput
    create: XOR<service_categoryCreateWithoutServiceInput, service_categoryUncheckedCreateWithoutServiceInput>
  }

  export type service_usageCreateWithoutServiceInput = {
    id: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    usage?: string | null
    created?: Date | string | null
    status?: string | null
    client?: clientCreateNestedOneWithoutService_usageInput
  }

  export type service_usageUncheckedCreateWithoutServiceInput = {
    id: string
    client_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    usage?: string | null
    created?: Date | string | null
    status?: string | null
  }

  export type service_usageCreateOrConnectWithoutServiceInput = {
    where: service_usageWhereUniqueInput
    create: XOR<service_usageCreateWithoutServiceInput, service_usageUncheckedCreateWithoutServiceInput>
  }

  export type service_usageCreateManyServiceInputEnvelope = {
    data: service_usageCreateManyServiceInput | service_usageCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type client_serviceUpsertWithWhereUniqueWithoutServiceInput = {
    where: client_serviceWhereUniqueInput
    update: XOR<client_serviceUpdateWithoutServiceInput, client_serviceUncheckedUpdateWithoutServiceInput>
    create: XOR<client_serviceCreateWithoutServiceInput, client_serviceUncheckedCreateWithoutServiceInput>
  }

  export type client_serviceUpdateWithWhereUniqueWithoutServiceInput = {
    where: client_serviceWhereUniqueInput
    data: XOR<client_serviceUpdateWithoutServiceInput, client_serviceUncheckedUpdateWithoutServiceInput>
  }

  export type client_serviceUpdateManyWithWhereWithoutServiceInput = {
    where: client_serviceScalarWhereInput
    data: XOR<client_serviceUpdateManyMutationInput, client_serviceUncheckedUpdateManyWithoutServiceInput>
  }

  export type invoice_detailUpsertWithWhereUniqueWithoutServiceInput = {
    where: invoice_detailWhereUniqueInput
    update: XOR<invoice_detailUpdateWithoutServiceInput, invoice_detailUncheckedUpdateWithoutServiceInput>
    create: XOR<invoice_detailCreateWithoutServiceInput, invoice_detailUncheckedCreateWithoutServiceInput>
  }

  export type invoice_detailUpdateWithWhereUniqueWithoutServiceInput = {
    where: invoice_detailWhereUniqueInput
    data: XOR<invoice_detailUpdateWithoutServiceInput, invoice_detailUncheckedUpdateWithoutServiceInput>
  }

  export type invoice_detailUpdateManyWithWhereWithoutServiceInput = {
    where: invoice_detailScalarWhereInput
    data: XOR<invoice_detailUpdateManyMutationInput, invoice_detailUncheckedUpdateManyWithoutServiceInput>
  }

  export type quote_detailUpsertWithWhereUniqueWithoutServiceInput = {
    where: quote_detailWhereUniqueInput
    update: XOR<quote_detailUpdateWithoutServiceInput, quote_detailUncheckedUpdateWithoutServiceInput>
    create: XOR<quote_detailCreateWithoutServiceInput, quote_detailUncheckedCreateWithoutServiceInput>
  }

  export type quote_detailUpdateWithWhereUniqueWithoutServiceInput = {
    where: quote_detailWhereUniqueInput
    data: XOR<quote_detailUpdateWithoutServiceInput, quote_detailUncheckedUpdateWithoutServiceInput>
  }

  export type quote_detailUpdateManyWithWhereWithoutServiceInput = {
    where: quote_detailScalarWhereInput
    data: XOR<quote_detailUpdateManyMutationInput, quote_detailUncheckedUpdateManyWithoutServiceInput>
  }

  export type service_categoryUpsertWithoutServiceInput = {
    update: XOR<service_categoryUpdateWithoutServiceInput, service_categoryUncheckedUpdateWithoutServiceInput>
    create: XOR<service_categoryCreateWithoutServiceInput, service_categoryUncheckedCreateWithoutServiceInput>
    where?: service_categoryWhereInput
  }

  export type service_categoryUpdateToOneWithWhereWithoutServiceInput = {
    where?: service_categoryWhereInput
    data: XOR<service_categoryUpdateWithoutServiceInput, service_categoryUncheckedUpdateWithoutServiceInput>
  }

  export type service_categoryUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type service_categoryUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type service_usageUpsertWithWhereUniqueWithoutServiceInput = {
    where: service_usageWhereUniqueInput
    update: XOR<service_usageUpdateWithoutServiceInput, service_usageUncheckedUpdateWithoutServiceInput>
    create: XOR<service_usageCreateWithoutServiceInput, service_usageUncheckedCreateWithoutServiceInput>
  }

  export type service_usageUpdateWithWhereUniqueWithoutServiceInput = {
    where: service_usageWhereUniqueInput
    data: XOR<service_usageUpdateWithoutServiceInput, service_usageUncheckedUpdateWithoutServiceInput>
  }

  export type service_usageUpdateManyWithWhereWithoutServiceInput = {
    where: service_usageScalarWhereInput
    data: XOR<service_usageUpdateManyMutationInput, service_usageUncheckedUpdateManyWithoutServiceInput>
  }

  export type serviceCreateWithoutService_categoryInput = {
    id: string
    name?: string | null
    unit?: string | null
    description?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_service?: client_serviceCreateNestedManyWithoutServiceInput
    invoice_detail?: invoice_detailCreateNestedManyWithoutServiceInput
    quote_detail?: quote_detailCreateNestedManyWithoutServiceInput
    service_usage?: service_usageCreateNestedManyWithoutServiceInput
  }

  export type serviceUncheckedCreateWithoutService_categoryInput = {
    id: string
    name?: string | null
    unit?: string | null
    description?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_service?: client_serviceUncheckedCreateNestedManyWithoutServiceInput
    invoice_detail?: invoice_detailUncheckedCreateNestedManyWithoutServiceInput
    quote_detail?: quote_detailUncheckedCreateNestedManyWithoutServiceInput
    service_usage?: service_usageUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceCreateOrConnectWithoutService_categoryInput = {
    where: serviceWhereUniqueInput
    create: XOR<serviceCreateWithoutService_categoryInput, serviceUncheckedCreateWithoutService_categoryInput>
  }

  export type serviceCreateManyService_categoryInputEnvelope = {
    data: serviceCreateManyService_categoryInput | serviceCreateManyService_categoryInput[]
    skipDuplicates?: boolean
  }

  export type serviceUpsertWithWhereUniqueWithoutService_categoryInput = {
    where: serviceWhereUniqueInput
    update: XOR<serviceUpdateWithoutService_categoryInput, serviceUncheckedUpdateWithoutService_categoryInput>
    create: XOR<serviceCreateWithoutService_categoryInput, serviceUncheckedCreateWithoutService_categoryInput>
  }

  export type serviceUpdateWithWhereUniqueWithoutService_categoryInput = {
    where: serviceWhereUniqueInput
    data: XOR<serviceUpdateWithoutService_categoryInput, serviceUncheckedUpdateWithoutService_categoryInput>
  }

  export type serviceUpdateManyWithWhereWithoutService_categoryInput = {
    where: serviceScalarWhereInput
    data: XOR<serviceUpdateManyMutationInput, serviceUncheckedUpdateManyWithoutService_categoryInput>
  }

  export type serviceScalarWhereInput = {
    AND?: serviceScalarWhereInput | serviceScalarWhereInput[]
    OR?: serviceScalarWhereInput[]
    NOT?: serviceScalarWhereInput | serviceScalarWhereInput[]
    id?: UuidFilter<"service"> | string
    service_category_id?: UuidNullableFilter<"service"> | string | null
    name?: StringNullableFilter<"service"> | string | null
    unit?: StringNullableFilter<"service"> | string | null
    description?: StringNullableFilter<"service"> | string | null
    created?: DateTimeNullableFilter<"service"> | Date | string | null
    updated?: DateTimeNullableFilter<"service"> | Date | string | null
    status?: BoolNullableFilter<"service"> | boolean | null
  }

  export type clientCreateWithoutService_usageInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_details?: client_detailsCreateNestedManyWithoutClientInput
    client_service?: client_serviceCreateNestedManyWithoutClientInput
    invoice?: invoiceCreateNestedManyWithoutClientInput
    log?: logCreateNestedManyWithoutClientInput
    payment?: paymentCreateNestedManyWithoutClientInput
    quote?: quoteCreateNestedManyWithoutClientInput
    user?: userCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateWithoutService_usageInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_details?: client_detailsUncheckedCreateNestedManyWithoutClientInput
    client_service?: client_serviceUncheckedCreateNestedManyWithoutClientInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClientInput
    log?: logUncheckedCreateNestedManyWithoutClientInput
    payment?: paymentUncheckedCreateNestedManyWithoutClientInput
    quote?: quoteUncheckedCreateNestedManyWithoutClientInput
    user?: userUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientCreateOrConnectWithoutService_usageInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutService_usageInput, clientUncheckedCreateWithoutService_usageInput>
  }

  export type serviceCreateWithoutService_usageInput = {
    id: string
    name?: string | null
    unit?: string | null
    description?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_service?: client_serviceCreateNestedManyWithoutServiceInput
    invoice_detail?: invoice_detailCreateNestedManyWithoutServiceInput
    quote_detail?: quote_detailCreateNestedManyWithoutServiceInput
    service_category?: service_categoryCreateNestedOneWithoutServiceInput
  }

  export type serviceUncheckedCreateWithoutService_usageInput = {
    id: string
    service_category_id?: string | null
    name?: string | null
    unit?: string | null
    description?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_service?: client_serviceUncheckedCreateNestedManyWithoutServiceInput
    invoice_detail?: invoice_detailUncheckedCreateNestedManyWithoutServiceInput
    quote_detail?: quote_detailUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceCreateOrConnectWithoutService_usageInput = {
    where: serviceWhereUniqueInput
    create: XOR<serviceCreateWithoutService_usageInput, serviceUncheckedCreateWithoutService_usageInput>
  }

  export type clientUpsertWithoutService_usageInput = {
    update: XOR<clientUpdateWithoutService_usageInput, clientUncheckedUpdateWithoutService_usageInput>
    create: XOR<clientCreateWithoutService_usageInput, clientUncheckedCreateWithoutService_usageInput>
    where?: clientWhereInput
  }

  export type clientUpdateToOneWithWhereWithoutService_usageInput = {
    where?: clientWhereInput
    data: XOR<clientUpdateWithoutService_usageInput, clientUncheckedUpdateWithoutService_usageInput>
  }

  export type clientUpdateWithoutService_usageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_details?: client_detailsUpdateManyWithoutClientNestedInput
    client_service?: client_serviceUpdateManyWithoutClientNestedInput
    invoice?: invoiceUpdateManyWithoutClientNestedInput
    log?: logUpdateManyWithoutClientNestedInput
    payment?: paymentUpdateManyWithoutClientNestedInput
    quote?: quoteUpdateManyWithoutClientNestedInput
    user?: userUpdateManyWithoutClientNestedInput
  }

  export type clientUncheckedUpdateWithoutService_usageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_details?: client_detailsUncheckedUpdateManyWithoutClientNestedInput
    client_service?: client_serviceUncheckedUpdateManyWithoutClientNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClientNestedInput
    log?: logUncheckedUpdateManyWithoutClientNestedInput
    payment?: paymentUncheckedUpdateManyWithoutClientNestedInput
    quote?: quoteUncheckedUpdateManyWithoutClientNestedInput
    user?: userUncheckedUpdateManyWithoutClientNestedInput
  }

  export type serviceUpsertWithoutService_usageInput = {
    update: XOR<serviceUpdateWithoutService_usageInput, serviceUncheckedUpdateWithoutService_usageInput>
    create: XOR<serviceCreateWithoutService_usageInput, serviceUncheckedCreateWithoutService_usageInput>
    where?: serviceWhereInput
  }

  export type serviceUpdateToOneWithWhereWithoutService_usageInput = {
    where?: serviceWhereInput
    data: XOR<serviceUpdateWithoutService_usageInput, serviceUncheckedUpdateWithoutService_usageInput>
  }

  export type serviceUpdateWithoutService_usageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_service?: client_serviceUpdateManyWithoutServiceNestedInput
    invoice_detail?: invoice_detailUpdateManyWithoutServiceNestedInput
    quote_detail?: quote_detailUpdateManyWithoutServiceNestedInput
    service_category?: service_categoryUpdateOneWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateWithoutService_usageInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_service?: client_serviceUncheckedUpdateManyWithoutServiceNestedInput
    invoice_detail?: invoice_detailUncheckedUpdateManyWithoutServiceNestedInput
    quote_detail?: quote_detailUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type logCreateWithoutUserInput = {
    id: string
    user_name?: string | null
    ip?: string | null
    type?: string | null
    detail?: string | null
    created?: Date | string | null
    client?: clientCreateNestedOneWithoutLogInput
    role?: roleCreateNestedOneWithoutLogInput
  }

  export type logUncheckedCreateWithoutUserInput = {
    id: string
    role_id?: string | null
    client_id?: string | null
    user_name?: string | null
    ip?: string | null
    type?: string | null
    detail?: string | null
    created?: Date | string | null
  }

  export type logCreateOrConnectWithoutUserInput = {
    where: logWhereUniqueInput
    create: XOR<logCreateWithoutUserInput, logUncheckedCreateWithoutUserInput>
  }

  export type logCreateManyUserInputEnvelope = {
    data: logCreateManyUserInput | logCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type clientCreateWithoutUserInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_details?: client_detailsCreateNestedManyWithoutClientInput
    client_service?: client_serviceCreateNestedManyWithoutClientInput
    invoice?: invoiceCreateNestedManyWithoutClientInput
    log?: logCreateNestedManyWithoutClientInput
    payment?: paymentCreateNestedManyWithoutClientInput
    quote?: quoteCreateNestedManyWithoutClientInput
    service_usage?: service_usageCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateWithoutUserInput = {
    id: string
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    client_details?: client_detailsUncheckedCreateNestedManyWithoutClientInput
    client_service?: client_serviceUncheckedCreateNestedManyWithoutClientInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClientInput
    log?: logUncheckedCreateNestedManyWithoutClientInput
    payment?: paymentUncheckedCreateNestedManyWithoutClientInput
    quote?: quoteUncheckedCreateNestedManyWithoutClientInput
    service_usage?: service_usageUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientCreateOrConnectWithoutUserInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutUserInput, clientUncheckedCreateWithoutUserInput>
  }

  export type roleCreateWithoutUserInput = {
    id: string
    name?: string | null
    role_category?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    description?: string | null
    log?: logCreateNestedManyWithoutRoleInput
    role_permission?: role_permissionCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateWithoutUserInput = {
    id: string
    name?: string | null
    role_category?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
    description?: string | null
    log?: logUncheckedCreateNestedManyWithoutRoleInput
    role_permission?: role_permissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleCreateOrConnectWithoutUserInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutUserInput, roleUncheckedCreateWithoutUserInput>
  }

  export type logUpsertWithWhereUniqueWithoutUserInput = {
    where: logWhereUniqueInput
    update: XOR<logUpdateWithoutUserInput, logUncheckedUpdateWithoutUserInput>
    create: XOR<logCreateWithoutUserInput, logUncheckedCreateWithoutUserInput>
  }

  export type logUpdateWithWhereUniqueWithoutUserInput = {
    where: logWhereUniqueInput
    data: XOR<logUpdateWithoutUserInput, logUncheckedUpdateWithoutUserInput>
  }

  export type logUpdateManyWithWhereWithoutUserInput = {
    where: logScalarWhereInput
    data: XOR<logUpdateManyMutationInput, logUncheckedUpdateManyWithoutUserInput>
  }

  export type clientUpsertWithoutUserInput = {
    update: XOR<clientUpdateWithoutUserInput, clientUncheckedUpdateWithoutUserInput>
    create: XOR<clientCreateWithoutUserInput, clientUncheckedCreateWithoutUserInput>
    where?: clientWhereInput
  }

  export type clientUpdateToOneWithWhereWithoutUserInput = {
    where?: clientWhereInput
    data: XOR<clientUpdateWithoutUserInput, clientUncheckedUpdateWithoutUserInput>
  }

  export type clientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_details?: client_detailsUpdateManyWithoutClientNestedInput
    client_service?: client_serviceUpdateManyWithoutClientNestedInput
    invoice?: invoiceUpdateManyWithoutClientNestedInput
    log?: logUpdateManyWithoutClientNestedInput
    payment?: paymentUpdateManyWithoutClientNestedInput
    quote?: quoteUpdateManyWithoutClientNestedInput
    service_usage?: service_usageUpdateManyWithoutClientNestedInput
  }

  export type clientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_details?: client_detailsUncheckedUpdateManyWithoutClientNestedInput
    client_service?: client_serviceUncheckedUpdateManyWithoutClientNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClientNestedInput
    log?: logUncheckedUpdateManyWithoutClientNestedInput
    payment?: paymentUncheckedUpdateManyWithoutClientNestedInput
    quote?: quoteUncheckedUpdateManyWithoutClientNestedInput
    service_usage?: service_usageUncheckedUpdateManyWithoutClientNestedInput
  }

  export type roleUpsertWithoutUserInput = {
    update: XOR<roleUpdateWithoutUserInput, roleUncheckedUpdateWithoutUserInput>
    create: XOR<roleCreateWithoutUserInput, roleUncheckedCreateWithoutUserInput>
    where?: roleWhereInput
  }

  export type roleUpdateToOneWithWhereWithoutUserInput = {
    where?: roleWhereInput
    data: XOR<roleUpdateWithoutUserInput, roleUncheckedUpdateWithoutUserInput>
  }

  export type roleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role_category?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    log?: logUpdateManyWithoutRoleNestedInput
    role_permission?: role_permissionUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role_category?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    log?: logUncheckedUpdateManyWithoutRoleNestedInput
    role_permission?: role_permissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type client_detailsCreateManyClientInput = {
    id: string
    c_parameter_id?: string | null
    value?: string | null
  }

  export type client_serviceCreateManyClientInput = {
    id: string
    service_id?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    started?: Date | string | null
    delivery?: Date | string | null
    expiry?: Date | string | null
    frequency?: string | null
    unit?: string | null
    url_api?: string | null
    token_api?: string | null
  }

  export type invoiceCreateManyClientInput = {
    id: string
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type logCreateManyClientInput = {
    id: string
    user_id?: string | null
    role_id?: string | null
    user_name?: string | null
    ip?: string | null
    type?: string | null
    detail?: string | null
    created?: Date | string | null
  }

  export type paymentCreateManyClientInput = {
    id: string
    code?: string | null
    value?: string | null
    status_pay?: string | null
    method?: string | null
    payment_method_id?: string | null
    type?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type quoteCreateManyClientInput = {
    id: string
    description?: string | null
    value?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type service_usageCreateManyClientInput = {
    id: string
    service_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    usage?: string | null
    created?: Date | string | null
    status?: string | null
  }

  export type userCreateManyClientInput = {
    id: string
    role_id?: string | null
    user?: string | null
    pass?: string | null
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type client_detailsUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    client_parameter?: client_parameterUpdateOneWithoutClient_detailsNestedInput
  }

  export type client_detailsUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    c_parameter_id?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type client_detailsUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    c_parameter_id?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type client_serviceUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    url_api?: NullableStringFieldUpdateOperationsInput | string | null
    token_api?: NullableStringFieldUpdateOperationsInput | string | null
    service?: serviceUpdateOneWithoutClient_serviceNestedInput
  }

  export type client_serviceUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    url_api?: NullableStringFieldUpdateOperationsInput | string | null
    token_api?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type client_serviceUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    url_api?: NullableStringFieldUpdateOperationsInput | string | null
    token_api?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invoiceUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    invoice_detail?: invoice_detailUpdateManyWithoutInvoiceNestedInput
    payment_attachment?: payment_attachmentUpdateManyWithoutInvoiceNestedInput
    quote_attachment?: quote_attachmentUpdateManyWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    invoice_detail?: invoice_detailUncheckedUpdateManyWithoutInvoiceNestedInput
    payment_attachment?: payment_attachmentUncheckedUpdateManyWithoutInvoiceNestedInput
    quote_attachment?: quote_attachmentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type logUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: roleUpdateOneWithoutLogNestedInput
    user?: userUpdateOneWithoutLogNestedInput
  }

  export type logUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type logUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    status_pay?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_method?: payment_methodUpdateOneWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    status_pay?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type paymentUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    status_pay?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type quoteUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quote_attachment?: quote_attachmentUpdateManyWithoutQuoteNestedInput
    quote_detail?: quote_detailUpdateManyWithoutQuoteNestedInput
  }

  export type quoteUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quote_attachment?: quote_attachmentUncheckedUpdateManyWithoutQuoteNestedInput
    quote_detail?: quote_detailUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type quoteUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type service_usageUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usage?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    service?: serviceUpdateOneWithoutService_usageNestedInput
  }

  export type service_usageUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usage?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type service_usageUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usage?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    log?: logUpdateManyWithoutUserNestedInput
    role?: roleUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    log?: logUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type client_detailsCreateManyClient_parameterInput = {
    id: string
    client_id?: string | null
    value?: string | null
  }

  export type client_detailsUpdateWithoutClient_parameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    client?: clientUpdateOneWithoutClient_detailsNestedInput
  }

  export type client_detailsUncheckedUpdateWithoutClient_parameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type client_detailsUncheckedUpdateManyWithoutClient_parameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invoice_detailCreateManyInvoiceInput = {
    id: string
    service_id?: string | null
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type payment_attachmentCreateManyInvoiceInput = {
    id: string
  }

  export type quote_attachmentCreateManyInvoiceInput = {
    id: string
    quote_id?: string | null
  }

  export type invoice_detailUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    service?: serviceUpdateOneWithoutInvoice_detailNestedInput
  }

  export type invoice_detailUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invoice_detailUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type payment_attachmentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type payment_attachmentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type payment_attachmentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type quote_attachmentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: quoteUpdateOneWithoutQuote_attachmentNestedInput
  }

  export type quote_attachmentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quote_attachmentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentCreateManyPayment_methodInput = {
    id: string
    client_id?: string | null
    code?: string | null
    value?: string | null
    status_pay?: string | null
    method?: string | null
    type?: string | null
    url?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type paymentUpdateWithoutPayment_methodInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    status_pay?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client?: clientUpdateOneWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateWithoutPayment_methodInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    status_pay?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type paymentUncheckedUpdateManyWithoutPayment_methodInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    status_pay?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type role_permissionCreateManyPermissionInput = {
    id: string
    role_id?: string | null
  }

  export type role_permissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: roleUpdateOneWithoutRole_permissionNestedInput
  }

  export type role_permissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type role_permissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quote_attachmentCreateManyQuoteInput = {
    id: string
    invoice_id?: string | null
  }

  export type quote_detailCreateManyQuoteInput = {
    id: string
    service_id?: string | null
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type quote_attachmentUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice?: invoiceUpdateOneWithoutQuote_attachmentNestedInput
  }

  export type quote_attachmentUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quote_attachmentUncheckedUpdateManyWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quote_detailUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    service?: serviceUpdateOneWithoutQuote_detailNestedInput
  }

  export type quote_detailUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type quote_detailUncheckedUpdateManyWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type logCreateManyRoleInput = {
    id: string
    user_id?: string | null
    client_id?: string | null
    user_name?: string | null
    ip?: string | null
    type?: string | null
    detail?: string | null
    created?: Date | string | null
  }

  export type role_permissionCreateManyRoleInput = {
    id: string
    permission_id?: string | null
  }

  export type userCreateManyRoleInput = {
    id: string
    client_id?: string | null
    user?: string | null
    pass?: string | null
    name?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type logUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: clientUpdateOneWithoutLogNestedInput
    user?: userUpdateOneWithoutLogNestedInput
  }

  export type logUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type logUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type role_permissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: permissionUpdateOneWithoutRole_permissionNestedInput
  }

  export type role_permissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type role_permissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    log?: logUpdateManyWithoutUserNestedInput
    client?: clientUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    log?: logUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type client_serviceCreateManyServiceInput = {
    id: string
    client_id?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    started?: Date | string | null
    delivery?: Date | string | null
    expiry?: Date | string | null
    frequency?: string | null
    unit?: string | null
    url_api?: string | null
    token_api?: string | null
  }

  export type invoice_detailCreateManyServiceInput = {
    id: string
    invoice_id?: string | null
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type quote_detailCreateManyServiceInput = {
    id: string
    quote_id?: string | null
    item?: number | null
    quantity?: number | null
    total_value?: number | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type service_usageCreateManyServiceInput = {
    id: string
    client_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    usage?: string | null
    created?: Date | string | null
    status?: string | null
  }

  export type client_serviceUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    url_api?: NullableStringFieldUpdateOperationsInput | string | null
    token_api?: NullableStringFieldUpdateOperationsInput | string | null
    client?: clientUpdateOneWithoutClient_serviceNestedInput
  }

  export type client_serviceUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    url_api?: NullableStringFieldUpdateOperationsInput | string | null
    token_api?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type client_serviceUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    url_api?: NullableStringFieldUpdateOperationsInput | string | null
    token_api?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invoice_detailUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    invoice?: invoiceUpdateOneWithoutInvoice_detailNestedInput
  }

  export type invoice_detailUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invoice_detailUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type quote_detailUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quote?: quoteUpdateOneWithoutQuote_detailNestedInput
  }

  export type quote_detailUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote_id?: NullableStringFieldUpdateOperationsInput | string | null
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type quote_detailUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote_id?: NullableStringFieldUpdateOperationsInput | string | null
    item?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type service_usageUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usage?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    client?: clientUpdateOneWithoutService_usageNestedInput
  }

  export type service_usageUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usage?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type service_usageUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usage?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviceCreateManyService_categoryInput = {
    id: string
    name?: string | null
    unit?: string | null
    description?: string | null
    created?: Date | string | null
    updated?: Date | string | null
    status?: boolean | null
  }

  export type serviceUpdateWithoutService_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_service?: client_serviceUpdateManyWithoutServiceNestedInput
    invoice_detail?: invoice_detailUpdateManyWithoutServiceNestedInput
    quote_detail?: quote_detailUpdateManyWithoutServiceNestedInput
    service_usage?: service_usageUpdateManyWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateWithoutService_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_service?: client_serviceUncheckedUpdateManyWithoutServiceNestedInput
    invoice_detail?: invoice_detailUncheckedUpdateManyWithoutServiceNestedInput
    quote_detail?: quote_detailUncheckedUpdateManyWithoutServiceNestedInput
    service_usage?: service_usageUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateManyWithoutService_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type logCreateManyUserInput = {
    id: string
    role_id?: string | null
    client_id?: string | null
    user_name?: string | null
    ip?: string | null
    type?: string | null
    detail?: string | null
    created?: Date | string | null
  }

  export type logUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: clientUpdateOneWithoutLogNestedInput
    role?: roleUpdateOneWithoutLogNestedInput
  }

  export type logUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type logUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}